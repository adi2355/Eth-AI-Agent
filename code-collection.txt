

================================================================================
File: .bolt/config.json
================================================================================

{
  "template": "nextjs-shadcn"
}


================================================================================
File: app/api/auth/nonce/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { storeNonce } from '@/lib/auth';

export async function POST(req: Request) {
  try {
    const { address } = await req.json();
    const nonce = storeNonce(address);
    
    return NextResponse.json({ nonce });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to generate nonce' },
      { status: 500 }
    );
  }
}

================================================================================
File: app/api/auth/verify/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { verifySignature, generateToken } from '@/lib/auth';

export async function POST(req: Request) {
  try {
    const { message, signature, address } = await req.json();
    
    const user = await verifySignature(message, signature, address);
    const token = generateToken(user);
    
    return NextResponse.json({ token });
  } catch (error) {
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 401 }
    );
  }
}

================================================================================
File: app/api/blockchain-query/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { AgentOrchestrator } from '@/lib/orchestrator';

const corsHeaders = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const orchestrator = new AgentOrchestrator();

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

export async function POST(req: Request) {
  try {
    let body;
    try {
      body = await req.json();
    } catch {
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400, headers: corsHeaders }
      );
    }

    const { query, sessionId } = body;
    
    if (!query?.trim()) {
      return NextResponse.json(
        { error: 'Query is required' },
        { status: 400, headers: corsHeaders }
      );
    }

    const result = await orchestrator.processQuery(query, sessionId);

    return NextResponse.json(result, { 
      status: 200, 
      headers: corsHeaders 
    });

  } catch (error) {
    console.error('API Error:', error);
    
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to process request' 
      },
      { status: 500, headers: corsHeaders }
    );
  }
}

================================================================================
File: app/api/chat/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { AgentOrchestrator } from '@/lib/orchestrator';

const orchestrator = new AgentOrchestrator();

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const corsHeaders = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

export async function POST(req: Request) {
  console.log('Chat API: Starting request processing');
  console.log('Headers:', Object.fromEntries(req.headers.entries()));

  try {
    let body;
    try {
      const text = await req.text();
      console.log('Raw request body:', text);
      body = JSON.parse(text);
      console.log('Chat API: Request body parsed:', body);
    } catch (error) {
      console.error('Chat API: JSON parsing error:', error);
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400, headers: corsHeaders }
      );
    }

    const { query, sessionId } = body;

    console.log('Chat API: Extracted sessionId:', sessionId);
    console.log('Chat API: Extracted query:', query);

    if (!query?.trim()) {
      console.log('Chat API: Empty query received');
      return NextResponse.json(
        { error: 'Query is required' },
        { status: 400, headers: corsHeaders }
      );
    }

    if (!sessionId?.trim()) {
      console.log('Chat API: No sessionId received');
      return NextResponse.json(
        { 
          error: 'Session ID is required',
          debug: { 
            body,
            headers: Object.fromEntries(req.headers.entries())
          }
        },
        { status: 400, headers: corsHeaders }
      );
    }

    console.log('Chat API: Starting chat pipeline for query:', query);
    console.log('Chat API: Using session ID:', sessionId);

    const result = await orchestrator.processQuery(query, sessionId);

    console.log('Chat API: Pipeline complete. Analysis:', result.analysis.classification.primaryIntent);
    console.log('Chat API: Generated response:', result.response);

    return NextResponse.json(
      {
        response: result.response,
        data: result.aggregatorData,
        analysis: result.analysis,
        suggestions: result.suggestions,
        contextAnalysis: result.contextAnalysis
      },
      { status: 200, headers: corsHeaders }
    );
  } catch (error) {
    console.error('Chat API error:', error);

    let errorMessage = 'Failed to process chat request';
    let statusCode = 500;

    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        errorMessage = 'Service configuration error';
        statusCode = 503;
      } else if (error.message.includes('rate limit')) {
        errorMessage = 'Service is busy, please try again in a moment';
        statusCode = 429;
      } else if (error.message.includes('validation')) {
        errorMessage = error.message;
        statusCode = 400;
      } else if (error.message.includes('Session ID is required')) {
        errorMessage = 'Session ID is required for conversation memory';
        statusCode = 400;
      } else {
        errorMessage = error.message;
      }
    }

    return NextResponse.json(
      { error: errorMessage },
      { status: statusCode, headers: corsHeaders }
    );
  }
}

================================================================================
File: app/api/token-data/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { getTrendingTokens, getTokenPrices } from '@/lib/token-data';
import { withRateLimit } from '@/lib/rate-limit';
import { withAuth } from '@/lib/middleware';

const handler = withAuth(
  withRateLimit(async (req: Request) => {
    try {
      const trendingTokens = await getTrendingTokens();
      const tokenIds = trendingTokens.map(trend => trend.item.id);
      const tokenPrices = await getTokenPrices(tokenIds);

      const enrichedTrends = trendingTokens.map(trend => ({
        ...trend,
        price_data: tokenPrices[trend.item.id] || null,
      }));

      return NextResponse.json({ data: enrichedTrends });
    } catch (error) {
      console.error('Token data error:', error);
      return NextResponse.json(
        { error: 'Failed to fetch token data' },
        { status: 500 }
      );
    }
  })
);

export { handler as GET };

================================================================================
File: collectcode.js
================================================================================

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const DEFAULT_CONFIG = {
  extensions: ['.ts', '.tsx', '.js', '.jsx', '.json', '.css', '.sql'],
  excludeDirs: [
    'node_modules',
    '.git',
    'dist',
    '.next',
    'coverage',
    'tests',
    'scripts',
    'components/ui',
  ],
  excludeFiles: [
    '.test.',
    '.spec.',
    '.d.ts',
    '.map',
    'next-env.d.ts',
    '.gitignore',
    '.eslintrc.json',
    '.env.example',
    'components.json',
    'package-lock.json',
  ],
  excludePaths: [
    'lib/supabase.ts',
    'lib/rate-limit.ts',
    'lib/monitoring.ts',
    'lib/cache.ts',
    'lib/auth.ts',
    'scripts/test-agent1.ts',
    'scripts/test-agent2.ts',
    'scripts/test-agent3.ts',
    'scripts/test-orchestrator.ts',
    'lib/graphql/queries.ts',
    'lib/graphql/client.ts',
    'hooks/use-toast.ts',
    'components/WalletConnect.tsx',
    'components/Learn.tsx',
    'components/ContractInteraction.tsx',
    'components/Analytics.tsx',
    'app/providers.tsx',
    'app/page.tsx',
    'app/globals.css',
    'app/layout.tsx',
  ],
  maxFileSize: 1024 * 1024, // 1MB
};

function getRelativePath(fullPath, rootDir) {
  return path.relative(rootDir, fullPath);
}

function shouldExcludeFile(filePath, config) {
  const normalizedPath = path.normalize(filePath);

  if (config.excludeFiles.some((pattern) => normalizedPath.includes(pattern))) {
    return true;
  }

  if (config.excludePaths.some((excludePath) =>
    normalizedPath.includes(path.normalize(excludePath))
  )) {
    return true;
  }

  return false;
}

function shouldExcludeDir(dirPath, config) {
  const normalizedPath = path.normalize(dirPath);
  return config.excludeDirs.some((excludeDir) =>
    normalizedPath.includes(path.normalize(excludeDir))
  );
}

function collectFiles(dir, rootDir, config) {
  let results = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });

  for (const item of items) {
    const fullPath = path.join(dir, item.name);
    const relativePath = getRelativePath(fullPath, rootDir);

    if (item.isDirectory()) {
      if (!shouldExcludeDir(fullPath, config)) {
        results = results.concat(collectFiles(fullPath, rootDir, config));
      }
    } else {
      const ext = path.extname(item.name).toLowerCase();

      if (config.extensions.includes(ext) && !shouldExcludeFile(relativePath, config)) {
        const stats = fs.statSync(fullPath);
        if (stats.size <= config.maxFileSize) {
          results.push({ path: fullPath, relativePath });
        }
      }
    }
  }

  return results;
}

function collectCode(outputFile, customConfig = {}) {
  const config = { ...DEFAULT_CONFIG, ...customConfig };

  try {
    fs.writeFileSync(outputFile, '');

    const rootDir = process.cwd();
    console.log(`Processing project directory: ${rootDir}`);
    const files = collectFiles(rootDir, rootDir, config);

    files.sort((a, b) => a.relativePath.localeCompare(b.relativePath));

    files.forEach(({ path: filePath, relativePath }) => {
      const content = fs.readFileSync(filePath, 'utf8');
      const separator = '='.repeat(80);
      fs.appendFileSync(
        outputFile,
        `\n\n${separator}\nFile: ${relativePath}\n${separator}\n\n${content}`
      );
    });

    console.log('Collection complete!');
  } catch (error) {
    console.error('Error during collection:', error);
    process.exit(1);
  }
}

const isMainModule = process.argv[1] === fileURLToPath(import.meta.url);

if (isMainModule) {
  const outputFile = process.argv[2] || 'code-collection.txt';
  collectCode(outputFile);
}

export { collectCode };

================================================================================
File: components/ChatInterface.tsx
================================================================================

"use client";

import React, { useState, useRef, useEffect } from 'react';
import { Bot, Send, Loader2, RefreshCcw, ChevronDown, AlertCircle, Info } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { v4 as uuidv4 } from 'uuid';

interface ErrorAlert {
  type: 'rate-limit' | 'api-error' | 'not-found' | 'network' | 'unknown';
  message: string;
  suggestion?: string;
  retryable: boolean;
}

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  error?: ErrorAlert;
  data?: any;
  suggestions?: string[];
  contextAnalysis?: {
    isCoherent: boolean;
    confidence: number;
  };
}

const ErrorAlertComponent = ({ error, onRetry }: { error: ErrorAlert; onRetry?: () => void }) => (
  <Alert variant="destructive" className="mb-4">
    <AlertCircle className="h-4 w-4" />
    <AlertDescription className="flex items-center justify-between">
      <div>
        <p className="font-medium">{error.message}</p>
        {error.suggestion && (
          <p className="text-sm mt-1 text-muted-foreground">{error.suggestion}</p>
        )}
      </div>
      {error.retryable && onRetry && (
        <Button variant="outline" size="sm" onClick={onRetry} className="ml-4">
          <RefreshCcw className="h-4 w-4 mr-2" />
          Retry
        </Button>
      )}
    </AlertDescription>
  </Alert>
);

const MessageComponent = ({ 
  message, 
  onRetry, 
  onSuggestionClick 
}: { 
  message: Message; 
  onRetry: () => void;
  onSuggestionClick: (suggestion: string) => void;
}) => {
  const isError = message.error !== undefined;
  const hasApiSource = message.data?.source === 'coingecko' || message.data?.source === 'coinmarketcap';

  const messageClasses = [
    "max-w-[80%] rounded-lg px-4 py-2",
    message.role === 'user' 
      ? "bg-primary text-primary-foreground" 
      : isError 
        ? "bg-destructive/10 text-destructive" 
        : "bg-muted"
  ].join(' ');

  const containerClasses = [
    "flex gap-2",
    message.role === 'user' ? "justify-end" : "justify-start"
  ].join(' ');

  return (
    <div className={containerClasses}>
      {message.role === 'assistant' && (
        <div className="w-6 h-6 rounded-full bg-primary/10 flex items-center justify-center">
          <Bot className="h-4 w-4" />
        </div>
      )}
      <div className={messageClasses}>
        <p className="whitespace-pre-wrap">{message.content}</p>
        
        {hasApiSource && (
          <div className="flex items-center gap-1 text-xs opacity-70 mt-1">
            <Info className="h-3 w-3" />
            <span>Data source: {message.data.source}</span>
          </div>
        )}

        {message.contextAnalysis && (
          <div className="flex items-center gap-2 text-xs opacity-70 mt-1 border-t pt-1">
            {message.contextAnalysis.isCoherent ? (
              <>
                <span className="text-green-500">âœ“</span>
                <span>Context aligned</span>
                <span className="text-muted-foreground">
                  ({(message.contextAnalysis.confidence * 100).toFixed(0)}% confidence)
                </span>
              </>
            ) : (
              <>
                <span className="text-yellow-500">âš </span>
                <span>Context shift detected</span>
                <span className="text-muted-foreground">
                  ({(message.contextAnalysis.confidence * 100).toFixed(0)}% confidence)
                </span>
              </>
            )}
          </div>
        )}

        <p className="text-xs opacity-70 mt-1">
          {message.timestamp.toLocaleTimeString()}
        </p>

        {isError && message.error?.retryable && (
          <Button
            variant="ghost"
            size="sm"
            onClick={onRetry}
            className="mt-2"
          >
            <RefreshCcw className="h-4 w-4 mr-2" />
            Retry
          </Button>
        )}

        {message.suggestions && message.suggestions.length > 0 && (
          <div className="mt-3 space-y-2">
            <p className="text-sm font-medium">Suggested queries:</p>
            <div className="flex flex-wrap gap-2">
              {message.suggestions.map((suggestion, i) => (
                <Button
                  key={i}
                  variant="outline"
                  size="sm"
                  onClick={() => onSuggestionClick(suggestion)}
                >
                  {suggestion}
                </Button>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

const QUICK_QUERIES = [
  {
    label: 'Bitcoin price',
    query: 'What is the current price of Bitcoin?',
  },
  {
    label: 'ETH price',
    query: 'What is the current price of Ethereum?',
  },
  {
    label: 'Compare BTC & ETH',
    query: 'Compare Bitcoin and Ethereum prices',
  },
];

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  useEffect(() => {
    // Initialize session with UUID
    setSessionId(uuidv4());
  }, []);

  const handleError = (error: unknown): ErrorAlert => {
    if (error instanceof Error) {
      // Rate limit errors
      if (error.message.includes('rate limit')) {
        return {
          type: 'rate-limit',
          message: 'API rate limit exceeded',
          suggestion: 'Please wait a moment before trying again',
          retryable: true
        };
      }
      
      // API configuration errors
      if (error.message.includes('API key')) {
        return {
          type: 'api-error',
          message: 'Service configuration error',
          suggestion: 'Please contact support if this persists',
          retryable: false
        };
      }

      // Not found errors
      if (error.message.includes('not found') || error.message.includes('No data available')) {
        return {
          type: 'not-found',
          message: 'Token not found',
          suggestion: 'Try checking the token symbol or searching for a different token',
          retryable: false
        };
      }

      // Network errors
      if (error.message.includes('network') || error.message.includes('ECONNRESET')) {
        return {
          type: 'network',
          message: 'Network connection error',
          suggestion: 'Please check your internet connection',
          retryable: true
        };
      }

      return {
        type: 'unknown',
        message: error.message,
        retryable: true
      };
    }

    return {
      type: 'unknown',
      message: 'An unexpected error occurred',
      retryable: true
    };
  };

  const handleSubmit = async (e: React.FormEvent | string, isRetry = false) => {
    if (typeof e !== 'string' && e?.preventDefault) {
      e.preventDefault();
    }
    const queryText = typeof e === 'string' ? e : input;
    
    if (!queryText.trim() || !sessionId || isLoading) return;

    if (!isRetry) {
      setRetryCount(0);
    }

    const userMessage: Message = {
      role: 'user',
      content: queryText,
      timestamp: new Date(),
    };

    if (!isRetry) {
      setMessages(prev => [...prev, userMessage]);
    }
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          query: queryText,
          sessionId
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: `Server error: ${response.status}` }));
        throw new Error(errorData.error || `Server error: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.error) {
        throw new Error(data.error);
      }

      const assistantMessage: Message = {
        role: 'assistant',
        content: data.response,
        timestamp: new Date(),
        data: data.data,
        suggestions: data.suggestions,
        contextAnalysis: data.contextAnalysis
      };

      setMessages(prev => {
        if (isRetry) {
          return [...prev.slice(0, -1), assistantMessage];
        }
        return [...prev, assistantMessage];
      });
    } catch (error) {
      const errorAlert = handleError(error);
      
      const errorMessage: Message = {
        role: 'assistant',
        content: errorAlert.message + (errorAlert.suggestion ? `\n\n${errorAlert.suggestion}` : ''),
        timestamp: new Date(),
        error: errorAlert,
      };

      setMessages(prev => {
        if (isRetry) {
          return [...prev.slice(0, -1), errorMessage];
        }
        return [...prev, errorMessage];
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleSuggestionClick = (suggestion: string) => {
    handleSubmit(suggestion);
  };

  return (
    <Card className="h-[calc(100vh-12rem)]">
      <CardHeader className="border-b">
        <CardTitle className="flex items-center gap-2">
          <Bot className="h-5 w-5" />
          Blockchain Assistant
        </CardTitle>
      </CardHeader>
      <CardContent className="flex flex-col h-[calc(100%-5rem)]">
        <div className="flex-1 overflow-y-auto space-y-4 mb-4 p-4">
          {messages.length === 0 && (
            <div className="text-center text-muted-foreground p-4">
              <p>ðŸ‘‹ Hi! I can help you explore blockchain data.</p>
              <p className="mt-2">Try asking about token prices or market trends.</p>
            </div>
          )}
          {messages.map((message, index) => (
            <MessageComponent
              key={index}
              message={message}
              onRetry={() => handleSubmit(messages[messages.length - 2].content, true)}
              onSuggestionClick={handleSuggestionClick}
            />
          ))}
          {isLoading && (
            <div className="flex gap-2">
              <div className="w-6 h-6 rounded-full bg-primary/10 flex items-center justify-center">
                <Bot className="h-4 w-4" />
              </div>
              <div className="bg-muted rounded-lg px-4 py-2">
                <div className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <p>Processing your request...</p>
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
        <div className="border-t pt-4 px-4">
          <form onSubmit={handleSubmit} className="flex gap-2">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="icon">
                  <ChevronDown className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start">
                {QUICK_QUERIES.map((item, index) => (
                  <DropdownMenuItem
                    key={index}
                    onClick={() => handleSubmit(item.query)}
                  >
                    {item.label}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
            <Input
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Ask about token prices or trends (e.g., 'What is Bitcoin's price?')"
              disabled={isLoading}
              className="flex-1"
            />
            <Button type="submit" disabled={isLoading || !input.trim()}>
              <Send className="h-4 w-4" />
            </Button>
          </form>
        </div>
      </CardContent>
    </Card>
  );
}

================================================================================
File: components/ErrorBoundary.tsx
================================================================================

"use client";

import React from 'react';
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { AlertCircle, RefreshCcw, Home } from 'lucide-react';
import Link from 'next/link';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log error to monitoring service
    console.error('Error caught by boundary:', error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <Card className="max-w-lg mx-auto my-8 shadow-lg">
          <CardHeader className="space-y-1">
            <CardTitle className="flex items-center gap-2 text-destructive">
              <AlertCircle className="h-5 w-5" />
              Something went wrong
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-muted-foreground">
              {process.env.NODE_ENV === 'development' 
                ? this.state.error?.message || 'An unexpected error occurred'
                : 'An unexpected error occurred. Our team has been notified.'}
            </p>
            {process.env.NODE_ENV === 'development' && this.state.error?.stack && (
              <pre className="p-4 bg-muted rounded-lg text-xs overflow-auto max-h-[200px]">
                {this.state.error.stack}
              </pre>
            )}
          </CardContent>
          <CardFooter className="flex gap-2">
            <Button
              onClick={() => window.location.reload()}
              variant="default"
              size="sm"
            >
              <RefreshCcw className="h-4 w-4 mr-2" />
              Retry
            </Button>
            <Link href="/" passHref>
              <Button
                variant="outline"
                size="sm"
                onClick={this.handleReset}
              >
                <Home className="h-4 w-4 mr-2" />
                Back to Home
              </Button>
            </Link>
          </CardFooter>
        </Card>
      );
    }

    return this.props.children;
  }
}

================================================================================
File: jsconfig.json
================================================================================

{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  }
} 

================================================================================
File: lib/agents/aggregator.ts
================================================================================

import { RobustAnalysis, AggregatorSpec } from './types';
import { getTokenDetails, getTokenPrices } from '@/lib/token-data';

export async function buildAggregatorCalls(analysis: RobustAnalysis): Promise<AggregatorSpec> {
  console.log('buildAggregatorCalls: Starting with analysis:', {
    primaryIntent: analysis.classification.primaryIntent,
    tokens: analysis.queryAnalysis.detectedTokens,
    needsApiCall: analysis.classification.needsApiCall
  });

  const spec: AggregatorSpec = {
    primary: {},
    fallback: {}
  };

  // Handle different intent types
  switch (analysis.classification.primaryIntent) {
    case 'MARKET_DATA':
    case 'COMPARISON':
    case 'DEFI':
      // Market data logic with actual API calls
      if (analysis.classification.needsApiCall) {
        spec.primary.coingecko = {
          method: 'GET',
          tokens: analysis.queryAnalysis.detectedTokens,
          timeframe: analysis.queryAnalysis.timeContext || 'current'
        };
      }
      break;

    case 'NEWS_EVENTS':
    case 'REGULATORY':
      if (analysis.classification.requiresWebSearch) {
        const contentTypes = analysis.dataRequirements.newsData?.types || ['announcement'];
        const timeRange = analysis.dataRequirements.newsData?.timeRange;
        
        spec.primary.news = {
          method: 'GET',
          contentTypes,
          timeRange,
          tokens: analysis.queryAnalysis.detectedTokens
        };

        // Add regulatory data requirements if needed
        if (analysis.classification.primaryIntent === 'REGULATORY') {
          spec.primary.regulatory = {
            method: 'GET',
            jurisdiction: 'global',
            timeRange
          };
        }
      }
      break;

    case 'SECURITY':
      if (analysis.classification.requiresWebSearch) {
        spec.primary.security = {
          method: 'GET',
          contentTypes: ['security_incident'],
          tokens: analysis.queryAnalysis.detectedTokens
        };
      }
      break;
  }

  return spec;
}

export async function executeAggregatorCalls(spec: AggregatorSpec) {
  console.log('executeAggregatorCalls: Starting with spec:', spec);
  const results: Record<string, any> = {
    primary: {},
    fallback: {}
  };

  try {
    // Validate spec
    if (!spec || typeof spec !== 'object') {
      throw new Error('Invalid aggregator specification');
    }

    // Handle CoinGecko data requests
    if (spec.primary.coingecko) {
      const { tokens } = spec.primary.coingecko;
      
      // Validate tokens array
      if (!Array.isArray(tokens)) {
        throw new Error('Invalid tokens specification');
      }

      if (tokens.length === 0) {
        throw new Error('No tokens specified for price lookup');
      }

      if (tokens.length > 5) {
        throw new Error('Too many tokens requested (maximum 5)');
      }

      // Get token details for each token with error handling
      const tokenDetailsPromises = tokens.map(async token => {
        try {
          if (!token || typeof token !== 'string') {
            throw new Error(`Invalid token: ${token}`);
          }

          const details = await getTokenDetails(token);
          if (!details) {
            console.warn(`No details found for token: ${token}`);
            return null;
          }
          return details;
        } catch (error) {
          console.error(`Error fetching details for token ${token}:`, error);
          return null;
        }
      });

      const tokenDetails = await Promise.all(tokenDetailsPromises);
      
      // Filter out failed lookups and get valid token IDs
      const validTokenDetails = tokenDetails.filter(detail => detail !== null);
      
      if (validTokenDetails.length === 0) {
        throw new Error('No valid token details found');
      }

      const tokenIds = validTokenDetails
        .filter((detail): detail is NonNullable<typeof detail> => detail !== null)
        .map(detail => detail.id);
      
      // Get token prices with error handling
      try {
        const prices = await getTokenPrices(tokenIds);
        
        results.primary.coingecko = {
          tokenDetails: validTokenDetails,
          prices
        };
      } catch (error) {
        console.error('Error fetching token prices:', error);
        throw new Error('Failed to fetch token prices');
      }
    }

    // Handle news data requests
    if (spec.primary.news) {
      // News data would be handled by a separate service
      results.primary.news = {
        status: 'success',
        message: 'News data would be fetched here'
      };
    }

    // Handle regulatory data requests
    if (spec.primary.regulatory) {
      // Regulatory data would be handled by a separate service
      results.primary.regulatory = {
        status: 'success',
        message: 'Regulatory data would be fetched here'
      };
    }

    // Handle security data requests
    if (spec.primary.security) {
      // Security data would be handled by a separate service
      results.primary.security = {
        status: 'success',
        message: 'Security data would be fetched here'
      };
    }

    return results;

  } catch (error) {
    console.error('Error executing aggregator calls:', error);
    
    // Enhanced error handling with specific error types
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('API rate limit exceeded. Please try again in a moment.');
      }
      if (error.message.includes('API key')) {
        throw new Error('API configuration error. Please check your settings.');
      }
      if (error.message.includes('No valid token')) {
        throw new Error('Could not find data for the requested tokens. Please verify the token symbols.');
      }
      if (error.message.includes('Too many tokens')) {
        throw new Error('Please request fewer tokens (maximum 5 at a time).');
      }
      if (error.message.includes('Invalid token')) {
        throw new Error('Invalid token symbol provided. Please check the token name.');
      }
    }
    
    throw new Error('Failed to fetch token data. Please try again.');
  }
}

================================================================================
File: lib/agents/blockchain-orchestrator.ts
================================================================================

import { contractDeploymentAgent, DeploymentParams, DeploymentResult } from './deployment/contract-deployment-agent';
import { tokenTransferAgent, TransferParams, TransferResult } from './transaction/token-transfer-agent';
import { walletService, WalletConnectionOptions } from '../blockchain/wallet-integration';
import { tokenRegistry, TokenInfo } from '../blockchain/token-registry';
import { getTemplate, ContractTemplate } from './deployment/contract-templates';

// Helper functions for contract templates
async function getAllTemplates(): Promise<ContractTemplate[]> {
  // In a real implementation, this would fetch all templates from a database or API
  // For now, we'll return a simple array of templates
  const templates: ContractTemplate[] = [];
  
  const erc20Template = await getTemplate('ERC20');
  const erc721Template = await getTemplate('ERC721');
  const erc1155Template = await getTemplate('ERC1155');
  
  if (erc20Template) templates.push(erc20Template);
  if (erc721Template) templates.push(erc721Template);
  if (erc1155Template) templates.push(erc1155Template);
  
  return templates;
}

async function getTemplatesByCategory(category: string): Promise<ContractTemplate[]> {
  // In a real implementation, this would filter templates by category
  const allTemplates = await getAllTemplates();
  return allTemplates.filter(template => template.category === category);
}

// Blockchain action types
export type BlockchainActionType = 
  | 'CONNECT_WALLET'
  | 'DISCONNECT_WALLET'
  | 'DEPLOY_CONTRACT'
  | 'TRANSFER_TOKENS'
  | 'GET_TOKEN_INFO'
  | 'GET_CONTRACT_TEMPLATES'
  | 'GET_DEPLOYMENT_STATUS'
  | 'GET_TRANSFER_STATUS';

// Blockchain action parameters
export interface BlockchainActionParams {
  actionType: BlockchainActionType;
  walletParams?: WalletConnectionOptions;
  deploymentParams?: DeploymentParams;
  transferParams?: TransferParams;
  tokenAddress?: `0x${string}`;
  chainId?: number;
  templateCategory?: string;
  transactionHash?: `0x${string}`;
}

// Blockchain action result
export interface BlockchainActionResult {
  success: boolean;
  actionType: BlockchainActionType;
  data?: any;
  error?: string;
}

export class BlockchainOrchestrator {
  // Handle blockchain actions
  async handleAction(params: BlockchainActionParams): Promise<BlockchainActionResult> {
    try {
      switch (params.actionType) {
        case 'CONNECT_WALLET':
          return await this.connectWallet(params.walletParams!);
          
        case 'DISCONNECT_WALLET':
          return this.disconnectWallet();
          
        case 'DEPLOY_CONTRACT':
          return await this.deployContract(params.deploymentParams!);
          
        case 'TRANSFER_TOKENS':
          return await this.transferTokens(params.transferParams!);
          
        case 'GET_TOKEN_INFO':
          return await this.getTokenInfo(params.tokenAddress!, params.chainId!);
          
        case 'GET_CONTRACT_TEMPLATES':
          return await this.getContractTemplates(params.templateCategory);
          
        case 'GET_DEPLOYMENT_STATUS':
          return this.getDeploymentStatus(params.transactionHash!);
          
        case 'GET_TRANSFER_STATUS':
          return this.getTransferStatus(params.transactionHash!);
          
        default:
          throw new Error(`Unknown action type: ${params.actionType}`);
      }
    } catch (error) {
      console.error('Blockchain action error:', error);
      return {
        success: false,
        actionType: params.actionType,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Connect wallet
  private async connectWallet(params: WalletConnectionOptions): Promise<BlockchainActionResult> {
    try {
      const address = await walletService.connect(params);
      return {
        success: true,
        actionType: 'CONNECT_WALLET',
        data: { address }
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'CONNECT_WALLET',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Disconnect wallet
  private disconnectWallet(): BlockchainActionResult {
    try {
      walletService.disconnect();
      return {
        success: true,
        actionType: 'DISCONNECT_WALLET'
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'DISCONNECT_WALLET',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Deploy contract
  private async deployContract(params: DeploymentParams): Promise<BlockchainActionResult> {
    try {
      const result = await contractDeploymentAgent.deployContract(params);
      return {
        success: true,
        actionType: 'DEPLOY_CONTRACT',
        data: result
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'DEPLOY_CONTRACT',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Transfer tokens
  private async transferTokens(params: TransferParams): Promise<BlockchainActionResult> {
    try {
      const result = await tokenTransferAgent.transferTokens(params);
      return {
        success: true,
        actionType: 'TRANSFER_TOKENS',
        data: result
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'TRANSFER_TOKENS',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get token info
  private async getTokenInfo(tokenAddress: `0x${string}`, chainId: number): Promise<BlockchainActionResult> {
    try {
      let tokenInfo = tokenRegistry.getToken(tokenAddress, chainId);
      
      if (!tokenInfo) {
        // Try to load token info from blockchain
        tokenInfo = await tokenRegistry.loadTokenInfo(tokenAddress, chainId);
      }
      
      return {
        success: true,
        actionType: 'GET_TOKEN_INFO',
        data: tokenInfo
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_TOKEN_INFO',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get contract templates
  private async getContractTemplates(category?: string): Promise<BlockchainActionResult> {
    try {
      let templates: ContractTemplate[];
      
      if (category) {
        templates = await getTemplatesByCategory(category);
      } else {
        templates = await getAllTemplates();
      }
      
      return {
        success: true,
        actionType: 'GET_CONTRACT_TEMPLATES',
        data: templates
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_CONTRACT_TEMPLATES',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get deployment status
  private getDeploymentStatus(transactionHash: `0x${string}`): BlockchainActionResult {
    try {
      const deployment = contractDeploymentAgent.getDeployment(transactionHash);
      
      if (!deployment) {
        throw new Error(`Deployment with hash ${transactionHash} not found`);
      }
      
      return {
        success: true,
        actionType: 'GET_DEPLOYMENT_STATUS',
        data: deployment
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_DEPLOYMENT_STATUS',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get transfer status
  private getTransferStatus(transactionHash: `0x${string}`): BlockchainActionResult {
    try {
      const transfer = tokenTransferAgent.getTransfer(transactionHash);
      
      if (!transfer) {
        throw new Error(`Transfer with hash ${transactionHash} not found`);
      }
      
      return {
        success: true,
        actionType: 'GET_TRANSFER_STATUS',
        data: transfer
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_TRANSFER_STATUS',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
}

// Export singleton instance
export const blockchainOrchestrator = new BlockchainOrchestrator(); 

================================================================================
File: lib/agents/deployment/contract-deployment-agent.ts
================================================================================

import { parseAbi, encodeAbiParameters } from 'viem';
import { walletService, TransactionOptions, WalletIntegrationService } from '../../blockchain/wallet-integration';
import { publicClient } from '../../blockchain/providers';
import { validateContract } from '../security/contract-validator';
import { ContractTemplate, getTemplate } from './contract-templates';
import { compile } from './solidity-compiler';

export interface DeploymentParams {
  // Contract source or template information
  source?: string;
  templateId?: string;
  templateParams?: Record<string, any>;
  
  // Constructor parameters (if any)
  constructorArgs?: any[];
  
  // Deployment options
  value?: string; // ETH value in string format (e.g. "0.1")
  gasLimit?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
  
  // Verification options
  verify?: boolean;
  compilerVersion?: string;
  optimizationRuns?: number;
}

export interface DeploymentResult {
  transactionHash: `0x${string}`;
  contractAddress: `0x${string}` | null;
  deploymentStatus: 'pending' | 'success' | 'failed';
  abi: any[];
  bytecode: `0x${string}`;
  constructorArgs: any[];
  gasUsed?: bigint;
  effectiveGasPrice?: bigint;
  receipt?: any;
  error?: string;
}

export class ContractDeploymentAgent {
  private deployments = new Map<string, DeploymentResult>();

  // Generate contract from template or use provided source
  private async getContractSource(params: DeploymentParams): Promise<string> {
    // If source is provided directly, use it
    if (params.source) {
      return params.source;
    }
    
    // If template ID is provided, get template and fill parameters
    if (params.templateId) {
      const template = await getTemplate(params.templateId);
      if (!template) {
        throw new Error(`Template with ID ${params.templateId} not found`);
      }
      
      // Replace template parameters
      let source = template.source;
      if (params.templateParams) {
        for (const [key, value] of Object.entries(params.templateParams)) {
          const placeholder = `{{${key}}}`;
          source = source.replace(new RegExp(placeholder, 'g'), String(value));
        }
      }
      
      return source;
    }
    
    throw new Error('Either source or templateId must be provided');
  }

  // Deploy a smart contract
  async deployContract(params: DeploymentParams): Promise<DeploymentResult> {
    try {
      // Check if wallet is connected
      if (!walletService.isConnected()) {
        throw new Error('Wallet not connected');
      }
      
      // Get contract source
      const source = await this.getContractSource(params);
      
      // Validate contract security
      const securityResults = await validateContract(source);
      if (!securityResults.valid) {
        throw new Error(`Contract failed security validation: ${securityResults.issues.map(i => i.title).join(', ')}`);
      }
      
      // Compile the contract
      const compilation = await compile(source, {
        optimizer: {
          enabled: true,
          runs: params.optimizationRuns || 200
        },
        version: params.compilerVersion
      });
      
      if (compilation.errors && compilation.errors.length > 0) {
        throw new Error(`Compilation failed: ${compilation.errors.map((e: { message: string }) => e.message).join(', ')}`);
      }
      
      // Find the main contract (assuming it's the last one)
      const contractNames = Object.keys(compilation.contracts);
      const contractName = contractNames[contractNames.length - 1];
      const contract = compilation.contracts[contractName];
      
      // Prepare deployment data
      const bytecode = contract.evm.bytecode.object as `0x${string}`;
      const abi = JSON.parse(contract.abi);
      
      // Encode constructor arguments if provided
      let data = bytecode;
      if (params.constructorArgs && params.constructorArgs.length > 0) {
        // Find constructor in ABI
        const constructorAbi = abi.find((item: any) => item.type === 'constructor');
        if (constructorAbi) {
          const encodedArgs = encodeAbiParameters(
            constructorAbi.inputs,
            params.constructorArgs
          );
          data = `${bytecode}${encodedArgs.slice(2)}`; // remove 0x prefix from args
        }
      }
      
      // Prepare transaction options
      const txOptions: TransactionOptions = {
        to: '0x' as `0x${string}`, // Empty address for contract deployment
        data: data as `0x${string}`,
        value: params.value ? WalletIntegrationService.parseEther(params.value) : 0n,
      };
      
      // Add gas parameters if provided
      if (params.gasLimit) {
        txOptions.gasLimit = BigInt(params.gasLimit);
      }
      if (params.maxFeePerGas) {
        txOptions.maxFeePerGas = BigInt(params.maxFeePerGas);
      }
      if (params.maxPriorityFeePerGas) {
        txOptions.maxPriorityFeePerGas = BigInt(params.maxPriorityFeePerGas);
      }
      
      // Send deployment transaction
      const hash = await walletService.sendTransaction(txOptions);
      
      // Create initial deployment result
      const deploymentResult: DeploymentResult = {
        transactionHash: hash,
        contractAddress: null,
        deploymentStatus: 'pending',
        abi,
        bytecode,
        constructorArgs: params.constructorArgs || []
      };
      
      // Store the deployment
      this.deployments.set(hash, deploymentResult);
      
      // Wait for transaction confirmation in the background
      this.waitForDeployment(hash, params.verify);
      
      return deploymentResult;
      
    } catch (error) {
      console.error('Contract deployment error:', error);
      throw new Error(`Failed to deploy contract: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Wait for deployment confirmation
  private async waitForDeployment(hash: `0x${string}`, verify: boolean = false): Promise<void> {
    try {
      // Wait for transaction receipt
      const receipt = await walletService.waitForTransaction(hash);
      
      // Update deployment result
      const deployment = this.deployments.get(hash);
      if (deployment) {
        deployment.deploymentStatus = receipt.status === 'success' ? 'success' : 'failed';
        deployment.contractAddress = receipt.contractAddress as `0x${string}` || null;
        deployment.gasUsed = receipt.gasUsed;
        deployment.effectiveGasPrice = receipt.effectiveGasPrice;
        deployment.receipt = receipt;
        
        // Verify contract on Etherscan if requested
        if (verify && receipt.status === 'success' && receipt.contractAddress) {
          try {
            // Verification logic would go here
            // This would typically call the Etherscan API
            console.log(`Contract verification requested for ${receipt.contractAddress}`);
          } catch (verifyError) {
            console.error('Contract verification error:', verifyError);
            deployment.error = `Deployment succeeded but verification failed: ${verifyError instanceof Error ? verifyError.message : 'Unknown error'}`;
          }
        }
        
        this.deployments.set(hash, deployment);
      }
    } catch (error) {
      console.error('Deployment confirmation error:', error);
      
      // Update deployment status to failed
      const deployment = this.deployments.get(hash);
      if (deployment) {
        deployment.deploymentStatus = 'failed';
        deployment.error = `Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
        this.deployments.set(hash, deployment);
      }
    }
  }

  // Get deployment status
  getDeployment(hash: `0x${string}`): DeploymentResult | null {
    return this.deployments.get(hash) || null;
  }

  // Get all deployments
  getAllDeployments(): DeploymentResult[] {
    return Array.from(this.deployments.values());
  }
}

// Export singleton instance
export const contractDeploymentAgent = new ContractDeploymentAgent(); 

================================================================================
File: lib/agents/deployment/contract-templates.ts
================================================================================

// Contract template interface
export interface ContractTemplate {
  id: string;
  name: string;
  description: string;
  category: 'token' | 'nft' | 'defi' | 'utility' | 'governance';
  source: string;
  parameters: TemplateParameter[];
  defaultValues?: Record<string, any>;
  version: string;
  author: string;
}

// Template parameter interface
export interface TemplateParameter {
  name: string;
  description: string;
  type: 'string' | 'number' | 'boolean' | 'address' | 'uint256' | 'uint8';
  required: boolean;
  defaultValue?: any;
  options?: any[];
}

// Template registry
const templates: Map<string, ContractTemplate> = new Map();

// Get a template by ID
export async function getTemplate(id: string): Promise<ContractTemplate | null> {
  return templates.get(id) || null;
}

// Get all templates
export async function getAllTemplates(): Promise<ContractTemplate[]> {
  return Array.from(templates.values());
}

// Get templates by category
export async function getTemplatesByCategory(category: string): Promise<ContractTemplate[]> {
  return Array.from(templates.values()).filter(template => template.category === category);
}

// Register a template
export function registerTemplate(template: ContractTemplate): void {
  templates.set(template.id, template);
}

// ERC20 Token Template
const erc20TokenTemplate: ContractTemplate = {
  id: 'erc20-token',
  name: 'ERC20 Token',
  description: 'Standard ERC20 token with name, symbol, and supply',
  category: 'token',
  source: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract {{name}} is ERC20, Ownable {
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply,
        address _owner
    ) ERC20(_name, _symbol) Ownable(_owner) {
        _mint(_owner, _initialSupply * 10 ** decimals());
    }
    
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}`,
  parameters: [
    {
      name: 'name',
      description: 'Token name',
      type: 'string',
      required: true,
      defaultValue: 'My Token'
    },
    {
      name: '_name',
      description: 'Token name parameter',
      type: 'string',
      required: true,
      defaultValue: 'My Token'
    },
    {
      name: '_symbol',
      description: 'Token symbol',
      type: 'string',
      required: true,
      defaultValue: 'MTK'
    },
    {
      name: '_initialSupply',
      description: 'Initial token supply',
      type: 'uint256',
      required: true,
      defaultValue: '1000000'
    },
    {
      name: '_owner',
      description: 'Token owner address',
      type: 'address',
      required: true
    }
  ],
  defaultValues: {
    name: 'MyToken'
  },
  version: '1.0.0',
  author: 'BlockchainGPT'
};

// NFT Collection Template
const nftCollectionTemplate: ContractTemplate = {
  id: 'nft-collection',
  name: 'NFT Collection',
  description: 'ERC721 NFT collection with metadata',
  category: 'nft',
  source: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract {{name}} is ERC721Enumerable, Ownable {
    using Strings for uint256;
    
    string public baseURI;
    uint256 public maxSupply;
    uint256 public price;
    bool public saleIsActive = false;
    
    constructor(
        string memory _name,
        string memory _symbol,
        string memory _initBaseURI,
        uint256 _maxSupply,
        uint256 _price,
        address _owner
    ) ERC721(_name, _symbol) Ownable(_owner) {
        baseURI = _initBaseURI;
        maxSupply = _maxSupply;
        price = _price;
    }
    
    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }
    
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";
    }
    
    function mint(uint256 numberOfTokens) public payable {
        require(saleIsActive, "Sale is not active");
        require(numberOfTokens > 0, "Must mint at least 1 token");
        require(totalSupply() + numberOfTokens <= maxSupply, "Would exceed max supply");
        require(msg.value >= price * numberOfTokens, "Insufficient payment");
        
        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = totalSupply() + 1;
            _safeMint(msg.sender, tokenId);
        }
    }
    
    function setSaleState(bool _saleIsActive) public onlyOwner {
        saleIsActive = _saleIsActive;
    }
    
    function setBaseURI(string memory _newBaseURI) public onlyOwner {
        baseURI = _newBaseURI;
    }
    
    function setPrice(uint256 _newPrice) public onlyOwner {
        price = _newPrice;
    }
    
    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }
}`,
  parameters: [
    {
      name: 'name',
      description: 'Contract name',
      type: 'string',
      required: true,
      defaultValue: 'MyNFTCollection'
    },
    {
      name: '_name',
      description: 'Collection name',
      type: 'string',
      required: true,
      defaultValue: 'My NFT Collection'
    },
    {
      name: '_symbol',
      description: 'Collection symbol',
      type: 'string',
      required: true,
      defaultValue: 'MNFT'
    },
    {
      name: '_initBaseURI',
      description: 'Base URI for token metadata',
      type: 'string',
      required: true,
      defaultValue: 'https://example.com/metadata/'
    },
    {
      name: '_maxSupply',
      description: 'Maximum supply of NFTs',
      type: 'uint256',
      required: true,
      defaultValue: '10000'
    },
    {
      name: '_price',
      description: 'Price per NFT in wei',
      type: 'uint256',
      required: true,
      defaultValue: '50000000000000000' // 0.05 ETH
    },
    {
      name: '_owner',
      description: 'Collection owner address',
      type: 'address',
      required: true
    }
  ],
  defaultValues: {
    name: 'MyNFTCollection'
  },
  version: '1.0.0',
  author: 'BlockchainGPT'
};

// Simple Storage Template
const simpleStorageTemplate: ContractTemplate = {
  id: 'simple-storage',
  name: 'Simple Storage',
  description: 'Basic contract for storing and retrieving a value',
  category: 'utility',
  source: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract {{name}} {
    uint256 private value;
    address public owner;
    
    event ValueChanged(uint256 newValue);
    
    constructor(uint256 _initialValue) {
        value = _initialValue;
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }
    
    function setValue(uint256 _newValue) public onlyOwner {
        value = _newValue;
        emit ValueChanged(_newValue);
    }
    
    function getValue() public view returns (uint256) {
        return value;
    }
    
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "Invalid address");
        owner = _newOwner;
    }
}`,
  parameters: [
    {
      name: 'name',
      description: 'Contract name',
      type: 'string',
      required: true,
      defaultValue: 'SimpleStorage'
    },
    {
      name: '_initialValue',
      description: 'Initial stored value',
      type: 'uint256',
      required: true,
      defaultValue: '0'
    }
  ],
  defaultValues: {
    name: 'SimpleStorage'
  },
  version: '1.0.0',
  author: 'BlockchainGPT'
};

// Register templates
registerTemplate(erc20TokenTemplate);
registerTemplate(nftCollectionTemplate);
registerTemplate(simpleStorageTemplate); 

================================================================================
File: lib/agents/deployment/solidity-compiler.ts
================================================================================

import * as solc from 'solc';

export interface CompilerOptions {
  optimizer?: {
    enabled: boolean;
    runs: number;
  };
  version?: string;
  evmVersion?: string;
}

export interface CompilationResult {
  contracts: Record<string, any>;
  sources: Record<string, any>;
  errors?: Array<{
    message: string;
    severity: 'error' | 'warning';
    type: string;
  }>;
}

export async function compile(source: string, options: CompilerOptions = {}): Promise<CompilationResult> {
  // Prepare compiler input
  const input = {
    language: 'Solidity',
    sources: {
      'main.sol': {
        content: source
      }
    },
    settings: {
      outputSelection: {
        '*': {
          '*': ['abi', 'evm.bytecode', 'evm.deployedBytecode', 'metadata']
        }
      },
      optimizer: options.optimizer || {
        enabled: false,
        runs: 200
      },
      evmVersion: options.evmVersion || 'paris'
    }
  };

  // Compile the contract
  const output = JSON.parse(solc.compile(JSON.stringify(input)));

  // Check for errors
  const errors = output.errors?.filter((error: any) => error.severity === 'error');
  if (errors && errors.length > 0) {
    return {
      contracts: {},
      sources: {},
      errors: output.errors
    };
  }

  return {
    contracts: output.contracts['main.sol'],
    sources: output.sources,
    errors: output.errors
  };
} 

================================================================================
File: lib/agents/index.ts
================================================================================

export { analyzeUserQuery } from './intent';
export { buildAggregatorCalls, executeAggregatorCalls } from './aggregator';
export { generateSummary } from './summarization';
export * from './types';

================================================================================
File: lib/agents/intent.ts
================================================================================

import { Configuration, OpenAIApi } from 'openai';
import { RobustAnalysis, Agent1Input, PreprocessingStep, QueryMetadata } from './types';
import { validateAnalysis, validateLLMResponse, PreprocessingError, LLMError } from './validation';

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
let openai: OpenAIApi | null = null;

function getOpenAIClient() {
  if (!openai) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    const configuration = new Configuration({ apiKey });
    openai = new OpenAIApi(configuration);
  }
  return openai;
}

const SYSTEM_PROMPT = `You are an advanced blockchain and cryptocurrency analysis system specializing in intent classification. Your task is to analyze and categorize user queries across multiple domains while being resilient to ambiguous, malformed, or complex inputs.

CLASSIFICATION CATEGORIES:

1. MARKET_DATA
   - Price inquiries and market statistics
   - Trading volume and liquidity information
   - Market cap and supply metrics
   - Historical price data requests
   Examples: "What's BTC price?", "Show ETH trading volume"

2. COMPARISON
   - Direct token comparisons
   - Performance analysis between assets
   - Market metric comparisons
   - Technology or feature comparisons
   Examples: "Compare BTC and ETH", "Which has better performance?"

3. TECHNICAL
   - Smart contract inquiries
   - Blockchain architecture questions
   - Protocol specifications
   - Development and implementation
   Examples: "How do ERC20 tokens work?", "Explain Ethereum's consensus"

4. DEFI
   - Yield farming and liquidity
   - Lending protocols
   - DEX mechanics
   - Tokenomics
   Examples: "How does liquidity mining work?", "Explain impermanent loss"

5. REGULATORY
   - Legal and compliance questions
   - Regulatory updates
   - Policy impact analysis
   - Jurisdictional inquiries
   Examples: "Latest crypto regulations", "Is mining legal in China?"

6. NEWS_EVENTS
   - Recent developments
   - Project updates
   - Market events
   - Industry announcements
   Examples: "Latest Bitcoin news", "Updates on ETH merge"

7. SECURITY
   - Network security
   - Wallet safety
   - Smart contract audits
   - Attack vectors and risks
   Examples: "Is hardware wallet safe?", "Common DeFi exploits"

8. CONCEPTUAL
   - Basic blockchain concepts
   - Cryptocurrency fundamentals
   - General educational queries
   Examples: "What are gas fees?", "How does mining work?"

9. HYBRID
   - Queries spanning multiple categories
   - Complex multi-part questions
   Example: "Compare ETH price and explain smart contracts"

10. NEEDS_CONTEXT
    - Ambiguous queries
    - Incomplete information
    - Context-dependent questions
    Example: "Is it better?", "What's the difference?"

DETECTION RULES:

1. Token Detection:
   - Common tokens: BTC, ETH, SOL, DOGE, ADA, BNB, XRP, DOT, MATIC, AVAX, LINK, UNI, ATOM, LTC
   - Special cases: LUNA -> terra-luna-2, LUNC -> terra-luna
   - Handle both symbols and full names: Bitcoin, Ethereum, etc.
   - Process token pairs in comparisons
   - Maximum 5 tokens per query
   - Normalize token names consistently

2. Intent Analysis:
   - Primary intent based on strongest category match
   - Secondary intents for hybrid queries
   - Confidence level assessment
   - Ambiguity detection

3. Market Indicators:
   - Price-related terms
   - Volume and liquidity metrics
   - Trading signals
   - Technical analysis terms

4. Conceptual Indicators:
   - Educational keywords
   - Definition requests
   - How-to questions
   - Explanation markers

5. Time Context:
   - Current vs historical
   - Specific timeframes
   - Trend analysis periods
   - Future predictions

CRITICAL RESPONSE REQUIREMENTS:

Return a valid JSON response with EXACTLY this structure:

{
  "classification": {
    "primaryIntent": "MARKET_DATA" | "COMPARISON" | "TECHNICAL" | "DEFI" | 
                    "REGULATORY" | "NEWS_EVENTS" | "SECURITY" | "CONCEPTUAL" | 
                    "HYBRID" | "NEEDS_CONTEXT",
    "confidence": <number between 0 and 1>,
    "needsApiCall": <boolean>,
    "ambiguityLevel": "LOW" | "MEDIUM" | "HIGH",
    "requiresWebSearch": <boolean>
  },
  "queryAnalysis": {
    "sanitizedQuery": <string>,
    "detectedTokens": <string[]>,
    "comparisonRequest": {
      "isComparison": <boolean>,
      "tokens": <string[]>,
      "aspects": <string[]>,
      "primaryMetric": <string | null>
    },
    "detectedIntents": <string[]>,
    "timeContext": "current" | "24h" | "7d" | "30d" | null,
    "marketIndicators": <string[]>,
    "conceptualIndicators": <string[]>,
    "webSearchContext": {
      "needed": <boolean>,
      "reason": <string | null>,
      "suggestedQueries": <string[]>
    }
  },
  "dataRequirements": {
    "marketData": {
      "needed": <boolean>,
      "types": <string[]>,
      "timeframe": "current" | "24h" | "7d" | "30d" | null,
      "tokenCount": <number>
    },
    "conceptualData": {
      "needed": <boolean>,
      "aspects": <string[]>
    }
  }
}

CRITICAL REQUIREMENTS:
1. ALWAYS include ALL fields exactly as shown above
2. NEVER omit any fields or change the structure
3. ALWAYS validate token count <= 5
4. ENSURE all string arrays contain valid strings
5. SET needsApiCall=true for any market data requests
6. SET requiresWebSearch=true for news/regulatory queries
7. INCLUDE clear reason when webSearchContext.needed=true
8. VALIDATE all enums match specified values exactly
9. For market data:
   - Set tokenCount accurately
   - Include all required data types
   - Set timeframe appropriately
10. For comparisons:
    - Set comparisonRequest.isComparison = true
    - Include all detected tokens in comparisonRequest.tokens
    - List relevant aspects in comparisonRequest.aspects
    - Set primaryMetric based on query focus
11. For news/regulatory/security queries:
    - Set requiresWebSearch = true
    - Include clear reason in webSearchContext
    - Provide relevant suggestedQueries
12. For conceptual/technical queries:
    - Set marketData.needed = false
    - Set marketData.tokenCount = 0
    - Include relevant aspects in conceptualData`;

function preprocessQuery(query: string): PreprocessingStep[] {
  const steps: PreprocessingStep[] = [];
  
  try {
    if (!query?.trim()) {
      throw new PreprocessingError('Empty query', 'sanitize');
    }

    let processed = query.trim();
    steps.push({
      operation: 'sanitize',
      input: query,
      output: processed
    });

    processed = processed.toLowerCase();
    const tokenMappings: Record<string, string> = {
      'btc': 'bitcoin',
      'eth': 'ethereum',
      'sol': 'solana',
      'doge': 'dogecoin',
      'ada': 'cardano',
      'bnb': 'binancecoin',
      'xrp': 'ripple',
      'dot': 'polkadot',
      'matic': 'polygon',
      'avax': 'avalanche-2',
      'link': 'chainlink',
      'uni': 'uniswap',
      'atom': 'cosmos',
      'ltc': 'litecoin',
      'luna': 'terra-luna-2',
      'lunc': 'terra-luna'
    };

    for (const [abbr, full] of Object.entries(tokenMappings)) {
      processed = processed.replace(new RegExp(`\\b${abbr}\\b`, 'g'), full);
    }
    steps.push({
      operation: 'normalize_tokens',
      input: processed,
      output: processed
    });

    return steps;
  } catch (error) {
    if (error instanceof PreprocessingError) {
      throw error;
    }
    throw new PreprocessingError(
      'Preprocessing failed',
      'unknown',
      query
    );
  }
}

function extractMetadata(query: string, steps: PreprocessingStep[]): QueryMetadata {
  try {
    const processedQuery = steps[steps.length - 1].output;
    
    const commonTokens = [
      'bitcoin', 'ethereum', 'solana', 'dogecoin', 'cardano',
      'binancecoin', 'ripple', 'polkadot', 'polygon', 'avalanche-2',
      'chainlink', 'uniswap', 'cosmos', 'litecoin', 'terra-luna-2',
      'terra-luna'
    ];

    const tokens = processedQuery
      .split(/\s+/)
      .filter(token => 
        token.length > 1 && 
        !['price', 'show', 'me', 'what', 'is', 'the', 'of', 'and', 'vs', 'versus', 'compare'].includes(token)
      );

    const uniqueTokens = Array.from(new Set(tokens))
      .filter(token => 
        commonTokens.includes(token) || 
        /^[a-z0-9]+$/.test(token)
      )
      .slice(0, 5);

    const hints = [];
    if (query.includes('price')) hints.push('PRICE_QUERY');
    if (query.includes('compare') || query.includes('vs') || query.includes('versus')) hints.push('COMPARISON');
    if (query.includes('trend')) hints.push('TREND_ANALYSIS');
    if (query.includes('how') || query.includes('what')) hints.push('EDUCATIONAL');
    if (uniqueTokens.length > 1) hints.push('MULTI_TOKEN');
    if (query.includes('news') || query.includes('latest')) hints.push('NEWS');
    if (query.includes('regulation') || query.includes('legal')) hints.push('REGULATORY');
    if (query.includes('security') || query.includes('safe')) hints.push('SECURITY');
    if (query.includes('defi') || query.includes('yield')) hints.push('DEFI');

    return {
      tokens: uniqueTokens,
      entities: uniqueTokens.filter(token => commonTokens.includes(token)),
      contextualHints: hints
    };
  } catch (error) {
    throw new PreprocessingError(
      'Metadata extraction failed',
      'metadata',
      query
    );
  }
}

async function retryWithExponentialBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      if (error instanceof Error && error.message.includes('rate limit')) {
        const delay = initialDelay * Math.pow(2, i);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      throw error;
    }
  }
  
  throw lastError || new Error('Operation failed after retries');
}

export async function analyzeUserQuery(input: Agent1Input): Promise<RobustAnalysis> {
  try {
    const startTime = Date.now();
    const preprocessingSteps = preprocessQuery(input.query);
    const metadata = extractMetadata(input.query, preprocessingSteps);

    const client = getOpenAIClient();
    const completion = await retryWithExponentialBackoff(async () => {
      return client.createChatCompletion({
        model: OPENAI_MODEL,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: preprocessingSteps[preprocessingSteps.length - 1].output }
        ],
        temperature: 0.1,
        max_tokens: 1000,
      });
    });

    const response = completion.data.choices[0]?.message?.content;
    if (!response) {
      throw new LLMError('No response from OpenAI');
    }

    const parsedResponse = validateLLMResponse(response);
    
    const analysis: RobustAnalysis = {
      originalContext: {
        rawQuery: input.query,
        timestamp: startTime,
        preprocessingSteps,
        metadata
      },
      classification: parsedResponse.classification,
      queryAnalysis: parsedResponse.queryAnalysis,
      dataRequirements: parsedResponse.dataRequirements
    };

    validateAnalysis(analysis);

    return analysis;

  } catch (error) {
    console.error('Intent analysis error:', error);
    
    if (error instanceof PreprocessingError) {
      throw new Error(`Preprocessing failed at ${error.step}: ${error.message}`);
    }
    if (error instanceof LLMError) {
      throw new Error(`LLM error: ${error.message}`);
    }
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('Unknown error during analysis');
  }
}

================================================================================
File: lib/agents/regulatory.ts
================================================================================

import { TokenCache } from './token-cache';

interface RegulatoryUpdate {
  id: string;
  title: string;
  summary: string;
  jurisdiction: string;
  authority: string;
  date: string;
  url: string;
  category: string;
  impact: 'HIGH' | 'MEDIUM' | 'LOW';
  status: 'PROPOSED' | 'ENACTED' | 'UNDER_REVIEW';
  relatedAssets?: string[];
}

interface CrystalRiskData {
  address?: string;
  riskScore: number;
  riskLevel: 'HIGH' | 'MEDIUM' | 'LOW';
  categories: string[];
  lastUpdated: string;
}

interface RegulatorySearchParams {
  jurisdiction?: string;
  timeRange?: string;
  category?: string;
  asset?: string;
  status?: string;
}

class RegulatoryCache extends TokenCache {
  constructor() {
    super(1800000); // 30 minutes cache for regulatory data
  }
}

const regulatoryCache = new RegulatoryCache();

async function fetchCrystalData(address: string): Promise<CrystalRiskData> {
  const apiKey = process.env.CRYSTAL_API_KEY;
  if (!apiKey) {
    throw new Error('Crystal API key not configured');
  }

  const cacheKey = `crystal-${address}`;
  const cachedData = regulatoryCache.get(cacheKey);
  if (cachedData) return cachedData;

  try {
    const response = await fetch(
      `https://api.crystalblockchain.com/v1/risk/${address}`,
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Crystal API error: ${response.status}`);
    }

    const data = await response.json();
    const riskData: CrystalRiskData = {
      address,
      riskScore: data.risk_score,
      riskLevel: data.risk_level,
      categories: data.risk_categories,
      lastUpdated: new Date().toISOString()
    };

    regulatoryCache.set(cacheKey, riskData);
    return riskData;
  } catch (error) {
    console.error('Crystal API error:', error);
    throw error;
  }
}

async function fetchChainalysisData(asset: string): Promise<any> {
  const apiKey = process.env.CHAINALYSIS_API_KEY;
  if (!apiKey) {
    throw new Error('Chainalysis API key not configured');
  }

  const cacheKey = `chainalysis-${asset}`;
  const cachedData = regulatoryCache.get(cacheKey);
  if (cachedData) return cachedData;

  try {
    const response = await fetch(
      `https://api.chainalysis.com/api/v1/asset/${asset}/compliance`,
      {
        headers: {
          'X-API-Key': apiKey,
          'Content-Type': 'application/json'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Chainalysis API error: ${response.status}`);
    }

    const data = await response.json();
    regulatoryCache.set(cacheKey, data);
    return data;
  } catch (error) {
    console.error('Chainalysis API error:', error);
    throw error;
  }
}

export async function getRegulatoryUpdates(
  params: RegulatorySearchParams
): Promise<RegulatoryUpdate[]> {
  const cacheKey = `regulatory-${JSON.stringify(params)}`;
  const cachedData = regulatoryCache.get(cacheKey);
  if (cachedData) return cachedData;

  try {
    // Fetch from multiple sources and combine results
    const [crystalUpdates, chainalysisUpdates] = await Promise.all([
      params.asset ? fetchCrystalData(params.asset).then(data => ({
        id: `crystal-${params.asset}`,
        title: `Risk assessment for ${params.asset}`,
        summary: `Crystal Blockchain risk assessment for ${params.asset}`,
        jurisdiction: 'GLOBAL',
        authority: 'Crystal Blockchain',
        date: data.lastUpdated,
        url: 'https://crystalblockchain.com/',
        category: data.categories[0] || 'RISK_ASSESSMENT',
        impact: data.riskLevel,
        status: 'ENACTED',
        relatedAssets: [params.asset]
      })) : Promise.resolve(null),
      params.asset ? fetchChainalysisData(params.asset).then(data => ({
        id: `chainalysis-${params.asset}`,
        title: `Chainalysis report for ${params.asset}`,
        summary: data.summary || `Chainalysis report for ${params.asset}`,
        jurisdiction: 'GLOBAL',
        authority: 'Chainalysis',
        date: new Date().toISOString(),
        url: 'https://chainalysis.com/',
        category: 'RISK_ASSESSMENT',
        impact: data.riskLevel || 'MEDIUM',
        status: 'ENACTED',
        relatedAssets: [params.asset]
      })) : Promise.resolve(null)
    ]);

    // Use type assertion to help TypeScript understand the filter
    const updates = [
      crystalUpdates,
      chainalysisUpdates
    ].filter(Boolean) as RegulatoryUpdate[];

    regulatoryCache.set(cacheKey, updates);
    return updates;
  } catch (error) {
    console.error('Regulatory data fetch error:', error);
    throw error;
  }
}

export async function getComplianceRisk(
  asset: string
): Promise<{
  riskScore: number;
  riskLevel: string;
  details: string[];
}> {
  try {
    const [crystalData, chainalysisData] = await Promise.all([
      fetchCrystalData(asset),
      fetchChainalysisData(asset)
    ]);

    return {
      riskScore: (crystalData.riskScore + chainalysisData.riskScore) / 2,
      riskLevel: crystalData.riskLevel,
      details: [
        ...crystalData.categories,
        ...chainalysisData.riskFactors || []
      ]
    };
  } catch (error) {
    console.error('Compliance risk assessment error:', error);
    throw error;
  }
}

================================================================================
File: lib/agents/security/contract-validator.ts
================================================================================

// Security issue interface
export interface SecurityIssue {
  severity: 'high' | 'medium' | 'low' | 'info';
  title: string;
  description: string;
  line?: number;
  column?: number;
}

// Validation result interface
export interface ValidationResult {
  valid: boolean;
  issues: SecurityIssue[];
}

// Basic patterns to check for common security issues
const SECURITY_PATTERNS = [
  {
    pattern: /selfdestruct|suicide/i,
    severity: 'high' as const,
    title: 'Self-destruct found',
    description: 'The contract contains a self-destruct function which can permanently destroy the contract.'
  },
  {
    pattern: /tx\.origin/i,
    severity: 'high' as const,
    title: 'tx.origin used for authentication',
    description: 'Using tx.origin for authentication is vulnerable to phishing attacks.'
  },
  {
    pattern: /block\.(timestamp|number|difficulty)/i,
    severity: 'medium' as const,
    title: 'Block properties used as source of randomness',
    description: 'Block properties like timestamp, number, or difficulty are not secure sources of randomness.'
  },
  {
    pattern: /function\s+\w+\s*\(\s*\)\s*public\s+payable\s*\{\s*\}/i,
    severity: 'medium' as const,
    title: 'Empty payable function',
    description: 'Contract has an empty payable function which can lock funds.'
  },
  {
    pattern: /assembly\s*\{/i,
    severity: 'medium' as const,
    title: 'Assembly code used',
    description: 'Contract uses assembly code which bypasses Solidity safety features.'
  },
  {
    pattern: /\.call\.value\s*\(/i,
    severity: 'medium' as const,
    title: 'Low-level call with value',
    description: 'Low-level calls with value can lead to reentrancy attacks if not properly guarded.'
  },
  {
    pattern: /\.transfer\s*\(/i,
    severity: 'low' as const,
    title: 'Transfer used',
    description: 'Consider using call instead of transfer as transfer has a gas limit of 2300 gas.'
  },
  {
    pattern: /pragma\s+solidity\s+(\^|>|>=|<|<=)\s*0\.8/i,
    severity: 'info' as const,
    title: 'Solidity version',
    description: 'Contract uses Solidity version 0.8.x which has built-in overflow protection.'
  }
];

// Validate a contract for security issues
export async function validateContract(source: string): Promise<ValidationResult> {
  const issues: SecurityIssue[] = [];
  
  // Check for security patterns
  for (const pattern of SECURITY_PATTERNS) {
    const matches = source.match(pattern.pattern);
    if (matches) {
      issues.push({
        severity: pattern.severity,
        title: pattern.title,
        description: pattern.description
      });
    }
  }
  
  // Check for reentrancy vulnerabilities
  if (
    source.includes('.call{value:') && 
    !source.includes('ReentrancyGuard') && 
    !source.includes('nonReentrant')
  ) {
    issues.push({
      severity: 'high',
      title: 'Potential reentrancy vulnerability',
      description: 'Contract uses .call{value:} without reentrancy protection. Consider using ReentrancyGuard.'
    });
  }
  
  // Check for unchecked external calls
  if (
    (source.includes('.call(') || source.includes('.call{')) && 
    !source.match(/require\s*\(\s*\w+\s*\)/)
  ) {
    issues.push({
      severity: 'medium',
      title: 'Unchecked external call',
      description: 'External call result is not checked. Always verify the return value of low-level calls.'
    });
  }
  
  // Check for unbounded loops
  if (source.match(/for\s*\(\s*.*;\s*.*;\s*.*\)/)) {
    const hasArrayLength = source.match(/for\s*\(\s*.*;\s*\w+\s*<\s*\w+\.length/);
    if (hasArrayLength) {
      issues.push({
        severity: 'medium',
        title: 'Potentially unbounded loop',
        description: 'Loop over array without fixed bounds could run out of gas for large arrays.'
      });
    }
  }
  
  // Check for proper visibility
  if (source.match(/function\s+\w+\s*\([^)]*\)\s*\{/)) {
    issues.push({
      severity: 'medium',
      title: 'Missing function visibility',
      description: 'Functions without explicit visibility default to public.'
    });
  }
  
  // Check for state variables without visibility
  if (source.match(/^\s*\w+\s+\w+\s*;/m)) {
    issues.push({
      severity: 'low',
      title: 'State variable missing visibility',
      description: 'State variables should have explicit visibility (public, private, internal).'
    });
  }
  
  // Determine if the contract is valid based on high severity issues
  const hasHighSeverityIssues = issues.some(issue => issue.severity === 'high');
  
  return {
    valid: !hasHighSeverityIssues,
    issues
  };
}

// Validate a transaction before sending
export async function validateTransaction(
  to: string, 
  value: bigint, 
  data: string | undefined
): Promise<ValidationResult> {
  const issues: SecurityIssue[] = [];
  
  // Check if sending to address(0)
  if (to === '0x0000000000000000000000000000000000000000') {
    issues.push({
      severity: 'high',
      title: 'Sending to zero address',
      description: 'Transaction is sending to the zero address, which will burn the funds.'
    });
  }
  
  // Check if sending a large amount of ETH
  if (value > 10000000000000000000n) { // > 10 ETH
    issues.push({
      severity: 'medium',
      title: 'Large value transfer',
      description: 'Transaction is sending a large amount of ETH. Please verify the recipient address.'
    });
  }
  
  // Check if the transaction has data but no value (potential contract interaction)
  if (data && data !== '0x' && value === 0n) {
    // This is likely a contract interaction, which is fine
  }
  
  // Check if the transaction has both value and data (potential contract interaction with value)
  if (data && data !== '0x' && value > 0n) {
    issues.push({
      severity: 'low',
      title: 'Contract interaction with value',
      description: 'Transaction is sending ETH to a contract. Ensure the contract can handle ETH transfers.'
    });
  }
  
  return {
    valid: !issues.some(issue => issue.severity === 'high'),
    issues
  };
} 

================================================================================
File: lib/agents/summarization.ts
================================================================================

import { Configuration, OpenAIApi } from 'openai';
import { SummarizationInput } from './types';
import { ConversationStore, ChatMessage } from '../conversation-store';

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
let openai: OpenAIApi | null = null;

function getOpenAIClient() {
  if (!openai) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    const configuration = new Configuration({ apiKey });
    openai = new OpenAIApi(configuration);
  }
  return openai;
}

function generateTokenPriceResponse(tokenName: string, data: any): string {
  // Check if we have error information
  if (data?.error) {
    return `### ${tokenName} Price Information

I apologize, but I couldn't retrieve the current price for **${tokenName}**. This could be because:
- The token might not be listed on major exchanges
- The token symbol might be different than expected
- The token might only be available on specific platforms

To find accurate price information, you could:
1. Check decentralized exchanges (DEXs)
2. Visit the token's official website or community channels
3. Search with alternative token symbols
4. Check specialized crypto tracking platforms

Would you like to:
- Search for another token?
- Get information about major cryptocurrencies instead?
- Learn more about finding prices for newer tokens?`;
  }

  // Handle successful price data
  if (data?.current_price) {
    return `### Current ${tokenName} Price Data

**Price**: $${data.current_price.toFixed(6)}
**24h Change**: ${data.price_change_percentage_24h.toFixed(2)}%
**Market Cap**: $${formatMarketCap(data.market_cap)}

*Data source: ${data.source}*

Would you like to:
- See detailed market metrics?
- Compare with other tokens?
- View historical price data?`;
  }

  // Generic fallback response
  return `### ${tokenName} Price Query

I apologize, but I couldn't find current price information for **${tokenName}**. 
The token data might be unavailable or the token symbol might need verification.

Try checking:
- Popular crypto exchanges
- Token tracking websites
- The project's official channels

Would you like to search for a different token or get information about major cryptocurrencies instead?`;
}

function formatMarketCap(marketCap: number): string {
  if (marketCap >= 1e9) {
    return `${(marketCap / 1e9).toFixed(2)}B`;
  }
  if (marketCap >= 1e6) {
    return `${(marketCap / 1e6).toFixed(2)}M`;
  }
  if (marketCap >= 1e3) {
    return `${(marketCap / 1e3).toFixed(2)}K`;
  }
  return marketCap.toString();
}

const SYSTEM_PROMPT = `You are an advanced blockchain and cryptocurrency analysis system providing detailed, accurate responses based on real-time market data, regulatory information, news, and comprehensive blockchain knowledge.

CONTEXT TYPES AND HANDLING:

1. Market Data (MARKET_DATA, COMPARISON):
   - Present prices with appropriate decimals (6 for < $1, 2 for >= $1)
   - Format market caps using B/M/K notation
   - Include percentage changes with +/- prefix
   - Show relevant volume and liquidity metrics
   - Compare multiple tokens when relevant

2. Technical Information (TECHNICAL):
   - Explain blockchain concepts clearly
   - Use appropriate technical terminology
   - Include code examples when relevant
   - Reference specific protocols or standards
   - Explain security implications

3. DeFi Analysis (DEFI):
   - Present TVL and yield data
   - Explain protocol mechanisms
   - Discuss risks and security considerations
   - Compare with similar protocols
   - Include liquidity metrics

4. Regulatory Updates (REGULATORY):
   - Summarize latest regulatory developments
   - Specify jurisdictions affected
   - Explain potential impact
   - Include compliance requirements
   - Reference official sources
   - Present risk assessments when available

5. News and Events (NEWS_EVENTS):
   - Summarize recent developments
   - Provide context and implications
   - Include relevant dates
   - Reference multiple sources
   - Maintain objectivity

6. Security Analysis (SECURITY):
   - Present risk assessments
   - Explain vulnerabilities
   - Provide security recommendations
   - Reference audits and incidents
   - Include best practices

RESPONSE STRUCTURE:

1. Market Data Format:
   - Prices: 6 decimals for < $1, 2 decimals for >= $1
   - Market Cap: Use B/M/K notation (e.g., $50.5B)
   - Percentages: Include +/- prefix, 2 decimal places
   - Time References: Include timezone or relative time

2. Regulatory Format:
   - Jurisdiction: Clearly state affected regions
   - Status: Indicate if proposed/enacted/under review
   - Impact: HIGH/MEDIUM/LOW classification
   - Compliance: List specific requirements
   - Sources: Reference official documentation

3. News Format:
   - Date: Recent first, include timestamps
   - Source: Credit reputable sources
   - Impact: Explain significance
   - Context: Provide background
   - Follow-up: Suggest related queries

4. Technical Format:
   - Concepts: Clear explanations
   - Code: Properly formatted examples
   - Standards: Reference specifications
   - Security: Note important considerations
   - Resources: Link to documentation

CRITICAL REQUIREMENTS:

1. Accuracy:
   - Never invent or estimate missing data
   - Clearly indicate data sources
   - Acknowledge limitations
   - State when information is incomplete
   - Update timestamps for time-sensitive data

2. Clarity:
   - Use appropriate technical terms
   - Explain complex concepts
   - Structure information logically
   - Highlight important points
   - Maintain consistent formatting

3. Context:
   - Reference relevant background
   - Explain implications
   - Compare with alternatives
   - Note important caveats
   - Suggest related queries

4. Sources:
   - Credit data providers
   - Reference official documents
   - Link to specifications
   - Cite regulatory bodies
   - Include timestamps

5. Response Formatting:
   - Use markdown for formatting
   - Create clear sections with headers
   - Use bullet points for lists
   - Format code blocks properly
   - Include line breaks for readability

6. Error Handling:
   - Acknowledge missing data
   - Explain why data might be unavailable
   - Suggest alternative sources
   - Provide guidance for finding information
   - Recommend follow-up queries

7. Conversation Continuity:
   - Reference previous context when relevant
   - Build upon earlier discussions
   - Maintain consistent terminology
   - Track user preferences
   - Suggest logical next queries`;

export async function generateSummary(input: SummarizationInput): Promise<string> {
  const { userQuery, analysis, aggregatorResult, sessionId, enhancedContext } = input;

  try {
    const client = getOpenAIClient();
    
    // Check if we have any valid data
    const hasValidData = aggregatorResult?.primary?.coingecko || 
                        aggregatorResult?.primary?.coinmarketcap;

    // If this is a price query and we have token data, use the specialized formatter
    if (analysis.classification.primaryIntent === 'MARKET_DATA' && 
        analysis.queryAnalysis.detectedTokens.length === 1) {
      const tokenName = analysis.queryAnalysis.detectedTokens[0];
      const tokenData = aggregatorResult?.primary?.coingecko?.[tokenName] || 
                       aggregatorResult?.primary?.coinmarketcap?.[tokenName];
      
      if (tokenData) {
        return generateTokenPriceResponse(tokenName, tokenData);
      }
    }

    // Format the system message to include context handling instructions
    const systemMessage = `${SYSTEM_PROMPT}\n\nWhen generating responses:
1. Consider the user's technical level and interests
2. Maintain conversation continuity with previous topics
3. Use appropriate terminology based on user's expertise
4. Reference relevant history when appropriate
5. Adapt explanation depth based on user preferences`;

    // Build the conversation context
    const messages = [
      { role: "system" as const, content: systemMessage }
    ];

    // Add enhanced context if available
    if (enhancedContext) {
      messages.push({
        role: "system" as const,
        content: `Conversation Context:\n${enhancedContext}`
      });
    }

    // If no valid data, provide a helpful response
    if (!hasValidData && analysis.classification.needsApiCall) {
      messages.push({
        role: "system" as const,
        content: `Generate a helpful response for a failed data fetch. Query: "${userQuery}". 
Consider:
1. Common reasons for missing data
2. Alternative ways to find the information
3. Suggestions for similar tokens or topics
4. Guidance on verifying token information
5. Next steps the user can take`
      });
    } else {
      // Add the current query and data
      messages.push({
        role: "system" as const,
        content: `Query: ${userQuery}\n\nAnalysis Context:\n${JSON.stringify(analysis, null, 2)}\n\nAvailable Data:\n${JSON.stringify(aggregatorResult, null, 2)}`
      });
    }

    const completion = await client.createChatCompletion({
      model: OPENAI_MODEL,
      messages,
      temperature: 0.3,
      max_tokens: 700,
      presence_penalty: 0.1,
      frequency_penalty: 0.1
    });

    const response = completion.data.choices[0]?.message?.content;
    if (!response) {
      throw new Error('No response from GPT');
    }

    return response.trim();

  } catch (error) {
    console.error('Summary generation error:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        throw new Error('OpenAI API key is not configured');
      }
      if (error.message.includes('429')) {
        throw new Error('Rate limit exceeded. Please try again in a moment');
      }
      if (error.message.includes('401')) {
        throw new Error('Authentication failed. Please check API key configuration');
      }
      if (error.message.includes('insufficient_quota')) {
        throw new Error('OpenAI API quota exceeded. Please try again later');
      }
      throw error;
    }
    
    throw new Error('Failed to generate summary');
  }
}

================================================================================
File: lib/agents/token-cache.ts
================================================================================

interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

export class TokenCache {
  protected cache: Map<string, CacheEntry<any>>;
  protected readonly TTL: number;

  constructor(ttl: number = 60000) { // Default 1 minute cache
    this.cache = new Map();
    this.TTL = ttl;
  }

  get(key: string): any | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    if (Date.now() - entry.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  set(key: string, data: any): void {
    if (Object.keys(data).length > 0) {
      this.cache.set(key, {
        data,
        timestamp: Date.now()
      });
    }
  }

  getPartial(keys: string[]): Record<string, any> {
    const result: Record<string, any> = {};
    for (const key of keys) {
      const data = this.get(key);
      if (data) {
        Object.assign(result, { [key]: data });
      }
    }
    return result;
  }

  setPartial(keys: string[], data: Record<string, any>): void {
    // Store combined data
    this.set(keys.sort().join(','), data);
    
    // Store individual entries
    for (const [key, value] of Object.entries(data)) {
      this.set(key, { [key]: value });
    }
  }

  clear(): void {
    this.cache.clear();
  }

  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.TTL) {
        this.cache.delete(key);
      }
    }
  }
}

================================================================================
File: lib/agents/transaction/token-transfer-agent.ts
================================================================================

import { walletService, WalletIntegrationService } from '../../blockchain/wallet-integration';
import { tokenRegistry } from '../../blockchain/token-registry';
import { validateTransaction } from '../security/contract-validator';
import { publicClient } from '../../blockchain/providers';

export interface TransferParams {
  // Token information (null for ETH)
  tokenAddress?: `0x${string}` | null;
  
  // Transfer details
  to: `0x${string}`;
  amount: string;
  
  // Chain information
  chainId: number;
  
  // Transaction options
  gasLimit?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
}

export interface TransferResult {
  transactionHash: `0x${string}`;
  tokenAddress: `0x${string}` | null;
  to: `0x${string}`;
  amount: string;
  amountInWei: bigint;
  status: 'pending' | 'success' | 'failed';
  receipt?: any;
  error?: string;
}

export class TokenTransferAgent {
  private transfers = new Map<string, TransferResult>();

  // Transfer ETH or tokens
  async transferTokens(params: TransferParams): Promise<TransferResult> {
    try {
      // Check if wallet is connected
      if (!walletService.isConnected()) {
        throw new Error('Wallet not connected');
      }
      
      // Validate recipient address
      if (!params.to || !params.to.startsWith('0x')) {
        throw new Error('Invalid recipient address');
      }
      
      // Validate amount
      if (!params.amount || isNaN(Number(params.amount)) || Number(params.amount) <= 0) {
        throw new Error('Invalid amount');
      }
      
      // Determine if this is an ETH transfer or token transfer
      const isEthTransfer = !params.tokenAddress;
      
      let amountInWei: bigint;
      let txHash: `0x${string}`;
      
      if (isEthTransfer) {
        // ETH transfer
        amountInWei = WalletIntegrationService.parseEther(params.amount);
        
        // Validate transaction
        const validationResult = await validateTransaction(params.to, amountInWei, undefined);
        if (!validationResult.valid) {
          throw new Error(`Transaction validation failed: ${validationResult.issues.map(i => i.title).join(', ')}`);
        }
        
        // Prepare transaction options
        const txOptions: any = {
          to: params.to,
          value: amountInWei,
          data: undefined
        };
        
        // Add gas parameters if provided
        if (params.gasLimit) {
          txOptions.gasLimit = BigInt(params.gasLimit);
        }
        if (params.maxFeePerGas) {
          txOptions.maxFeePerGas = BigInt(params.maxFeePerGas);
        }
        if (params.maxPriorityFeePerGas) {
          txOptions.maxPriorityFeePerGas = BigInt(params.maxPriorityFeePerGas);
        }
        
        // Send transaction
        txHash = await walletService.sendTransaction(txOptions);
      } else {
        // Token transfer
        // Get token info
        const tokenInfo = await tokenRegistry.getToken(params.tokenAddress!, params.chainId);
        if (!tokenInfo) {
          // Try to load token info from blockchain
          await tokenRegistry.loadTokenInfo(params.tokenAddress!, params.chainId);
        }
        
        // Convert amount to token decimals
        const token = tokenRegistry.getToken(params.tokenAddress!, params.chainId);
        if (!token) {
          throw new Error(`Token information not found for ${params.tokenAddress}`);
        }
        
        // Calculate amount in wei based on token decimals
        amountInWei = WalletIntegrationService.parseEther(params.amount);
        if (token.decimals !== 18) {
          // Adjust for token decimals
          const decimalsDiff = 18 - token.decimals;
          if (decimalsDiff > 0) {
            amountInWei = amountInWei / BigInt(10 ** decimalsDiff);
          } else {
            amountInWei = amountInWei * BigInt(10 ** Math.abs(decimalsDiff));
          }
        }
        
        // Transfer tokens
        txHash = await tokenRegistry.transfer(
          params.tokenAddress!,
          params.to,
          amountInWei,
          params.chainId
        );
      }
      
      // Create transfer result
      const transferResult: TransferResult = {
        transactionHash: txHash,
        tokenAddress: params.tokenAddress || null,
        to: params.to,
        amount: params.amount,
        amountInWei,
        status: 'pending'
      };
      
      // Store the transfer
      this.transfers.set(txHash, transferResult);
      
      // Wait for transaction confirmation in the background
      this.waitForTransfer(txHash);
      
      return transferResult;
    } catch (error) {
      console.error('Token transfer error:', error);
      throw new Error(`Failed to transfer tokens: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Wait for transfer confirmation
  private async waitForTransfer(hash: `0x${string}`): Promise<void> {
    try {
      // Wait for transaction receipt
      const receipt = await walletService.waitForTransaction(hash);
      
      // Update transfer result
      const transfer = this.transfers.get(hash);
      if (transfer) {
        transfer.status = receipt.status === 'success' ? 'success' : 'failed';
        transfer.receipt = receipt;
        
        this.transfers.set(hash, transfer);
      }
    } catch (error) {
      console.error('Transfer confirmation error:', error);
      
      // Update transfer status to failed
      const transfer = this.transfers.get(hash);
      if (transfer) {
        transfer.status = 'failed';
        transfer.error = `Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
        this.transfers.set(hash, transfer);
      }
    }
  }

  // Get transfer status
  getTransfer(hash: `0x${string}`): TransferResult | null {
    return this.transfers.get(hash) || null;
  }

  // Get all transfers
  getAllTransfers(): TransferResult[] {
    return Array.from(this.transfers.values());
  }

  // Get pending transfers
  getPendingTransfers(): TransferResult[] {
    return Array.from(this.transfers.values()).filter(transfer => transfer.status === 'pending');
  }
}

// Export singleton instance
export const tokenTransferAgent = new TokenTransferAgent(); 

================================================================================
File: lib/agents/types.ts
================================================================================

// Core intent types
export type IntentType = 
  | 'MARKET_DATA' 
  | 'COMPARISON' 
  | 'TECHNICAL' 
  | 'DEFI'
  | 'REGULATORY'
  | 'NEWS_EVENTS'
  | 'SECURITY'
  | 'CONCEPTUAL'
  | 'HYBRID'
  | 'NEEDS_CONTEXT';

// Market data types expanded
export type MarketDataType = 
  | 'price' 
  | 'market_cap' 
  | 'volume_24h' 
  | 'trending'
  | 'supply'
  | 'volume'
  | 'defi_tvl'
  | 'yield'
  | 'liquidity';

// Time frames
export type TimeFrame = 
  | 'current'
  | '24h'
  | '7d'
  | '30d'
  | null;

// Technical content types
export type TechnicalContentType =
  | 'smart_contract'
  | 'protocol'
  | 'architecture'
  | 'implementation'
  | 'code_example';

// News and regulatory content types
export type NewsContentType =
  | 'announcement'
  | 'update'
  | 'regulation'
  | 'policy'
  | 'security_incident'
  | 'market_event';

// DeFi specific types
export type DefiContentType =
  | 'protocol_metrics'
  | 'yield_data'
  | 'tvl_analysis'
  | 'pool_statistics'
  | 'farming_data';

// Enhanced comparison types
export interface ComparisonRequest {
  isComparison: boolean;
  tokens: string[];
  aspects: string[];
  primaryMetric: string | null;
  technicalAspects?: string[];
  defiMetrics?: string[];
}

// Web search context type
export interface WebSearchContext {
  needed: boolean;
  reason: string | null;
  suggestedQueries: string[];
  contentTypes: NewsContentType[];
  timeRange?: string;
}

// Analysis requirements
export interface DataRequirements {
  marketData: {
    needed: boolean;
    types: MarketDataType[];
    timeframe: TimeFrame;
    tokenCount: number;
  };
  conceptualData: {
    needed: boolean;
    aspects: string[];
  };
  technicalData?: {
    needed: boolean;
    types: TechnicalContentType[];
    codeLanguages?: string[];
  };
  defiData?: {
    needed: boolean;
    types: DefiContentType[];
    protocols?: string[];
  };
  newsData?: {
    needed: boolean;
    types: NewsContentType[];
    timeRange?: string;
  };
}

// Original context preservation
export interface OriginalContext {
  rawQuery: string;
  timestamp: number;
  preprocessingSteps: PreprocessingStep[];
  metadata: QueryMetadata;
}

export interface PreprocessingStep {
  operation: string;
  input: string;
  output: string;
}

export interface QueryMetadata {
  tokens: string[];
  entities: string[];
  contextualHints: string[];
  technicalTerms?: string[];
  defiProtocols?: string[];
}

// Main analysis interface
export interface RobustAnalysis {
  originalContext: OriginalContext;
  classification: {
    primaryIntent: IntentType;
    confidence: number;
    needsApiCall: boolean;
    ambiguityLevel: 'LOW' | 'MEDIUM' | 'HIGH';
    requiresWebSearch: boolean;
  };
  queryAnalysis: {
    sanitizedQuery: string;
    detectedTokens: string[];
    comparisonRequest: ComparisonRequest;
    detectedIntents: string[];
    timeContext: TimeFrame;
    marketIndicators: string[];
    conceptualIndicators: string[];
    webSearchContext: WebSearchContext;
  };
  dataRequirements: DataRequirements;
}

// Input/Output types
export interface Agent1Input {
  query: string;
}

export interface SummarizationInput {
  userQuery: string;
  analysis: RobustAnalysis;
  aggregatorResult: AggregatorResult | null;
  sessionId?: string;
  enhancedContext?: string;
}

export interface AggregatorResult {
  primary?: {
    coingecko?: any;
    defiLlama?: any;
    theGraph?: any;
    coinmarketcap?: any;
  };
  fallback?: {
    googleSearch?: any;
    webSearch?: any;
    potentialCoinGeckoLinks?: string[];
    firstSnippet?: string;
  };
}

export interface OrchestrationResult {
  analysis: RobustAnalysis;
  aggregatorData: AggregatorResult | null;
  response: string;
  suggestions?: string[];
  contextAnalysis?: {
    isCoherent: boolean;
    confidence: number;
  };
}

// Aggregator specification
export interface AggregatorSpec {
  primary: {
    coingecko?: any;
    defiLlama?: any;
    theGraph?: any;
    news?: any;
    regulatory?: any;
    security?: any;
  };
  fallback: {
    coingecko?: any;
    webSearch?: any;
  };
}

================================================================================
File: lib/agents/validation.ts
================================================================================

import { z } from 'zod';
import type { RobustAnalysis } from './types';

// Custom error types
export class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public details?: z.ZodError
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class PreprocessingError extends Error {
  constructor(
    message: string,
    public step: string,
    public input?: string
  ) {
    super(message);
    this.name = 'PreprocessingError';
  }
}

export class LLMError extends Error {
  constructor(
    message: string,
    public response?: any
  ) {
    super(message);
    this.name = 'LLMError';
  }
}

// Validation schemas
const classificationSchema = z.object({
  primaryIntent: z.enum([
    'MARKET_DATA',
    'COMPARISON',
    'TECHNICAL',
    'DEFI',
    'REGULATORY',
    'NEWS_EVENTS',
    'SECURITY',
    'CONCEPTUAL',
    'HYBRID',
    'NEEDS_CONTEXT'
  ] as const),
  confidence: z.number().min(0).max(1),
  needsApiCall: z.boolean(),
  ambiguityLevel: z.enum(['LOW', 'MEDIUM', 'HIGH'] as const),
  requiresWebSearch: z.boolean()
});

const comparisonRequestSchema = z.object({
  isComparison: z.boolean(),
  tokens: z.array(z.string()).max(5),
  aspects: z.array(z.string()),
  primaryMetric: z.string().nullable()
});

const webSearchContextSchema = z.object({
  needed: z.boolean(),
  reason: z.string().nullable(),
  suggestedQueries: z.array(z.string())
});

const queryAnalysisSchema = z.object({
  sanitizedQuery: z.string().min(1),
  detectedTokens: z.array(z.string()).max(5),
  comparisonRequest: comparisonRequestSchema,
  detectedIntents: z.array(z.string()),
  timeContext: z.enum(['current', '24h', '7d', '30d'] as const).nullable(),
  marketIndicators: z.array(z.string()),
  conceptualIndicators: z.array(z.string()),
  webSearchContext: webSearchContextSchema
});

const marketDataSchema = z.object({
  needed: z.boolean(),
  types: z.array(z.string()),
  timeframe: z.enum(['current', '24h', '7d', '30d'] as const).nullable(),
  tokenCount: z.number().min(0).max(5)
});

const conceptualDataSchema = z.object({
  needed: z.boolean(),
  aspects: z.array(z.string())
});

const dataRequirementsSchema = z.object({
  marketData: marketDataSchema,
  conceptualData: conceptualDataSchema
});

const preprocessingStepSchema = z.object({
  operation: z.string(),
  input: z.string(),
  output: z.string()
});

const queryMetadataSchema = z.object({
  tokens: z.array(z.string()),
  entities: z.array(z.string()),
  contextualHints: z.array(z.string())
});

const originalContextSchema = z.object({
  rawQuery: z.string(),
  timestamp: z.number(),
  preprocessingSteps: z.array(preprocessingStepSchema),
  metadata: queryMetadataSchema
});

const llmResponseSchema = z.object({
  classification: classificationSchema,
  queryAnalysis: queryAnalysisSchema,
  dataRequirements: dataRequirementsSchema
});

const robustAnalysisSchema = z.object({
  originalContext: originalContextSchema,
  classification: classificationSchema,
  queryAnalysis: queryAnalysisSchema,
  dataRequirements: dataRequirementsSchema
});

export function validateLLMResponse(response: string): any {
  try {
    const parsed = JSON.parse(response);
    return llmResponseSchema.parse(parsed);
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new LLMError('Invalid JSON in LLM response', response);
    }
    if (error instanceof z.ZodError) {
      const details = error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');
      throw new LLMError(`Invalid response structure: ${details}`, response);
    }
    throw error;
  }
}

export function validateAnalysis(analysis: unknown): void {
  try {
    robustAnalysisSchema.parse(analysis);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      throw new ValidationError(
        `Invalid analysis: ${firstError.message}`,
        firstError.path.join('.'),
        error
      );
    }
    throw error;
  }
}

================================================================================
File: lib/api-client.ts
================================================================================

import { generateResponse } from './llm';
import { processBlockchainQuery } from './blockchain';

// Client-side API functions
export async function fetchBlockchainData(query: string) {
  try {
    const data = await processBlockchainQuery(query);
    if (!data) {
      throw new Error('No data returned from blockchain query');
    }
    return { data };
  } catch (error) {
    console.error('Blockchain query error:', error);
    throw error;
  }
}

export async function fetchChatResponse(query: string, context: any) {
  try {
    if (!query) {
      throw new Error('Query is required');
    }

    if (!context || !context.data) {
      throw new Error('Context data is required');
    }

    const response = await generateResponse(
      query,
      context.data,
      context.conversationHistory,
      {
        queryType: context.queryType || 'trending',
        temperature: 0.7,
        maxTokens: 500
      }
    );

    return { response };
  } catch (error) {
    console.error('Chat error:', error);
    throw error;
  }
}

================================================================================
File: lib/api/blockchain-api.ts
================================================================================

import { blockchainOrchestrator, BlockchainActionParams, BlockchainActionResult } from '../agents/blockchain-orchestrator';
import { TokenInfo } from '../blockchain/token-registry';
import { DeploymentResult, DeploymentParams } from '../agents/deployment/contract-deployment-agent';
import { TransferResult, TransferParams } from '../agents/transaction/token-transfer-agent';
import { ContractTemplate } from '../agents/deployment/contract-templates';
import { WalletConnectionOptions } from '../blockchain/wallet-integration';

/**
 * Blockchain API Service
 * 
 * This service provides a simplified interface for frontend applications
 * to interact with blockchain functionality.
 */
export class BlockchainApiService {
  /**
   * Connect to wallet
   * @param provider - Wallet provider (metamask, walletconnect, etc.)
   * @returns Connected wallet address
   */
  async connectWallet(provider: string): Promise<string> {
    const walletParams: WalletConnectionOptions = { 
      type: provider as any // Cast to any as a temporary solution
    };
    
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'CONNECT_WALLET',
      walletParams
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to connect wallet');
    }
    
    return result.data.address;
  }
  
  /**
   * Disconnect wallet
   */
  disconnectWallet(): void {
    blockchainOrchestrator.handleAction({
      actionType: 'DISCONNECT_WALLET'
    });
  }
  
  /**
   * Deploy contract
   * @param templateId - Contract template ID
   * @param contractParams - Contract parameters
   * @param options - Deployment options
   * @returns Deployment result
   */
  async deployContract(
    templateId: string,
    contractParams: Record<string, any>,
    options: {
      value?: string;
      gasLimit?: string;
      maxFeePerGas?: string;
      maxPriorityFeePerGas?: string;
    } = {}
  ): Promise<DeploymentResult> {
    const deploymentParams: DeploymentParams = {
      templateId,
      templateParams: contractParams,
      value: options.value,
      gasLimit: options.gasLimit,
      maxFeePerGas: options.maxFeePerGas,
      maxPriorityFeePerGas: options.maxPriorityFeePerGas
    };
    
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'DEPLOY_CONTRACT',
      deploymentParams
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to deploy contract');
    }
    
    return result.data;
  }
  
  /**
   * Transfer tokens
   * @param to - Recipient address
   * @param amount - Amount to transfer
   * @param tokenAddress - Token address (optional, if not provided, transfers ETH)
   * @param options - Transfer options
   * @returns Transfer result
   */
  async transferTokens(
    to: string,
    amount: string,
    tokenAddress?: string,
    options: {
      gasLimit?: string;
      maxFeePerGas?: string;
      maxPriorityFeePerGas?: string;
    } = {}
  ): Promise<TransferResult> {
    const transferParams: TransferParams = {
      to: to as `0x${string}`,
      amount,
      tokenAddress: tokenAddress as `0x${string}` | undefined,
      chainId: 1, // Default to Ethereum mainnet
      gasLimit: options.gasLimit,
      maxFeePerGas: options.maxFeePerGas,
      maxPriorityFeePerGas: options.maxPriorityFeePerGas
    };
    
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'TRANSFER_TOKENS',
      transferParams
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to transfer tokens');
    }
    
    return result.data;
  }
  
  /**
   * Get token information
   * @param tokenAddress - Token address
   * @param chainId - Chain ID
   * @returns Token information
   */
  async getTokenInfo(tokenAddress: string, chainId: number): Promise<TokenInfo> {
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'GET_TOKEN_INFO',
      tokenAddress: tokenAddress as `0x${string}`,
      chainId
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get token info');
    }
    
    return result.data;
  }
  
  /**
   * Get contract templates
   * @param category - Template category (optional)
   * @returns List of contract templates
   */
  async getContractTemplates(category?: string): Promise<ContractTemplate[]> {
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'GET_CONTRACT_TEMPLATES',
      templateCategory: category
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get contract templates');
    }
    
    return result.data;
  }
  
  /**
   * Get deployment status
   * @param transactionHash - Transaction hash
   * @returns Deployment status
   */
  async getDeploymentStatus(transactionHash: string): Promise<DeploymentResult> {
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'GET_DEPLOYMENT_STATUS',
      transactionHash: transactionHash as `0x${string}`
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get deployment status');
    }
    
    return result.data;
  }
  
  /**
   * Get transfer status
   * @param transactionHash - Transaction hash
   * @returns Transfer status
   */
  async getTransferStatus(transactionHash: string): Promise<TransferResult> {
    const result = await blockchainOrchestrator.handleAction({
      actionType: 'GET_TRANSFER_STATUS',
      transactionHash: transactionHash as `0x${string}`
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get transfer status');
    }
    
    return result.data;
  }
  
  /**
   * Execute custom blockchain action
   * @param params - Action parameters
   * @returns Action result
   */
  async executeAction(params: BlockchainActionParams): Promise<BlockchainActionResult> {
    return blockchainOrchestrator.handleAction(params);
  }
}

// Export singleton instance
export const blockchainApi = new BlockchainApiService(); 

================================================================================
File: lib/blockchain.ts
================================================================================

import { getTrendingTokens, getTokenPrices, getTokenDetails } from './token-data';

type ConversationContext = {
  lastQuery?: string;
  lastResults?: any[];
  currentPage: number;
  messages: { role: 'user' | 'assistant'; content: string }[];
};

let conversationContext: ConversationContext = {
  currentPage: 1,
  messages: [],
};

export async function processBlockchainQuery(query: string) {
  if (!query?.trim()) {
    throw new Error('Query is required');
  }

  const lowercaseQuery = query.toLowerCase();
  
  try {
    // Store user message in context
    conversationContext.messages.push({ role: 'user', content: query });
    
    // Determine query type and get relevant data
    let data: any;
    
    if (lowercaseQuery.includes('trending') || lowercaseQuery.includes('popular')) {
      const trendingTokens = await getTrendingTokens();
      if (!trendingTokens?.length) {
        throw new Error('No trending tokens found');
      }

      const tokenIds = trendingTokens.map(trend => trend.item.id);
      const tokenPrices = await getTokenPrices(tokenIds);
      
      data = {
        trending: trendingTokens,
        prices: tokenPrices,
      };
    } else if (lowercaseQuery.includes('price') || 
               lowercaseQuery.includes('bitcoin') || 
               lowercaseQuery.includes('eth')) {
      // Extract token name from query
      const tokenQuery = lowercaseQuery.includes('bitcoin') ? 'bitcoin' :
                        lowercaseQuery.includes('eth') ? 'ethereum' :
                        lowercaseQuery.split(' ').find(word => 
                          !['what', 'is', 'the', 'price', 'of', 'show', 'me', 'tell'].includes(word)
                        );
      
      if (!tokenQuery) {
        throw new Error('Please specify which token you want to check');
      }

      const tokenInfo = await getTokenDetails(tokenQuery);
      if (!tokenInfo) {
        throw new Error(`Could not find information for token "${tokenQuery}"`);
      }

      data = { tokenInfo };
    } else {
      throw new Error('Please ask about trending tokens or specific token prices');
    }

    // Store data in context
    if (data) {
      conversationContext.lastResults = data;
      conversationContext.lastQuery = query;
    }

    return data;
  } catch (error) {
    console.error('Error processing blockchain query:', error);
    throw error;
  }
}

================================================================================
File: lib/blockchain/abis/erc20-abi.ts
================================================================================

// ERC20 ABI
export const erc20Abi = [
  // Read-only functions
  {
    inputs: [],
    name: 'name',
    outputs: [{ type: 'string', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'symbol',
    outputs: [{ type: 'string', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'decimals',
    outputs: [{ type: 'uint8', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'totalSupply',
    outputs: [{ type: 'uint256', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [{ type: 'address', name: 'account' }],
    name: 'balanceOf',
    outputs: [{ type: 'uint256', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'spender' }
    ],
    name: 'allowance',
    outputs: [{ type: 'uint256', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  // Write functions
  {
    inputs: [
      { type: 'address', name: 'recipient' },
      { type: 'uint256', name: 'amount' }
    ],
    name: 'transfer',
    outputs: [{ type: 'bool', name: '' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      { type: 'address', name: 'sender' },
      { type: 'address', name: 'recipient' },
      { type: 'uint256', name: 'amount' }
    ],
    name: 'transferFrom',
    outputs: [{ type: 'bool', name: '' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      { type: 'address', name: 'spender' },
      { type: 'uint256', name: 'amount' }
    ],
    name: 'approve',
    outputs: [{ type: 'bool', name: '' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  // Events
  {
    anonymous: false,
    inputs: [
      { indexed: true, type: 'address', name: 'from' },
      { indexed: true, type: 'address', name: 'to' },
      { indexed: false, type: 'uint256', name: 'value' }
    ],
    name: 'Transfer',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, type: 'address', name: 'owner' },
      { indexed: true, type: 'address', name: 'spender' },
      { indexed: false, type: 'uint256', name: 'value' }
    ],
    name: 'Approval',
    type: 'event'
  }
] as const; 

================================================================================
File: lib/blockchain/providers.ts
================================================================================

import { createPublicClient, http } from 'viem';
import { mainnet, sepolia, arbitrum, optimism, polygon } from 'viem/chains';

// Get the RPC URL from environment variables or use default
const getRpcUrl = (network: string): string => {
  const envVar = `${network.toUpperCase()}_RPC_URL`;
  return process.env[envVar] || getDefaultRpcUrl(network);
};

// Default public RPC URLs (consider using your own for production)
const getDefaultRpcUrl = (network: string): string => {
  switch (network) {
    case 'mainnet': return 'https://eth-mainnet.g.alchemy.com/v2/demo';
    case 'sepolia': return 'https://eth-sepolia.g.alchemy.com/v2/demo';
    case 'arbitrum': return 'https://arb-mainnet.g.alchemy.com/v2/demo';
    case 'optimism': return 'https://opt-mainnet.g.alchemy.com/v2/demo';
    case 'polygon': return 'https://polygon-mainnet.g.alchemy.com/v2/demo';
    default: return 'https://eth-mainnet.g.alchemy.com/v2/demo';
  }
};

// Create public clients for different chains
export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(getRpcUrl('mainnet'))
});

export const sepoliaClient = createPublicClient({
  chain: sepolia,
  transport: http(getRpcUrl('sepolia'))
});

export const arbitrumClient = createPublicClient({
  chain: arbitrum,
  transport: http(getRpcUrl('arbitrum'))
});

export const polygonClient = createPublicClient({
  chain: polygon,
  transport: http(getRpcUrl('polygon'))
});

export const getClientForChain = (chainId: number) => {
  switch (chainId) {
    case 1: return publicClient;
    case 11155111: return sepoliaClient;
    case 42161: return arbitrumClient;
    case 137: return polygonClient;
    default: return publicClient;
  }
}; 

================================================================================
File: lib/blockchain/token-registry.ts
================================================================================

import { createPublicClient, http, getContract, PublicClient } from 'viem';
import { mainnet, sepolia, optimism, arbitrum } from 'viem/chains';
import { erc20Abi } from './abis/erc20-abi';
import { walletService, TransactionOptions } from './wallet-integration';
import { parseAbi, encodeFunctionData } from 'viem';

// Token information interface
export interface TokenInfo {
  address: `0x${string}`;
  chainId: number;
  name: string;
  symbol: string;
  decimals: number;
  logoURI?: string;
  isVerified?: boolean;
}

// Chain configuration
interface ChainConfig {
  chainId: number;
  client: PublicClient;
}

// Common ERC20 ABI functions
const ERC20_ABI = parseAbi([
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address owner) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function transfer(address to, uint256 value) returns (bool)',
  'function approve(address spender, uint256 value) returns (bool)',
  'function transferFrom(address from, address to, uint256 value) returns (bool)'
]);

export class TokenRegistry {
  private tokens: Map<string, TokenInfo> = new Map();
  private chains: Map<number, ChainConfig> = new Map();
  
  constructor() {
    // Initialize supported chains
    this.initializeChains();
  }
  
  private initializeChains(): void {
    // Mainnet
    this.chains.set(1, {
      chainId: 1,
      client: createPublicClient({
        chain: mainnet,
        transport: http()
      })
    });
    
    // Sepolia (Ethereum testnet)
    this.chains.set(11155111, {
      chainId: 11155111,
      client: createPublicClient({
        chain: sepolia,
        transport: http()
      })
    });
    
    // Optimism
    this.chains.set(10, {
      chainId: 10,
      client: createPublicClient({
        chain: optimism,
        transport: http()
      })
    });
    
    // Arbitrum
    this.chains.set(42161, {
      chainId: 42161,
      client: createPublicClient({
        chain: arbitrum,
        transport: http()
      })
    });
  }
  
  // Get token key (chainId + address)
  private getTokenKey(address: `0x${string}`, chainId: number): string {
    return `${chainId}-${address.toLowerCase()}`;
  }
  
  // Add token to registry
  addToken(token: TokenInfo): void {
    const key = this.getTokenKey(token.address, token.chainId);
    this.tokens.set(key, token);
  }
  
  // Get token from registry
  getToken(address: `0x${string}`, chainId: number): TokenInfo | undefined {
    const key = this.getTokenKey(address, chainId);
    return this.tokens.get(key);
  }
  
  // Load token info from blockchain
  async loadTokenInfo(address: `0x${string}`, chainId: number): Promise<TokenInfo> {
    // Check if chain is supported
    const chainConfig = this.chains.get(chainId);
    if (!chainConfig) {
      throw new Error(`Chain ID ${chainId} is not supported`);
    }
    
    try {
      // Create contract instance
      const contract = getContract({
        address,
        abi: erc20Abi,
        publicClient: chainConfig.client
      });
      
      // Get token info
      const [name, symbol, decimals] = await Promise.all([
        contract.read.name(),
        contract.read.symbol(),
        contract.read.decimals()
      ]);
      
      // Create token info
      const tokenInfo: TokenInfo = {
        address,
        chainId,
        name: name as string,
        symbol: symbol as string,
        decimals: Number(decimals),
        isVerified: false
      };
      
      // Add to registry
      this.addToken(tokenInfo);
      
      return tokenInfo;
    } catch (error) {
      console.error('Error loading token info:', error);
      throw new Error(`Failed to load token info for ${address} on chain ${chainId}`);
    }
  }
  
  // Get all tokens
  getAllTokens(): TokenInfo[] {
    return Array.from(this.tokens.values());
  }
  
  // Get tokens by chain
  getTokensByChain(chainId: number): TokenInfo[] {
    return this.getAllTokens().filter(token => token.chainId === chainId);
  }
  
  // Check if token exists
  hasToken(address: `0x${string}`, chainId: number): boolean {
    const key = this.getTokenKey(address, chainId);
    return this.tokens.has(key);
  }
  
  // Remove token from registry
  removeToken(address: `0x${string}`, chainId: number): boolean {
    const key = this.getTokenKey(address, chainId);
    return this.tokens.delete(key);
  }
  
  // Clear registry
  clearRegistry(): void {
    this.tokens.clear();
  }
  
  // Get token balance
  async getBalance(tokenAddress: `0x${string}`, ownerAddress: `0x${string}`, chainId: number): Promise<bigint> {
    const chainConfig = this.chains.get(chainId);
    if (!chainConfig) {
      throw new Error(`Chain ID ${chainId} is not supported`);
    }
    
    const balance = await chainConfig.client.readContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: 'balanceOf',
      args: [ownerAddress]
    });
    
    return balance as bigint;
  }
  
  // Transfer tokens
  async transfer(
    tokenAddress: `0x${string}`, 
    to: `0x${string}`, 
    amount: bigint, 
    chainId: number
  ): Promise<`0x${string}`> {
    if (!walletService.isConnected()) {
      throw new Error('Wallet not connected');
    }
    
    // Encode the transfer function call
    const data = encodeFunctionData({
      abi: ERC20_ABI,
      functionName: 'transfer',
      args: [to, amount]
    });
    
    // Create transaction options
    const txOptions: TransactionOptions = {
      to: tokenAddress,
      data,
      value: 0n
    };
    
    // Send the transaction
    return walletService.sendTransaction(txOptions);
  }
  
  // Approve token spending
  async approve(
    tokenAddress: `0x${string}`, 
    spender: `0x${string}`, 
    amount: bigint, 
    chainId: number
  ): Promise<`0x${string}`> {
    if (!walletService.isConnected()) {
      throw new Error('Wallet not connected');
    }
    
    // Encode the approve function call
    const data = encodeFunctionData({
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [spender, amount]
    });
    
    // Create transaction options
    const txOptions: TransactionOptions = {
      to: tokenAddress,
      data,
      value: 0n
    };
    
    // Send the transaction
    return walletService.sendTransaction(txOptions);
  }
  
  // Get token allowance
  async getAllowance(
    tokenAddress: `0x${string}`,
    ownerAddress: `0x${string}`,
    spenderAddress: `0x${string}`,
    chainId: number
  ): Promise<bigint> {
    const chainConfig = this.chains.get(chainId);
    if (!chainConfig) {
      throw new Error(`Chain ID ${chainId} is not supported`);
    }
    
    const allowance = await chainConfig.client.readContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: 'allowance',
      args: [ownerAddress, spenderAddress]
    });
    
    return allowance as bigint;
  }
}

// Export singleton instance
export const tokenRegistry = new TokenRegistry();

// Common tokens
const COMMON_TOKENS: TokenInfo[] = [
  {
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' as `0x${string}`,
    name: 'Wrapped Ether',
    symbol: 'WETH',
    decimals: 18,
    chainId: 1,
    logoURI: 'https://assets.coingecko.com/coins/images/2518/thumb/weth.png'
  },
  {
    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' as `0x${string}`,
    name: 'USD Coin',
    symbol: 'USDC',
    decimals: 6,
    chainId: 1,
    logoURI: 'https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png'
  },
  {
    address: '0xdAC17F958D2ee523a2206206994597C13D831ec7' as `0x${string}`,
    name: 'Tether',
    symbol: 'USDT',
    decimals: 6,
    chainId: 1,
    logoURI: 'https://assets.coingecko.com/coins/images/325/thumb/Tether.png'
  }
];

// Initialize common tokens
COMMON_TOKENS.forEach(token => tokenRegistry.addToken(token)); 

================================================================================
File: lib/blockchain/wallet-integration.ts
================================================================================

import { createWalletClient, http, custom, parseEther, parseGwei } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet, sepolia, arbitrum } from 'viem/chains';
import { publicClient } from './providers';

// Supported wallet types
export type WalletType = 'metamask' | 'walletconnect' | 'private-key' | 'hardware';

// Wallet connection options
export interface WalletConnectionOptions {
  type: WalletType;
  chainId?: number;
  privateKey?: string;
  rpcUrl?: string;
}

// Transaction options 
export interface TransactionOptions {
  to: `0x${string}`;
  value?: bigint;
  data?: `0x${string}`;
  gasLimit?: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
  nonce?: number;
}

export class WalletIntegrationService {
  private walletClient: any = null;
  private connectedChainId: number | null = null;
  private connectedAddress: `0x${string}` | null = null;
  private pendingTransactions = new Map<string, any>();

  // Connect to a wallet
  async connect(options: WalletConnectionOptions): Promise<`0x${string}`> {
    try {
      const chainId = options.chainId || 1; // Default to Ethereum mainnet
      let chain;
      
      // Determine the chain
      switch (chainId) {
        case 1:
          chain = mainnet;
          break;
        case 11155111:
          chain = sepolia;
          break;
        case 42161:
          chain = arbitrum;
          break;
        default:
          throw new Error(`Chain ID ${chainId} not supported`);
      }

      // Connect based on wallet type
      switch (options.type) {
        case 'metamask':
          if (typeof window === 'undefined' || !window.ethereum) {
            throw new Error('MetaMask not detected in browser');
          }
          
          this.walletClient = createWalletClient({
            chain,
            transport: custom(window.ethereum)
          });
          
          // Request accounts
          const accounts = await this.walletClient.requestAddresses();
          if (!accounts || accounts.length === 0) {
            throw new Error('No accounts found in MetaMask');
          }
          
          this.connectedAddress = accounts[0];
          break;
          
        case 'private-key':
          if (!options.privateKey) {
            throw new Error('Private key is required');
          }
          
          // Create account from private key
          const account = privateKeyToAccount(options.privateKey as `0x${string}`);
          
          this.walletClient = createWalletClient({
            account,
            chain,
            transport: http(options.rpcUrl || 'https://eth-mainnet.g.alchemy.com/v2/demo')
          });
          
          this.connectedAddress = account.address;
          break;
          
        case 'walletconnect':
          throw new Error('WalletConnect integration not implemented yet');
          
        case 'hardware':
          throw new Error('Hardware wallet integration not implemented yet');
          
        default:
          throw new Error(`Wallet type ${options.type} not supported`);
      }

      this.connectedChainId = chainId;
      
      console.log(`Wallet connected: ${this.connectedAddress} on chain ${chainId}`);
      return this.connectedAddress;
      
    } catch (error) {
      console.error('Wallet connection error:', error);
      throw new Error(`Failed to connect wallet: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Check if wallet is connected
  isConnected(): boolean {
    return this.walletClient !== null && this.connectedAddress !== null;
  }

  // Get connected address
  getAddress(): `0x${string}` {
    if (!this.isConnected()) {
      throw new Error('Wallet not connected');
    }
    return this.connectedAddress!;
  }

  // Send a transaction
  async sendTransaction(options: TransactionOptions): Promise<`0x${string}`> {
    if (!this.isConnected()) {
      throw new Error('Wallet not connected');
    }

    try {
      // If gas parameters aren't provided, estimate them
      if (!options.maxFeePerGas || !options.maxPriorityFeePerGas) {
        const feeData = await publicClient.estimateFeesPerGas();
        options.maxFeePerGas = options.maxFeePerGas || feeData.maxFeePerGas;
        options.maxPriorityFeePerGas = options.maxPriorityFeePerGas || feeData.maxPriorityFeePerGas;
      }

      // If gas limit isn't provided, estimate it
      if (!options.gasLimit) {
        const gasLimit = await publicClient.estimateGas({
          account: this.connectedAddress!,
          to: options.to,
          value: options.value || 0n,
          data: options.data
        });
        
        // Add a 20% buffer to the gas limit to be safe
        options.gasLimit = (gasLimit * 120n) / 100n;
      }

      // If nonce isn't provided, get the next nonce
      if (options.nonce === undefined) {
        options.nonce = await publicClient.getTransactionCount({
          address: this.connectedAddress!
        });
      }

      // Send the transaction
      const hash = await this.walletClient.sendTransaction({
        account: this.walletClient.account || this.connectedAddress!,
        to: options.to,
        value: options.value || 0n,
        data: options.data,
        gasLimit: options.gasLimit,
        maxFeePerGas: options.maxFeePerGas,
        maxPriorityFeePerGas: options.maxPriorityFeePerGas,
        nonce: options.nonce
      });

      // Store the pending transaction
      this.pendingTransactions.set(hash, {
        ...options,
        hash,
        timestamp: Date.now(),
        status: 'pending'
      });

      return hash;
    } catch (error) {
      console.error('Transaction error:', error);
      throw new Error(`Failed to send transaction: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Wait for transaction confirmation
  async waitForTransaction(hash: `0x${string}`, confirmations = 1): Promise<any> {
    try {
      const receipt = await publicClient.waitForTransactionReceipt({
        hash,
        confirmations
      });

      // Update the transaction status
      if (this.pendingTransactions.has(hash)) {
        const tx = this.pendingTransactions.get(hash);
        this.pendingTransactions.set(hash, {
          ...tx,
          status: receipt.status === 'success' ? 'confirmed' : 'failed',
          receipt
        });
      }

      return receipt;
    } catch (error) {
      console.error('Transaction confirmation error:', error);
      
      // Update the transaction status to failed
      if (this.pendingTransactions.has(hash)) {
        const tx = this.pendingTransactions.get(hash);
        this.pendingTransactions.set(hash, {
          ...tx,
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
      
      throw error;
    }
  }

  // Get pending transactions
  getPendingTransactions(): any[] {
    return Array.from(this.pendingTransactions.values()).filter(tx => tx.status === 'pending');
  }

  // Get transaction by hash
  getTransaction(hash: `0x${string}`): any {
    return this.pendingTransactions.get(hash);
  }

  // Disconnect wallet
  disconnect(): void {
    this.walletClient = null;
    this.connectedAddress = null;
    this.connectedChainId = null;
    console.log('Wallet disconnected');
  }

  // Helper function to convert ETH string to wei BigInt
  static parseEther(amount: string): bigint {
    return parseEther(amount);
  }

  // Helper function to convert Gwei string to wei BigInt
  static parseGwei(amount: string): bigint {
    return parseGwei(amount);
  }
}

// Export singleton instance
export const walletService = new WalletIntegrationService(); 

================================================================================
File: lib/conversation-store.ts
================================================================================

import { v4 as uuidv4 } from 'uuid';
import { IntentType } from './agents/types';

export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  metadata?: {
    tokens?: string[];
    intent?: IntentType;
    confidence?: number;
    topics?: string[];
    entities?: string[];
    contextualHints?: string[];
    followUp?: boolean;
    referenceMessageId?: string;
    contextConfidence?: number;
  };
  id: string;
}

export interface TopicMetadata {
  name: string;
  frequency: number;
  lastMentioned: number;
  relatedTokens: string[];
  confidence: number;
}

export interface UserPreferences {
  favoriteTokens: Map<string, number>; // token -> frequency
  preferredTimeframes: Set<string>;
  interests: Set<string>;
  technicalLevel: 'basic' | 'intermediate' | 'advanced';
  lastUpdated: number;
}

export interface ConversationMetadata {
  lastActive: number;
  messageCount: number;
  topics: Map<string, TopicMetadata>;
  userPreferences: UserPreferences;
  continuityScore: number; // Measure of conversation coherence
}

export class ConversationStore {
  private static conversations = new Map<string, ChatMessage[]>();
  private static metadata = new Map<string, ConversationMetadata>();
  private static readonly MAX_MESSAGES = 50; // Increased from 20
  private static readonly EXPIRY_TIME = 24 * 60 * 60 * 1000; // Extended to 24 hours
  private static readonly TOPIC_RELEVANCE_DECAY = 0.8; // Topic relevance decay factor

  static getMessages(sessionId: string): ChatMessage[] {
    this.cleanExpiredSessions();
    return this.conversations.get(sessionId) || [];
  }

  static addMessage(sessionId: string, message: Omit<ChatMessage, 'id'>): void {
    const convo = this.getMessages(sessionId);
    const messageWithId: ChatMessage = {
      ...message,
      id: uuidv4(),
      timestamp: message.timestamp || Date.now()
    };

    convo.push(messageWithId);

    // Update metadata
    const metadata = this.getMetadata(sessionId);
    metadata.lastActive = Date.now();
    metadata.messageCount++;

    // Update topic metadata
    if (message.metadata?.intent) {
      this.updateTopicMetadata(metadata, message);
    }

    // Update user preferences
    if (message.metadata?.tokens) {
      this.updateUserPreferences(metadata, message);
    }

    // Calculate conversation continuity
    this.updateContinuityScore(metadata, convo);

    this.metadata.set(sessionId, metadata);
    this.truncate(sessionId);
    this.conversations.set(sessionId, convo);
  }

  private static updateTopicMetadata(metadata: ConversationMetadata, message: Omit<ChatMessage, 'id'>): void {
    const { intent, tokens = [], confidence = 0 } = message.metadata!;
    const topics = metadata.topics;
    
    if (!topics.has(intent!)) {
      topics.set(intent!, {
        name: intent!,
        frequency: 1,
        lastMentioned: message.timestamp,
        relatedTokens: tokens,
        confidence
      });
    } else {
      const topic = topics.get(intent!)!;
      topic.frequency++;
      topic.lastMentioned = message.timestamp;
      topic.relatedTokens = Array.from(new Set([...topic.relatedTokens, ...tokens]));
      topic.confidence = Math.max(topic.confidence, confidence);
    }
  }

  private static updateUserPreferences(metadata: ConversationMetadata, message: Omit<ChatMessage, 'id'>): void {
    const { tokens = [], contextualHints = [] } = message.metadata!;
    const prefs = metadata.userPreferences;

    // Update token frequencies
    tokens.forEach(token => {
      prefs.favoriteTokens.set(token, (prefs.favoriteTokens.get(token) || 0) + 1);
    });

    // Update interests based on contextual hints
    contextualHints.forEach(hint => prefs.interests.add(hint));

    // Infer technical level
    if (contextualHints.includes('TECHNICAL') || contextualHints.includes('CODE')) {
      prefs.technicalLevel = 'advanced';
    } else if (contextualHints.includes('INTERMEDIATE')) {
      prefs.technicalLevel = 'intermediate';
    }

    prefs.lastUpdated = message.timestamp;
  }

  private static updateContinuityScore(metadata: ConversationMetadata, messages: ChatMessage[]): void {
    if (messages.length < 2) {
      metadata.continuityScore = 1;
      return;
    }

    // Calculate continuity based on:
    // 1. Time between messages
    // 2. Topic consistency
    // 3. Token overlap
    let totalScore = 0;
    for (let i = 1; i < messages.length; i++) {
      const current = messages[i];
      const previous = messages[i - 1];
      
      // Time factor (decay over time)
      const timeDiff = current.timestamp - previous.timestamp;
      const timeFactor = Math.exp(-timeDiff / (30 * 60 * 1000)); // 30 minute half-life

      // Topic consistency
      const topicFactor = current.metadata?.intent === previous.metadata?.intent ? 1 : 0.5;

      // Token overlap
      const currentTokens = new Set(current.metadata?.tokens || []);
      const previousTokens = new Set(previous.metadata?.tokens || []);
      const overlap = new Set([...currentTokens].filter(x => previousTokens.has(x)));
      const tokenFactor = overlap.size > 0 ? 1 : 0.7;

      totalScore += (timeFactor + topicFactor + tokenFactor) / 3;
    }

    metadata.continuityScore = totalScore / (messages.length - 1);
  }

  static truncate(sessionId: string, maxMessages = this.MAX_MESSAGES): void {
    const convo = this.getMessages(sessionId);
    if (convo.length > maxMessages) {
      // Keep system messages and recent messages
      const systemMessages = convo.filter(m => m.role === 'system');
      const recentMessages = convo.slice(-maxMessages + systemMessages.length);
      const truncated = [...systemMessages, ...recentMessages];
      
      this.conversations.set(sessionId, truncated);
      
      // Update metadata
      const metadata = this.getMetadata(sessionId);
      metadata.messageCount = truncated.length;
      this.metadata.set(sessionId, metadata);
    }
  }

  static getMetadata(sessionId: string): ConversationMetadata {
    if (!this.metadata.has(sessionId)) {
      this.metadata.set(sessionId, {
        lastActive: Date.now(),
        messageCount: 0,
        topics: new Map(),
        userPreferences: {
          favoriteTokens: new Map(),
          preferredTimeframes: new Set(),
          interests: new Set(),
          technicalLevel: 'basic',
          lastUpdated: Date.now()
        },
        continuityScore: 1
      });
    }
    return this.metadata.get(sessionId)!;
  }

  static createSession(): string {
    const sessionId = uuidv4();
    this.conversations.set(sessionId, []);
    this.metadata.set(sessionId, this.getMetadata(sessionId));
    return sessionId;
  }

  static cleanExpiredSessions(): void {
    const now = Date.now();
    for (const [sessionId, metadata] of this.metadata.entries()) {
      if (now - metadata.lastActive > this.EXPIRY_TIME) {
        this.conversations.delete(sessionId);
        this.metadata.delete(sessionId);
      }
    }
  }

  static getRecentContext(sessionId: string, maxMessages = 5): ChatMessage[] {
    const messages = this.getMessages(sessionId);
    const metadata = this.getMetadata(sessionId);
    
    // Apply topic relevance decay
    const now = Date.now();
    metadata.topics.forEach((topic, key) => {
      const age = (now - topic.lastMentioned) / (60 * 60 * 1000); // Hours
      const relevance = Math.pow(this.TOPIC_RELEVANCE_DECAY, age);
      if (relevance < 0.1) {
        metadata.topics.delete(key);
      }
    });

    // Get messages with high continuity
    return messages
      .slice(-maxMessages)
      .filter(msg => {
        // Keep messages that:
        // 1. Are recent (< 1 hour old)
        // 2. Share topics with current conversation
        // 3. Have overlapping tokens with recent messages
        const age = (now - msg.timestamp) / (60 * 60 * 1000);
        if (age < 1) return true;
        
        const hasRelevantTopic = msg.metadata?.intent && 
          metadata.topics.has(msg.metadata.intent);
        
        const hasTokenOverlap = msg.metadata?.tokens?.some(token => 
          metadata.userPreferences.favoriteTokens.has(token));
        
        return hasRelevantTopic || hasTokenOverlap;
      });
  }

  static getTopics(sessionId: string): TopicMetadata[] {
    const metadata = this.getMetadata(sessionId);
    return Array.from(metadata.topics.values())
      .sort((a, b) => b.lastMentioned - a.lastMentioned);
  }

  static getUserPreferences(sessionId: string): UserPreferences {
    return this.getMetadata(sessionId).userPreferences;
  }

  static getFavoriteTokens(sessionId: string, limit = 5): string[] {
    const prefs = this.getUserPreferences(sessionId);
    return Array.from(prefs.favoriteTokens.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([token]) => token);
  }

  static getConversationSummary(sessionId: string): {
    messageCount: number;
    continuityScore: number;
    dominantTopics: string[];
    userLevel: string;
    favoriteTokens: string[];
  } {
    const metadata = this.getMetadata(sessionId);
    const topics = Array.from(metadata.topics.values())
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 3)
      .map(t => t.name);

    return {
      messageCount: metadata.messageCount,
      continuityScore: metadata.continuityScore,
      dominantTopics: topics,
      userLevel: metadata.userPreferences.technicalLevel,
      favoriteTokens: this.getFavoriteTokens(sessionId)
    };
  }
}

================================================================================
File: lib/conversation/context-builder.ts
================================================================================

import { ChatMessage, ConversationStore } from '../conversation-store';
import { RobustAnalysis, IntentType } from '../agents/types';

export interface EnhancedContext {
  recentMessages: ChatMessage[];
  userPreferences: {
    favoriteTokens: string[];
    technicalLevel: string;
    interests: string[];
  };
  conversationMetrics: {
    continuityScore: number;
    dominantTopics: string[];
    messageCount: number;
  };
  currentQuery: {
    analysis: RobustAnalysis;
    relatedTopics: string[];
    detectedTokens: string[];
  };
}

export function buildEnhancedContext(
  sessionId: string,
  currentAnalysis: RobustAnalysis,
  maxMessages = 5
): EnhancedContext {
  // Get conversation summary
  const summary = ConversationStore.getConversationSummary(sessionId);
  const recentMessages = ConversationStore.getRecentContext(sessionId, maxMessages);
  const prefs = ConversationStore.getUserPreferences(sessionId);

  // Find related topics from history
  const relatedTopics = ConversationStore.getTopics(sessionId)
    .filter(topic => {
      // Topic is related if it:
      // 1. Shares tokens with current query
      // 2. Has the same intent
      // 3. Was recently discussed
      const hasSharedTokens = topic.relatedTokens.some(token => 
        currentAnalysis.queryAnalysis.detectedTokens.includes(token)
      );
      
      const hasSameIntent = topic.name === currentAnalysis.classification.primaryIntent;
      
      const isRecent = (Date.now() - topic.lastMentioned) < (30 * 60 * 1000); // 30 minutes
      
      return hasSharedTokens || hasSameIntent || isRecent;
    })
    .map(topic => topic.name);

  return {
    recentMessages,
    userPreferences: {
      favoriteTokens: Array.from(prefs.favoriteTokens.keys()),
      technicalLevel: prefs.technicalLevel,
      interests: Array.from(prefs.interests)
    },
    conversationMetrics: {
      continuityScore: summary.continuityScore,
      dominantTopics: summary.dominantTopics,
      messageCount: summary.messageCount
    },
    currentQuery: {
      analysis: currentAnalysis,
      relatedTopics,
      detectedTokens: currentAnalysis.queryAnalysis.detectedTokens
    }
  };
}

export function formatContextForPrompt(context: EnhancedContext): string {
  const sections: string[] = [];

  // Format conversation history
  if (context.recentMessages.length > 0) {
    sections.push('Recent Conversation:\n' + context.recentMessages
      .map(msg => {
        const tokens = msg.metadata?.tokens?.join(', ') || '';
        const intent = msg.metadata?.intent || '';
        return `${msg.role.toUpperCase()}: ${msg.content}\n[tokens: ${tokens}, intent: ${intent}]`;
      })
      .join('\n\n')
    );
  }

  // Format user preferences
  sections.push('User Context:\n' + JSON.stringify({
    technicalLevel: context.userPreferences.technicalLevel,
    interests: context.userPreferences.interests,
    favoriteTokens: context.userPreferences.favoriteTokens
  }, null, 2));

  // Format conversation metrics
  sections.push('Conversation Metrics:\n' + JSON.stringify({
    messageCount: context.conversationMetrics.messageCount,
    continuityScore: context.conversationMetrics.continuityScore.toFixed(2),
    dominantTopics: context.conversationMetrics.dominantTopics
  }, null, 2));

  // Format current query information
  sections.push('Current Query Context:\n' + JSON.stringify({
    intent: context.currentQuery.analysis.classification.primaryIntent,
    confidence: context.currentQuery.analysis.classification.confidence.toFixed(2),
    detectedTokens: context.currentQuery.detectedTokens,
    relatedTopics: context.currentQuery.relatedTopics,
    timeContext: context.currentQuery.analysis.queryAnalysis.timeContext,
    marketIndicators: context.currentQuery.analysis.queryAnalysis.marketIndicators,
    conceptualIndicators: context.currentQuery.analysis.queryAnalysis.conceptualIndicators
  }, null, 2));

  return sections.join('\n\n');
}

export function analyzeContextContinuity(context: EnhancedContext): {
  isCoherent: boolean;
  confidence: number;
  suggestedFollowUp?: string;
} {
  const continuityScore = context.conversationMetrics.continuityScore;
  const currentIntent = context.currentQuery.analysis.classification.primaryIntent;
  const recentIntents = context.recentMessages
    .filter(msg => msg.metadata?.intent)
    .map(msg => msg.metadata!.intent);

  // Check if current query follows conversation flow
  const isRelatedToRecent = recentIntents.includes(currentIntent) ||
    context.currentQuery.relatedTopics.some(topic => 
      recentIntents.includes(topic as IntentType)
    );

  // Calculate confidence based on multiple factors
  const intentConfidence = context.currentQuery.analysis.classification.confidence;
  const topicRelevance = isRelatedToRecent ? 1 : 0.5;
  const overallConfidence = (continuityScore * 0.3 + intentConfidence * 0.4 + topicRelevance * 0.3);

  // Generate follow-up suggestion if conversation seems disconnected
  let suggestedFollowUp: string | undefined;
  if (!isRelatedToRecent && context.recentMessages.length > 0) {
    const lastTopic = recentIntents[recentIntents.length - 1];
    suggestedFollowUp = `Would you like to know how this relates to our previous discussion about ${lastTopic?.toLowerCase()}?`;
  }

  return {
    isCoherent: continuityScore > 0.7 && isRelatedToRecent,
    confidence: overallConfidence,
    suggestedFollowUp
  };
}

export function predictNextTopics(context: EnhancedContext): string[] {
  const currentIntent = context.currentQuery.analysis.classification.primaryIntent;
  const suggestions: string[] = [];

  // Add suggestions based on current intent
  switch (currentIntent) {
    case 'MARKET_DATA':
      suggestions.push(
        'price trends',
        'market comparison',
        'volume analysis'
      );
      break;
    case 'TECHNICAL':
      suggestions.push(
        'security implications',
        'implementation details',
        'best practices'
      );
      break;
    case 'DEFI':
      suggestions.push(
        'yield strategies',
        'liquidity analysis',
        'protocol comparison'
      );
      break;
    case 'REGULATORY':
      suggestions.push(
        'compliance requirements',
        'jurisdictional analysis',
        'risk assessment'
      );
      break;
    case 'SECURITY':
      suggestions.push(
        'audit findings',
        'security measures',
        'risk mitigation'
      );
      break;
    case 'NEWS_EVENTS':
      suggestions.push(
        'market impact',
        'related developments',
        'future implications'
      );
      break;
    default:
      suggestions.push(
        'market overview',
        'technical details',
        'latest updates'
      );
  }

  // Add suggestions based on user preferences
  if (context.userPreferences.technicalLevel === 'advanced') {
    suggestions.push(
      'technical deep dive',
      'architecture analysis',
      'security audit'
    );
  }

  // Add token-specific suggestions
  context.userPreferences.favoriteTokens.slice(0, 2).forEach(token => {
    suggestions.push(`${token} analysis`, `${token} performance`);
  });

  // Return top 5 unique suggestions
  return Array.from(new Set(suggestions)).slice(0, 5);
}

================================================================================
File: lib/conversation/context.ts
================================================================================

import { ChatMessage } from '../conversation-store';

export interface ConversationContext {
  recentMessages: ChatMessage[];
  topics: string[];
  userPreferences?: {
    favoriteTokens?: string[];
    preferredTimeframes?: string[];
  };
}

export function buildContext(messages: ChatMessage[]): ConversationContext {
  const topics = new Set<string>();
  const favoriteTokens = new Set<string>();
  const preferredTimeframes = new Set<string>();

  messages.forEach(msg => {
    if (msg.metadata?.intent) {
      topics.add(msg.metadata.intent);
    }
    if (msg.metadata?.tokens) {
      msg.metadata.tokens.forEach(token => favoriteTokens.add(token));
    }
  });

  return {
    recentMessages: messages.slice(-5),
    topics: Array.from(topics),
    userPreferences: {
      favoriteTokens: Array.from(favoriteTokens),
      preferredTimeframes: Array.from(preferredTimeframes)
    }
  };
}

================================================================================
File: lib/conversation/manager.ts
================================================================================

import { ConversationContext, ConversationMemory, ConversationTopic } from '@/lib/types/conversation';
import { RobustAnalysis } from '@/lib/agents/types';

export class ConversationManager {
  private contexts: Map<string, ConversationContext>;
  private readonly MAX_TOPICS = 5;
  private readonly MAX_MESSAGES = 10;
  private readonly CONTEXT_EXPIRY = 30 * 60 * 1000; // 30 minutes

  constructor() {
    this.contexts = new Map();
    // Set up periodic cleanup
    setInterval(() => this.cleanupExpiredContexts(), 5 * 60 * 1000); // Every 5 minutes
  }

  private initializeContext(sessionId: string): ConversationContext {
    return {
      sessionId,
      memory: {
        topics: [],
        userPreferences: {},
        lastInteraction: Date.now()
      },
      recentMessages: [],
    };
  }

  getContext(sessionId: string): ConversationContext {
    let context = this.contexts.get(sessionId);
    
    if (!context) {
      context = this.initializeContext(sessionId);
      this.contexts.set(sessionId, context);
    }

    // Update last interaction time
    context.memory.lastInteraction = Date.now();
    return context;
  }

  updateContext(sessionId: string, analysis: RobustAnalysis, response: string): void {
    const context = this.getContext(sessionId);
    
    // Update messages
    context.recentMessages.push({
      role: 'user',
      content: analysis.originalContext.rawQuery,
      timestamp: Date.now()
    });
    context.recentMessages.push({
      role: 'assistant',
      content: response,
      timestamp: Date.now()
    });

    // Trim messages to keep only recent ones
    if (context.recentMessages.length > this.MAX_MESSAGES) {
      context.recentMessages = context.recentMessages.slice(-this.MAX_MESSAGES);
    }

    // Update topics based on analysis
    this.updateTopics(context, analysis);

    // Update user preferences if detected
    this.updateUserPreferences(context, analysis);

    // Set current topic
    context.currentTopic = analysis.classification.primaryIntent;

    this.contexts.set(sessionId, context);
  }

  private updateTopics(context: ConversationContext, analysis: RobustAnalysis): void {
    const newTopic: ConversationTopic = {
      name: analysis.classification.primaryIntent,
      confidence: analysis.classification.confidence,
      lastDiscussed: Date.now(),
      relatedTokens: analysis.queryAnalysis.detectedTokens
    };

    const existingTopicIndex = context.memory.topics.findIndex(
      t => t.name === newTopic.name
    );

    if (existingTopicIndex !== -1) {
      // Update existing topic
      context.memory.topics[existingTopicIndex] = {
        ...context.memory.topics[existingTopicIndex],
        lastDiscussed: Date.now(),
        confidence: Math.max(
          context.memory.topics[existingTopicIndex].confidence,
          newTopic.confidence
        ),
        relatedTokens: Array.from(new Set([
          ...context.memory.topics[existingTopicIndex].relatedTokens,
          ...newTopic.relatedTokens
        ]))
      };
    } else {
      // Add new topic
      context.memory.topics.push(newTopic);
    }

    // Keep only recent topics, sorted by last discussed
    context.memory.topics = context.memory.topics
      .sort((a, b) => b.lastDiscussed - a.lastDiscussed)
      .slice(0, this.MAX_TOPICS);
  }

  private updateUserPreferences(context: ConversationContext, analysis: RobustAnalysis): void {
    const prefs = context.memory.userPreferences;

    // Update favorite tokens
    if (analysis.queryAnalysis.detectedTokens.length > 0) {
      const tokenFrequency = new Map<string, number>();
      
      // Count token frequency
      analysis.queryAnalysis.detectedTokens.forEach(token => {
        tokenFrequency.set(token, (tokenFrequency.get(token) || 0) + 1);
      });

      // Update favorites based on frequency
      prefs.favoriteTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([token]) => token)
        .slice(0, 5);
    }

    // Update risk tolerance
    if (analysis.queryAnalysis.detectedIntents.includes('risk_assessment')) {
      const riskTerms = analysis.queryAnalysis.detectedIntents.filter(
        intent => ['high_risk', 'moderate_risk', 'low_risk'].includes(intent)
      );
      
      if (riskTerms.length > 0) {
        prefs.riskTolerance = riskTerms[0].includes('high') ? 'high' :
                             riskTerms[0].includes('low') ? 'low' : 'medium';
      }
    }

    // Update investment goals
    if (analysis.queryAnalysis.detectedIntents.includes('investment_strategy')) {
      const goals = analysis.queryAnalysis.conceptualIndicators
        .filter(indicator => 
          ['long_term', 'short_term', 'growth', 'income', 'trading'].includes(indicator)
        );
      
      if (goals.length > 0) {
        prefs.investmentGoals = Array.from(new Set([
          ...(prefs.investmentGoals || []),
          ...goals
        ]));
      }
    }
  }

  suggestNextTopics(sessionId: string): string[] {
    const context = this.getContext(sessionId);
    const suggestions: string[] = [];

    // Add topic-based suggestions
    switch (context.currentTopic) {
      case 'MARKET_DATA':
        suggestions.push(
          'How does this compare to other similar tokens?',
          'What are the recent market trends?',
          'Would you like to see the price history?'
        );
        break;
      case 'COMPARISON':
        suggestions.push(
          'Which token has better performance?',
          'What are the key differences in technology?',
          'How do their market caps compare?'
        );
        break;
      case 'CONCEPTUAL':
        suggestions.push(
          'Would you like to see some real-world examples?',
          'How does this relate to other blockchain concepts?',
          'What are the practical applications?'
        );
        break;
      case 'HYBRID':
        suggestions.push(
          'Would you like more detailed market data?',
          'Should we focus on technical analysis?',
          'Would you like to understand the underlying technology?'
        );
        break;
    }

    // Add personalized suggestions
    if (context.memory.userPreferences.favoriteTokens?.length) {
      const favoriteToken = context.memory.userPreferences.favoriteTokens[0];
      suggestions.push(
        `What's the latest price of ${favoriteToken}?`,
        `How has ${favoriteToken} performed recently?`
      );
    }

    // Add risk-based suggestions
    if (context.memory.userPreferences.riskTolerance) {
      switch (context.memory.userPreferences.riskTolerance) {
        case 'high':
          suggestions.push(
            'Show me high-potential emerging tokens',
            'What are the most volatile tokens today?'
          );
          break;
        case 'medium':
          suggestions.push(
            'Show me tokens with balanced risk-reward',
            'What are the trending mid-cap tokens?'
          );
          break;
        case 'low':
          suggestions.push(
            'What are the most stable tokens?',
            'Show me tokens with consistent performance'
          );
          break;
      }
    }

    // Randomize and limit suggestions
    return this.shuffleArray(suggestions).slice(0, 3);
  }

  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  cleanupExpiredContexts(): void {
    const now = Date.now();
    for (const [sessionId, context] of this.contexts.entries()) {
      if (now - context.memory.lastInteraction > this.CONTEXT_EXPIRY) {
        this.contexts.delete(sessionId);
      }
    }
  }
}

================================================================================
File: lib/env-config.ts
================================================================================

interface EnvConfig {
  COINGECKO_API_KEY: string;
  COINMARKETCAP_API_KEY: string;
  OPENAI_API_KEY: string;
  NODE_ENV: string;
  API_RATE_LIMITS: {
    COINGECKO: number;
    COINMARKETCAP: number;
  };
  API_BASE_URLS: {
    COINGECKO: string;
    COINMARKETCAP: string;
  };
}

function validateEnv(): EnvConfig {
  const requiredVars = [
    'COINGECKO_API_KEY',
    'COINMARKETCAP_API_KEY',
    'OPENAI_API_KEY'
  ];

  const missingVars = requiredVars.filter(
    varName => !process.env[varName]
  );

  // In development mode, use placeholder values for missing variables
  const isDev = process.env.NODE_ENV === 'development';
  
  if (missingVars.length > 0 && !isDev) {
    throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
  }

  return {
    COINGECKO_API_KEY: process.env.COINGECKO_API_KEY || (isDev ? 'development_key' : ''),
    COINMARKETCAP_API_KEY: process.env.COINMARKETCAP_API_KEY || (isDev ? 'development_key' : ''),
    OPENAI_API_KEY: process.env.OPENAI_API_KEY || (isDev ? 'development_key' : ''),
    NODE_ENV: process.env.NODE_ENV || 'development',
    API_RATE_LIMITS: {
      COINGECKO: parseInt(process.env.COINGECKO_RATE_LIMIT || '50'),
      COINMARKETCAP: parseInt(process.env.COINMARKETCAP_RATE_LIMIT || '30')
    },
    API_BASE_URLS: {
      COINGECKO: process.env.COINGECKO_API_BASE || 'https://api.coingecko.com/api/v3',
      COINMARKETCAP: process.env.COINMARKETCAP_API_BASE || 'https://pro-api.coinmarketcap.com/v1'
    }
  };
}

export const envConfig = validateEnv();

// Rate limit tracking
let lastCoinGeckoCall = 0;
let lastCoinMarketCapCall = 0;

export function canCallCoinGecko(): boolean {
  const now = Date.now();
  const timeSinceLastCall = now - lastCoinGeckoCall;
  const minInterval = (60 * 1000) / envConfig.API_RATE_LIMITS.COINGECKO; // Convert rate per minute to ms interval
  return timeSinceLastCall >= minInterval;
}

export function canCallCoinMarketCap(): boolean {
  const now = Date.now();
  const timeSinceLastCall = now - lastCoinMarketCapCall;
  const minInterval = (60 * 1000) / envConfig.API_RATE_LIMITS.COINMARKETCAP;
  return timeSinceLastCall >= minInterval;
}

export function recordCoinGeckoCall(): void {
  lastCoinGeckoCall = Date.now();
}

export function recordCoinMarketCapCall(): void {
  lastCoinMarketCapCall = Date.now();
}

// Environment helpers
export function isDevelopment(): boolean {
  return envConfig.NODE_ENV === 'development';
}

export function isProduction(): boolean {
  return envConfig.NODE_ENV === 'production';
}

// API key access
export function getApiKey(service: 'COINGECKO' | 'COINMARKETCAP' | 'OPENAI'): string {
  switch (service) {
    case 'COINGECKO':
      return envConfig.COINGECKO_API_KEY;
    case 'COINMARKETCAP':
      return envConfig.COINMARKETCAP_API_KEY;
    case 'OPENAI':
      return envConfig.OPENAI_API_KEY;
    default:
      throw new Error(`Unknown service: ${service}`);
  }
}

// API base URL access
export function getApiBaseUrl(service: 'COINGECKO' | 'COINMARKETCAP'): string {
  return envConfig.API_BASE_URLS[service];
}

// Rate limit info
export function getRateLimit(service: 'COINGECKO' | 'COINMARKETCAP'): number {
  return envConfig.API_RATE_LIMITS[service];
}

// Time until next allowed call
export function getTimeUntilNextCall(service: 'COINGECKO' | 'COINMARKETCAP'): number {
  const now = Date.now();
  const lastCall = service === 'COINGECKO' ? lastCoinGeckoCall : lastCoinMarketCapCall;
  const minInterval = (60 * 1000) / getRateLimit(service);
  const timeUntilNext = Math.max(0, minInterval - (now - lastCall));
  return timeUntilNext;
}

================================================================================
File: lib/llm.ts
================================================================================

import { Configuration, OpenAIApi } from 'openai';
import { TokenInfo, TokenPrice, TokenTrend } from './token-data';

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
let openai: OpenAIApi | null = null;

function getOpenAIClient() {
  if (!openai) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    const configuration = new Configuration({ apiKey });
    openai = new OpenAIApi(configuration);
  }
  return openai;
}

// System prompt template for different query types
const SYSTEM_PROMPTS = {
  trending: `You are an expert cryptocurrency analyst specializing in market trends and token analysis. Your role is to:
1. Analyze the provided trending token data and their price movements
2. Highlight significant price changes and market movements
3. Provide brief, factual insights about each trending token
4. Format the response in a clear, easy-to-read manner
5. Only use the data provided - do not make assumptions or predictions

When discussing tokens:
- Always include the token symbol in uppercase
- Show percentage changes with 2 decimal places
- Format large numbers for readability (e.g., "$1.2M" instead of "1200000")
- Highlight significant movements (>5% changes)
- If price data is missing, acknowledge it explicitly`,

  tokenInfo: `You are a cryptocurrency token specialist providing detailed token analysis. Your role is to:
1. Present the token's key metrics clearly and accurately
2. Explain price movements and market position
3. Compare current prices to ATH when relevant
4. Format numbers for easy reading
5. Only use the provided data - no speculation or predictions

When presenting token information:
- Lead with the token's full name and symbol
- Format market cap and volume figures clearly
- Show price changes as percentages with 2 decimal places
- Include supply information when available
- If any key data is missing, acknowledge it explicitly`,

  transactions: `You are a blockchain transaction analyst specializing in DeFi activities. Your role is to:
1. Summarize recent transaction patterns
2. Identify significant swaps or liquidity events
3. Present transaction volumes clearly
4. Group similar transactions when relevant
5. Only discuss transactions in the provided data

When analyzing transactions:
- Format amounts with appropriate decimals
- Group similar transaction types together
- Highlight large value movements
- Show timestamps in a human-readable format
- If transaction details are incomplete, state it clearly`
} as const;

interface GenerateResponseOptions {
  queryType: keyof typeof SYSTEM_PROMPTS;
  maxTokens?: number;
  temperature?: number;
}

export async function generateResponse(
  query: string,
  data: any,
  context?: string,
  options: GenerateResponseOptions = { queryType: 'trending' }
): Promise<string> {
  try {
    // Validate input data
    if (!query.trim()) {
      throw new Error('Query cannot be empty');
    }

    if (!data) {
      throw new Error('Data is required');
    }

    const client = getOpenAIClient();
    
    // Format data based on query type
    const formattedData = formatDataForPrompt(data, options.queryType);
    
    const systemPrompt = SYSTEM_PROMPTS[options.queryType];
    const userContext = context ? `Previous context:\n${context}\n\n` : '';
    
    const messages = [
      { role: "system" as const, content: systemPrompt },
      { role: "user" as const, content: `${userContext}Available Data:\n${formattedData}\n\nUser Question: ${query}` }
    ];

    const completion = await client.createChatCompletion({
      model: OPENAI_MODEL,
      messages,
      temperature: options.temperature ?? 0.7,
      max_tokens: options.maxTokens ?? 500,
      presence_penalty: 0.1,
      frequency_penalty: 0.1,
    });

    const response = completion.data.choices[0]?.message?.content;
    if (!response) {
      throw new Error('No response received from OpenAI');
    }

    return response;

  } catch (error) {
    console.error('LLM error:', error);
    
    // Improve error handling with specific error types
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        throw new Error('OpenAI API key is invalid or not configured');
      }
      if (error.message.includes('429')) {
        throw new Error('Rate limit exceeded. Please try again in a moment');
      }
      if (error.message.includes('401')) {
        throw new Error('Authentication failed. Please check API key configuration');
      }
      if (error.message.includes('insufficient_quota')) {
        throw new Error('OpenAI API quota exceeded. Please try again later');
      }
      throw error;
    }
    
    throw new Error('An unexpected error occurred while processing your request');
  }
}

function formatDataForPrompt(data: any, queryType: keyof typeof SYSTEM_PROMPTS): string {
  if (!data) return 'No data available.';
  
  switch (queryType) {
    case 'trending':
      return formatTrendingData(data);
    case 'tokenInfo':
      return formatTokenInfo(data);
    case 'transactions':
      return formatTransactionData(data);
    default:
      return JSON.stringify(data, null, 2);
  }
}

function formatTrendingData(data: { 
  trending: TokenTrend[], 
  prices: Record<string, TokenPrice> 
}): string {
  if (!data.trending?.length) return 'No trending data available.';
  
  return data.trending.map(trend => {
    const price = data.prices[trend.item.id];
    return `Token: ${trend.item.name} (${trend.item.symbol.toUpperCase()})
- Market Cap Rank: ${trend.item.market_cap_rank ?? 'N/A'}
- Current Price: ${price?.current_price ? `$${price.current_price.toFixed(6)}` : 'N/A'}
- 24h Change: ${price?.price_change_percentage_24h ? `${price.price_change_percentage_24h.toFixed(2)}%` : 'N/A'}
- Market Cap: ${price?.market_cap ? `$${formatNumber(price.market_cap)}` : 'N/A'}`;
  }).join('\n\n');
}

function formatTokenInfo(data: { tokenDetails: TokenInfo[], prices: Record<string, TokenPrice> }): string {
  if (!data.tokenDetails?.length) return 'No token information available.';
  
  return data.tokenDetails.map(token => {
    const price = data.prices[token.id];
    return `Token: ${token.name} (${token.symbol.toUpperCase()})
Current Price: $${token.current_price?.toFixed(6) ?? 'N/A'}
Market Cap: $${formatNumber(token.market_cap)} (Rank #${token.market_cap_rank ?? 'N/A'})
24h Trading Volume: $${formatNumber(token.total_volume)}
24h Price Change: ${token.price_change_percentage_24h?.toFixed(2) ?? 'N/A'}%
24h Range: $${token.low_24h?.toFixed(6) ?? 'N/A'} - $${token.high_24h?.toFixed(6) ?? 'N/A'}
All-Time High: $${token.ath?.toFixed(6) ?? 'N/A'} (${token.ath_date ? new Date(token.ath_date).toLocaleDateString() : 'N/A'})
Supply Information:
- Circulating: ${formatNumber(token.circulating_supply)}
- Total: ${token.total_supply ? formatNumber(token.total_supply) : 'N/A'}
- Max: ${token.max_supply ? formatNumber(token.max_supply) : 'N/A'}`;
  }).join('\n\n');
}

function formatTransactionData(data: any): string {
  if (!data?.transactions?.length) return 'No transaction data available.';
  
  return data.transactions.map((tx: any) => {
    let actionType = 'Unknown';
    let details = '';
    
    if (tx.swaps?.length) {
      actionType = 'Swap';
      const swap = tx.swaps[0];
      details = `${swap.pair.token0.symbol}/${swap.pair.token1.symbol} ($${parseFloat(swap.amountUSD).toFixed(2)})`;
    } else if (tx.mints?.length) {
      actionType = 'Liquidity Addition';
      const mint = tx.mints[0];
      details = `${mint.pair.token0.symbol}/${mint.pair.token1.symbol}`;
    } else if (tx.burns?.length) {
      actionType = 'Liquidity Removal';
      const burn = tx.burns[0];
      details = `${burn.pair.token0.symbol}/${burn.pair.token1.symbol}`;
    }

    return `Transaction Type: ${actionType}
Details: ${details}
Timestamp: ${new Date(tx.timestamp * 1000).toLocaleString()}`;
  }).join('\n\n');
}

function formatNumber(num: number | null | undefined): string {
  if (num === null || num === undefined) return 'N/A';
  
  if (num >= 1e9) {
    return `${(num / 1e9).toFixed(2)}B`;
  }
  if (num >= 1e6) {
    return `${(num / 1e6).toFixed(2)}M`;
  }
  if (num >= 1e3) {
    return `${(num / 1e3).toFixed(2)}K`;
  }
  return num.toString();
}

================================================================================
File: lib/middleware.ts
================================================================================

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { verifyToken, type UserRole, type AuthenticatedUser } from './auth';

export function withAuth(handler: Function, requiredRole?: UserRole) {
  return async function (req: NextRequest) {
    const token = req.headers.get('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const user = verifyToken(token);
    if (!user) {
      return NextResponse.json(
        { error: 'Invalid or expired token' },
        { status: 401 }
      );
    }

    if (requiredRole && user.role !== requiredRole) {
      return NextResponse.json(
        { error: 'Insufficient permissions' },
        { status: 403 }
      );
    }

    // Pass the user to the handler function instead of modifying the request
    return handler(req, user);
  };
}

================================================================================
File: lib/orchestrator.ts
================================================================================

import { 
  analyzeUserQuery,
  buildAggregatorCalls,
  executeAggregatorCalls,
  generateSummary,
  RobustAnalysis,
  OrchestrationResult,
  AggregatorResult
} from './agents';
import { ConversationStore, ChatMessage } from './conversation-store';
import { buildEnhancedContext, formatContextForPrompt, analyzeContextContinuity } from './conversation/context-builder';

export class AgentOrchestrator {
  constructor() {
    // Clean up expired sessions periodically
    setInterval(() => {
      ConversationStore.cleanExpiredSessions();
    }, 5 * 60 * 1000); // Every 5 minutes
  }

  private checkApiKeys(): void {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('API configuration error: OpenAI API key is not configured');
    }

    if (!process.env.COINMARKETCAP_API_KEY) {
      console.warn('Warning: CoinMarketCap API key not configured - fallback functionality may be limited');
    }

    if (!process.env.COINGECKO_API_KEY) {
      console.warn('Warning: CoinGecko API key not configured - API rate limits may be restricted');
    }
  }

  private async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries = 3,
    initialDelay = 1000
  ): Promise<T> {
    let lastError: Error | null = null;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Operation timed out')), 30000); // 30s timeout
        });
        
        const operationPromise = operation();
        
        return await Promise.race([operationPromise, timeoutPromise]) as T;
      } catch (error) {
        lastError = error as Error;
        
        const isRetryable = error instanceof Error && (
          error.message.includes('socket hang up') ||
          error.message.includes('rate limit') ||
          error.message.includes('timeout') ||
          error.message.includes('ECONNRESET') ||
          error.message.includes('ETIMEDOUT')
        );
        
        if (isRetryable && i < maxRetries - 1) {
          const delay = initialDelay * Math.pow(2, i);
          console.log(`Retry ${i + 1}/${maxRetries} after ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        throw error;
      }
    }
    
    throw lastError || new Error('Operation failed after retries');
  }

  private async handleProcessingError(error: unknown): Promise<never> {
    console.error('Orchestration error:', error);
    
    if (error instanceof Error) {
      // Authentication errors
      if (error.message.includes('401') || error.message.includes('unauthorized') || error.message.includes('invalid api key')) {
        throw new Error('Service configuration error: API key is invalid or not configured properly. Please check your environment settings.');
      }

      // Rate limiting
      if (error.message.includes('429') || error.message.includes('rate limit')) {
        throw new Error('Service is currently busy. Please try again in a moment.');
      }

      // API errors
      if (error.message.includes('socket hang up') || error.message.includes('ECONNRESET')) {
        throw new Error('Connection interrupted. Please try again.');
      }

      if (error.message.includes('timeout')) {
        throw new Error('Request timed out. Please try again.');
      }

      // Service errors
      if (error.message.includes('503') || error.message.includes('502')) {
        throw new Error('Service is temporarily unavailable. Please try again later.');
      }

      // Return the original error message if it's from our own validation
      if (error.message.includes('API configuration error') || 
          error.message.includes('Session ID is required')) {
        throw error;
      }
    }
    
    // Generic error for unhandled cases
    throw new Error('An unexpected error occurred. Please try again later.');
  }

  async processQuery(query: string, sessionId?: string): Promise<OrchestrationResult> {
    console.log('Starting query processing:', { query, sessionId });
    
    try {
      // Check API keys first
      this.checkApiKeys();

      if (!sessionId) {
        throw new Error('Session ID is required for conversation memory');
      }

      // Step 1: Intent Analysis with retry
      console.log('Running intent analysis...');
      const analysis = await this.withRetry(
        () => analyzeUserQuery({ query }),
        3,
        1000
      );

      // Step 2: Build Enhanced Context
      const enhancedContext = buildEnhancedContext(sessionId, analysis);
      const formattedContext = formatContextForPrompt(enhancedContext);
      
      // Analyze conversation continuity
      const continuityAnalysis = analyzeContextContinuity(enhancedContext);
      console.log('Context analysis:', {
        isCoherent: continuityAnalysis.isCoherent,
        confidence: continuityAnalysis.confidence
      });

      // Store user message with metadata
      ConversationStore.addMessage(sessionId, {
        role: 'user',
        content: query,
        timestamp: Date.now(),
        metadata: {
          intent: analysis.classification.primaryIntent,
          confidence: analysis.classification.confidence,
          tokens: analysis.queryAnalysis.detectedTokens,
          contextConfidence: continuityAnalysis.confidence
        }
      });

      let aggregatorData: AggregatorResult | null = null;
      let response: string;

      // Step 3: Process based on intent and context with retry
      try {
        if (analysis.classification.needsApiCall || analysis.classification.requiresWebSearch) {
          console.log('Building aggregator spec...');
          const aggregatorSpec = await buildAggregatorCalls(analysis);
          
          console.log('Executing aggregator calls with retry...');
          aggregatorData = await this.withRetry(
            () => executeAggregatorCalls(aggregatorSpec),
            3,
            2000
          );
        }

        // Step 4: Generate Response with Enhanced Context and retry
        console.log('Generating response with enhanced context...');
        response = await this.withRetry(
          () => generateSummary({
            userQuery: query,
            analysis,
            aggregatorResult: aggregatorData,
            sessionId,
            enhancedContext: formattedContext
          }),
          3,
          1000
        );

        // Store assistant response with metadata
        ConversationStore.addMessage(sessionId, {
          role: 'assistant',
          content: response,
          timestamp: Date.now(),
          metadata: {
            intent: analysis.classification.primaryIntent,
            tokens: analysis.queryAnalysis.detectedTokens,
            contextConfidence: continuityAnalysis.confidence
          }
        });

        // Add follow-up suggestion if conversation flow needs bridging
        if (continuityAnalysis.suggestedFollowUp) {
          response += `\n\n${continuityAnalysis.suggestedFollowUp}`;
        }

        // Generate contextual suggestions
        const suggestions = this.generateSuggestions(
          analysis,
          enhancedContext
        );

        return {
          analysis,
          aggregatorData,
          response,
          suggestions,
          contextAnalysis: {
            isCoherent: continuityAnalysis.isCoherent,
            confidence: continuityAnalysis.confidence
          }
        };

      } catch (error) {
        console.error('Branch processing error:', error);
        
        // Attempt recovery with fallback processing
        response = await this.withRetry(
          () => generateSummary({
            userQuery: query,
            analysis,
            aggregatorResult: null,
            sessionId,
            enhancedContext: formattedContext
          }),
          3,
          1000
        );

        return {
          analysis,
          aggregatorData: null,
          response,
          suggestions: []
        };
      }

    } catch (error) {
      return this.handleProcessingError(error);
    }
  }

  private generateSuggestions(
    analysis: RobustAnalysis,
    enhancedContext: any
  ): string[] {
    const suggestions: string[] = [];

    // Add topic-based suggestions
    switch (analysis.classification.primaryIntent) {
      case 'MARKET_DATA':
        if (enhancedContext.userPreferences.technicalLevel === 'advanced') {
          suggestions.push(
            'Would you like to see detailed market metrics?',
            'Should we analyze the trading volume patterns?'
          );
        } else {
          suggestions.push(
            'How does this compare to other tokens?',
            'Would you like to see the price history?'
          );
        }
        break;

      case 'TECHNICAL':
        suggestions.push(
          'Would you like to see code examples?',
          'Should we explore security implications?'
        );
        break;

      case 'DEFI':
        suggestions.push(
          'Would you like to analyze the protocol risks?',
          'Should we compare yields across platforms?'
        );
        break;

      case 'REGULATORY':
        suggestions.push(
          'Would you like to see compliance requirements?',
          'Should we check jurisdictional differences?'
        );
        break;

      case 'SECURITY':
        suggestions.push(
          'Would you like to see recent audit findings?',
          'Should we review security best practices?'
        );
        break;

      case 'NEWS_EVENTS':
        suggestions.push(
          'Would you like to see related developments?',
          'Should we analyze market impact?'
        );
        break;
    }

    // Add personalized suggestions based on user preferences
    if (enhancedContext.userPreferences.favoriteTokens.length) {
      const favoriteToken = enhancedContext.userPreferences.favoriteTokens[0];
      suggestions.push(
        `What's the latest price of ${favoriteToken}?`,
        `How has ${favoriteToken} performed recently?`
      );
    }

    // Randomize and limit suggestions
    return this.shuffleArray(suggestions).slice(0, 3);
  }

  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
}

================================================================================
File: lib/session-utils.ts
================================================================================

import { v4 as uuidv4 } from 'uuid';

interface SessionStorage {
  getItem(key: string): string | null;
  setItem(key: string, value: string): void;
  removeItem(key: string): void;
}

class MemoryStorage implements SessionStorage {
  private storage = new Map<string, string>();

  getItem(key: string): string | null {
    return this.storage.get(key) || null;
  }

  setItem(key: string, value: string): void {
    this.storage.set(key, value);
  }

  removeItem(key: string): void {
    this.storage.delete(key);
  }
}

export const SESSION_STORAGE_KEY = 'chatSessionId';

export const getStorage = (): SessionStorage => {
  if (typeof window === 'undefined') {
    return new MemoryStorage();
  }

  try {
    // Test localStorage availability
    const test = '__test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return localStorage;
  } catch (e) {
    console.warn('localStorage not available, falling back to memory storage');
    return new MemoryStorage();
  }
};

export const initializeSession = (): string => {
  const storage = getStorage();
  const existingSession = storage.getItem(SESSION_STORAGE_KEY);
  
  if (existingSession) {
    console.log('Found existing session:', existingSession);
    return existingSession;
  }
  
  const newSession = uuidv4();
  console.log('Creating new session:', newSession);
  
  try {
    storage.setItem(SESSION_STORAGE_KEY, newSession);
  } catch (e) {
    console.error('Failed to store session:', e);
  }
  
  return newSession;
};

export const clearSession = (): void => {
  const storage = getStorage();
  try {
    storage.removeItem(SESSION_STORAGE_KEY);
  } catch (e) {
    console.error('Failed to clear session:', e);
  }
};

export const validateSession = (sessionId: string | null): boolean => {
  if (!sessionId) return false;
  
  // Validate UUID format
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(sessionId);
};

================================================================================
File: lib/token-data.ts
================================================================================

import { 
  envConfig, 
  canCallCoinGecko, 
  canCallCoinMarketCap,
  recordCoinGeckoCall,
  recordCoinMarketCapCall,
  getApiBaseUrl,
  getApiKey
} from './env-config';
import { queryCounter, queryDuration, queryErrors } from './monitoring';

export interface TokenPrice {
  current_price: number;
  market_cap: number;
  price_change_percentage_24h: number;
  source: 'coingecko' | 'coinmarketcap';
}

export interface TokenInfo {
  id: string;
  symbol: string;
  name: string;
  current_price: number;
  market_cap: number;
  market_cap_rank: number;
  total_volume: number;
  high_24h: number | null;
  low_24h: number | null;
  price_change_24h: number;
  price_change_percentage_24h: number;
  circulating_supply: number;
  total_supply: number;
  max_supply: number | null;
  ath: number | null;
  ath_date: string | null;
  source: 'coingecko' | 'coinmarketcap';
}

export interface TokenTrend {
  item: {
    id: string;
    coin_id: number;
    name: string;
    symbol: string;
    market_cap_rank: number;
    thumb: string;
    small: string;
    large: string;
    slug: string;
    price_btc: number;
    score: number;
  };
}

async function fetchCoinGecko(endpoint: string): Promise<Response> {
  const response = await fetch(
    `${getApiBaseUrl('COINGECKO')}${endpoint}`,
    {
      headers: {
        'x-cg-pro-api-key': getApiKey('COINGECKO'),
        'Accept': 'application/json'
      }
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('CoinGecko rate limit exceeded');
    }
    throw new Error(`CoinGecko API error: ${response.status}`);
  }

  return response;
}

async function fetchCoinMarketCap(endpoint: string): Promise<any> {
  const response = await fetch(
    `${getApiBaseUrl('COINMARKETCAP')}${endpoint}`,
    {
      headers: {
        'X-CMC_PRO_API_KEY': getApiKey('COINMARKETCAP'),
        'Accept': 'application/json'
      }
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('CoinMarketCap rate limit exceeded');
    }
    throw new Error(`CoinMarketCap API error: ${response.status}`);
  }

  const data = await response.json();
  if (data.status?.error_code) {
    throw new Error(`CoinMarketCap error: ${data.status.error_message}`);
  }

  return data.data;
}

export async function getTrendingTokens(): Promise<TokenTrend[]> {
  try {
    if (canCallCoinGecko()) {
      const response = await fetchCoinGecko('/search/trending');
      const data = await response.json();
      recordCoinGeckoCall();
      
      if (data?.coins) {
        return data.coins;
      }
    }
    
    // Fallback to CoinMarketCap trending
    if (canCallCoinMarketCap()) {
      const data = await fetchCoinMarketCap('/cryptocurrency/trending/latest');
      recordCoinMarketCapCall();
      
      if (data) {
        // Transform to match CoinGecko format
        return data.map((coin: any) => ({
          item: {
            id: coin.slug,
            coin_id: coin.id,
            name: coin.name,
            symbol: coin.symbol,
            market_cap_rank: coin.cmc_rank,
            thumb: coin.logo || '',
            small: coin.logo || '',
            large: coin.logo || '',
            slug: coin.slug,
            price_btc: coin.quote?.BTC?.price || 0,
            score: 0
          }
        }));
      }
    }
    
    return [];
  } catch (error) {
    console.error('Error fetching trending tokens:', error);
    return [];
  }
}

async function searchToken(query: string): Promise<{id: string, symbol: string, name: string} | null> {
  if (!query?.trim()) {
    throw new Error('Search query is required');
  }

  try {
    // Try CoinGecko first
    if (canCallCoinGecko()) {
      try {
        const response = await fetchCoinGecko(
          `/search?query=${encodeURIComponent(query)}`
        );

        const data = await response.json();
        if (data.coins?.length > 0) {
          // Find best match based on exact symbol/name match or highest market cap rank
          const exactSymbolMatch = data.coins.find(
            (coin: { symbol: string }) => coin.symbol.toLowerCase() === query.toLowerCase()
          );
          
          if (exactSymbolMatch) {
            recordCoinGeckoCall();
            return {
              id: exactSymbolMatch.id,
              symbol: exactSymbolMatch.symbol.toLowerCase(),
              name: exactSymbolMatch.name
            };
          }
          
          const exactNameMatch = data.coins.find(
            (coin: { name: string }) => coin.name.toLowerCase() === query.toLowerCase()
          );
          
          if (exactNameMatch) {
            recordCoinGeckoCall();
            return {
              id: exactNameMatch.id,
              symbol: exactNameMatch.symbol.toLowerCase(),
              name: exactNameMatch.name
            };
          }
          
          // Otherwise return the highest ranked result
          const bestMatch = data.coins.reduce((best: any, current: any) => {
            return (current.market_cap_rank < best.market_cap_rank) ? current : best;
          }, data.coins[0]);
          
          recordCoinGeckoCall();
          return {
            id: bestMatch.id,
            symbol: bestMatch.symbol.toLowerCase(),
            name: bestMatch.name
          };
        }
      } catch (error) {
        console.warn('CoinGecko search failed:', error);
      }
    }
    
    // Fallback to CoinMarketCap
    if (canCallCoinMarketCap()) {
      try {
        const data = await fetchCoinMarketCap(
          `/cryptocurrency/map?symbol=${encodeURIComponent(query)}`
        );
        
        if (data?.length > 0) {
          // Sort by rank and take the best match
          const bestMatch = data.sort((a: any, b: any) => a.rank - b.rank)[0];
          
          recordCoinMarketCapCall();
          return {
            id: bestMatch.id.toString(),
            symbol: bestMatch.symbol.toLowerCase(),
            name: bestMatch.name
          };
        }
      } catch (error) {
        console.warn('CoinMarketCap search failed:', error);
      }
    }

    return null;
  } catch (error) {
    console.error('Token search error:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('Rate limit exceeded. Please try again in a moment.');
      }
      if (error.message.includes('API key')) {
        throw new Error('API configuration error. Please check your settings.');
      }
    }
    
    throw new Error('Failed to search for token');
  }
}

export async function getTokenDetails(query: string): Promise<TokenInfo | null> {
  if (!query?.trim()) {
    throw new Error('Token query is required');
  }

  try {
    // First search for the token
    const tokenMatch = await searchToken(query);
    if (!tokenMatch) {
      return null;
    }

    console.log(`Found token match:`, tokenMatch);

    // Try CoinGecko first
    if (canCallCoinGecko()) {
      try {
        const response = await fetchCoinGecko(
          `/coins/${tokenMatch.id}?localization=false&tickers=false&community_data=false&developer_data=false`
        );

        const data = await response.json();
        if (data?.market_data) {
          recordCoinGeckoCall();
          
          return {
            id: data.id,
            symbol: data.symbol,
            name: data.name,
            current_price: data.market_data.current_price.usd,
            market_cap: data.market_data.market_cap.usd,
            market_cap_rank: data.market_cap_rank,
            total_volume: data.market_data.total_volume.usd,
            high_24h: data.market_data.high_24h?.usd || null,
            low_24h: data.market_data.low_24h?.usd || null,
            price_change_24h: data.market_data.price_change_24h || 0,
            price_change_percentage_24h: data.market_data.price_change_percentage_24h || 0,
            circulating_supply: data.market_data.circulating_supply,
            total_supply: data.market_data.total_supply,
            max_supply: data.market_data.max_supply,
            ath: data.market_data.ath?.usd || null,
            ath_date: data.market_data.ath_date?.usd || null,
            source: 'coingecko'
          };
        }
      } catch (error) {
        console.warn('CoinGecko details fetch failed:', error);
      }
    }
    
    // Fallback to CoinMarketCap
    if (canCallCoinMarketCap()) {
      try {
        const data = await fetchCoinMarketCap(
          `/cryptocurrency/quotes/latest?symbol=${tokenMatch.symbol}`
        );
        
        if (data && data[tokenMatch.symbol]) {
          const coinData = data[tokenMatch.symbol][0];
          const quote = coinData.quote.USD;
          
          recordCoinMarketCapCall();
          
          return {
            id: coinData.slug,
            symbol: coinData.symbol.toLowerCase(),
            name: coinData.name,
            current_price: quote.price,
            market_cap: quote.market_cap,
            market_cap_rank: coinData.cmc_rank,
            total_volume: quote.volume_24h,
            high_24h: null, // Not available in this endpoint
            low_24h: null, // Not available in this endpoint
            price_change_24h: quote.volume_change_24h || 0,
            price_change_percentage_24h: quote.percent_change_24h || 0,
            circulating_supply: coinData.circulating_supply,
            total_supply: coinData.total_supply,
            max_supply: coinData.max_supply,
            ath: null,
            ath_date: null,
            source: 'coinmarketcap'
          };
        }
      } catch (error) {
        console.warn('CoinMarketCap details fetch failed:', error);
      }
    }

    throw new Error('Failed to fetch token details from all available sources');

  } catch (error) {
    console.error('Token details fetch error:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('Rate limit exceeded. Please try again in a moment.');
      }
      if (error.message.includes('API key')) {
        throw new Error('API configuration error. Please check your settings.');
      }
    }
    
    return null;
  }
}

export async function getTokenPrices(tokens: string[]): Promise<Record<string, TokenPrice>> {
  const results: Record<string, TokenPrice> = {};
  
  for (const token of tokens) {
    const tokenInfo = await getTokenDetails(token);
    if (tokenInfo) {
      results[token] = {
        current_price: tokenInfo.current_price,
        market_cap: tokenInfo.market_cap,
        price_change_percentage_24h: tokenInfo.price_change_percentage_24h,
        source: tokenInfo.source
      };
    }
  }
  
  return results;
}

================================================================================
File: lib/types/conversation.ts
================================================================================

import type { RobustAnalysis } from '@/lib/agents/types';

export interface ConversationTopic {
  name: string;
  confidence: number;
  lastDiscussed: number;
  relatedTokens: string[];
}

export interface ConversationMemory {
  topics: ConversationTopic[];
  userPreferences: {
    favoriteTokens?: string[];
    riskTolerance?: 'low' | 'medium' | 'high';
    investmentGoals?: string[];
  };
  lastInteraction: number;
}

export interface ConversationContext {
  sessionId: string;
  memory: ConversationMemory;
  recentMessages: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp: number;
  }>;
  currentTopic?: string;
}

================================================================================
File: lib/utils.ts
================================================================================

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


================================================================================
File: lib/wagmi.ts
================================================================================

"use client";

import { http, createConfig } from 'wagmi';
import { mainnet } from 'wagmi/chains';
import { injected } from 'wagmi/connectors';
import { createPublicClient, fallback, http as viemHttp } from 'viem';

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: fallback([
    viemHttp(),
    viemHttp('https://eth-mainnet.g.alchemy.com/v2/demo'),
  ]),
});

export const config = createConfig({
  chains: [mainnet],
  connectors: [
    injected(),
  ],
  transports: {
    [mainnet.id]: http(),
  },
});

================================================================================
File: middleware.ts
================================================================================

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // Add CORS headers
  const response = NextResponse.next();
  
  response.headers.set('Access-Control-Allow-Origin', '*');
  response.headers.set(
    'Access-Control-Allow-Methods',
    'GET, POST, PUT, DELETE, OPTIONS'
  );
  response.headers.set(
    'Access-Control-Allow-Headers',
    'Content-Type, Authorization'
  );

  // Handle preflight requests
  if (request.method === 'OPTIONS') {
    return new NextResponse(null, { status: 200, headers: response.headers });
  }

  return response;
}

export const config = {
  matcher: '/api/:path*',
};

================================================================================
File: next.config.js
================================================================================

/** @type {import('next').NextConfig} */
const config = {
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: { unoptimized: true },
  async headers() {
    return [
      {
        source: "/api/:path*",
        headers: [
          { key: "Access-Control-Allow-Origin", value: "*" },
          { key: "Access-Control-Allow-Methods", value: "GET,POST,OPTIONS" },
          { key: "Access-Control-Allow-Headers", value: "Content-Type, Authorization" },
          { key: "Content-Type", value: "application/json" }
        ],
      },
    ];
  },
};

export default config;

================================================================================
File: package.json
================================================================================

{
  "name": "nextjs",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test:agents": "NODE_ENV=test node --loader ts-node/esm tests/agent-tests.ts"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.4",
    "@openzeppelin/contracts": "^5.2.0",
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-alert-dialog": "^1.0.5",
    "@radix-ui/react-aspect-ratio": "^1.0.3",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-checkbox": "^1.0.4",
    "@radix-ui/react-collapsible": "^1.0.3",
    "@radix-ui/react-context-menu": "^2.1.5",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-hover-card": "^1.0.7",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-menubar": "^1.0.4",
    "@radix-ui/react-navigation-menu": "^1.1.4",
    "@radix-ui/react-popover": "^1.0.7",
    "@radix-ui/react-progress": "^1.0.3",
    "@radix-ui/react-radio-group": "^1.1.3",
    "@radix-ui/react-scroll-area": "^1.0.5",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-separator": "^1.0.3",
    "@radix-ui/react-slider": "^1.1.2",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-switch": "^1.0.3",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-toast": "^1.1.5",
    "@radix-ui/react-toggle": "^1.0.3",
    "@radix-ui/react-toggle-group": "^1.0.4",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@supabase/supabase-js": "^2.39.7",
    "@tanstack/react-query": "^5.24.1",
    "@types/node": "^20.11.20",
    "@types/react": "^18.2.58",
    "@types/react-dom": "^18.2.19",
    "@types/uuid": "^9.0.8",
    "autoprefixer": "^10.4.17",
    "axios": "^1.8.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "cmdk": "^1.0.4",
    "date-fns": "^3.3.1",
    "embla-carousel-react": "^8.5.2",
    "ethers": "^6.13.5",
    "graphql": "^16.8.1",
    "graphql-request": "^6.1.0",
    "input-otp": "^1.4.2",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.341.0",
    "next": "14.1.0",
    "next-themes": "^0.4.4",
    "openai": "^3.3.0",
    "pino-pretty": "^10.3.1",
    "postcss": "^8.4.35",
    "react": "^18.2.0",
    "react-day-picker": "^9.5.1",
    "react-dom": "^18.2.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.12.1",
    "solc": "^0.8.28",
    "sonner": "^2.0.1",
    "tailwind-merge": "^2.2.1",
    "tailwindcss": "^3.4.1",
    "tailwindcss-animate": "^1.0.7",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3",
    "uuid": "^9.0.1",
    "vaul": "^1.1.2",
    "viem": "^2.23.7",
    "wagmi": "^2.5.7",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@graphql-codegen/cli": "^5.0.2",
    "@graphql-codegen/typescript": "^4.0.6",
    "@graphql-codegen/typescript-operations": "^4.1.3",
    "@types/jsonwebtoken": "^9.0.5"
  }
}


================================================================================
File: supabase/migrations/20250125030838_broad_tree.sql
================================================================================

/*
  # Initial Schema Setup

  1. New Tables
    - `users`
      - `id` (uuid, primary key)
      - `address` (text, unique) - Ethereum address
      - `role` (text) - User role (basic/advanced)
      - `created_at` (timestamp)
      - `last_login` (timestamp)
    
    - `queries`
      - `id` (uuid, primary key)
      - `user_id` (uuid, foreign key)
      - `query` (text)
      - `response` (text)
      - `created_at` (timestamp)

  2. Security
    - Enable RLS on all tables
    - Add policies for authenticated users
*/

-- Create users table
CREATE TABLE IF NOT EXISTS users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  address text UNIQUE NOT NULL,
  role text NOT NULL DEFAULT 'basic',
  created_at timestamptz DEFAULT now(),
  last_login timestamptz
);

-- Create queries table
CREATE TABLE IF NOT EXISTS queries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES users(id),
  query text NOT NULL,
  response text NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE queries ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can read own data"
  ON users
  FOR SELECT
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can update own data"
  ON users
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can read own queries"
  ON queries
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own queries"
  ON queries
  FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

================================================================================
File: tailwind.config.ts
================================================================================

import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      colors: {
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        chart: {
          '1': 'hsl(var(--chart-1))',
          '2': 'hsl(var(--chart-2))',
          '3': 'hsl(var(--chart-3))',
          '4': 'hsl(var(--chart-4))',
          '5': 'hsl(var(--chart-5))',
        },
      },
      keyframes: {
        'accordion-down': {
          from: {
            height: '0',
          },
          to: {
            height: 'var(--radix-accordion-content-height)',
          },
        },
        'accordion-up': {
          from: {
            height: 'var(--radix-accordion-content-height)',
          },
          to: {
            height: '0',
          },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};
export default config;


================================================================================
File: tsconfig.json
================================================================================

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "baseUrl": ".",
    "typeRoots": ["./node_modules/@types", "./types"]
  },
  "ts-node": {
    "esm": true,
    "transpileOnly": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "tests/**/*.ts",
    "types/**/*.d.ts"
  ],
  "exclude": ["node_modules"]
}