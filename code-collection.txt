

================================================================================
File: .bolt/config.json
================================================================================

{
  "template": "nextjs-shadcn"
}


================================================================================
File: app/api/auth/nonce/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { storeNonce } from '@/lib/auth';

export async function POST(req: Request) {
  try {
    const { address } = await req.json();
    const nonce = storeNonce(address);
    
    return NextResponse.json({ nonce });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to generate nonce' },
      { status: 500 }
    );
  }
}

================================================================================
File: app/api/auth/verify/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { verifySignature, generateToken } from '@/lib/auth';

export async function POST(req: Request) {
  try {
    const { message, signature, address } = await req.json();
    
    const user = await verifySignature(message, signature, address);
    const token = generateToken(user);
    
    return NextResponse.json({ token });
  } catch (error) {
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 401 }
    );
  }
}

================================================================================
File: app/api/blockchain-query/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { AgentOrchestrator } from '@/lib/orchestrator';

const corsHeaders = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const orchestrator = new AgentOrchestrator();

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

export async function POST(req: Request) {
  try {
    let body;
    try {
      body = await req.json();
    } catch {
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400, headers: corsHeaders }
      );
    }

    const { query, sessionId } = body;
    
    if (!query?.trim()) {
      return NextResponse.json(
        { error: 'Query is required' },
        { status: 400, headers: corsHeaders }
      );
    }

    const result = await orchestrator.processQuery(query, sessionId);

    return NextResponse.json(result, { 
      status: 200, 
      headers: corsHeaders 
    });

  } catch (error) {
    console.error('API Error:', error);
    
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to process request' 
      },
      { status: 500, headers: corsHeaders }
    );
  }
}

================================================================================
File: app/api/blockchain/route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { blockchainOrchestrator } from '@/lib/agents/blockchain-orchestrator';
import { BlockchainActionParams } from '@/lib/agents/blockchain-orchestrator';
import { sessionManager } from '@/lib/blockchain/session-manager';
import { WalletIntegrationService } from '@/lib/blockchain/wallet-integration';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { action, sessionId } = body;
    
    if (!action || !action.actionType) {
      return NextResponse.json(
        { error: 'Invalid request: actionType is required' },
        { status: 400 }
      );
    }
    
    // Special handling for wallet connections
    if (action.actionType === 'CONNECT_WALLET') {
      // Create a session ID if not provided
      const effectiveSessionId = sessionId || 'default-session';
      
      try {
        // Create a mock wallet service for server-side
        const walletService = new WalletIntegrationService();
        
        // Use a mock address for the server-side connection
        const mockAddress = '0x0000000000000000000000000000000000000000' as `0x${string}`;
        
        // Register this mock connection in the session manager
        sessionManager.storeConnection(
          effectiveSessionId,
          walletService,
          mockAddress,
          action.walletParams?.chainId || 1
        );
        
        console.log(`Registered mock wallet connection for session ${effectiveSessionId}`);
        
        // Return success response with the mock address
        return NextResponse.json({
          success: true,
          actionType: 'CONNECT_WALLET',
          data: {
            address: mockAddress,
            needsBrowserConnection: true
          }
        });
      } catch (error) {
        console.error('Error setting up mock wallet connection:', error);
        return NextResponse.json({
          success: false,
          actionType: 'CONNECT_WALLET',
          error: 'Failed to set up mock wallet connection'
        });
      }
    }
    
    // Add session ID to action params if provided
    const actionWithSession: BlockchainActionParams = {
      ...action,
      sessionId: sessionId || 'default-session'
    };
    
    // For other actions, execute them on the server
    const result = await blockchainOrchestrator.handleAction(actionWithSession);
    
    return NextResponse.json(result);
  } catch (error) {
    console.error('Blockchain API error:', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      },
      { status: 500 }
    );
  }
} 

================================================================================
File: app/api/chat/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { AgentOrchestrator } from '@/lib/orchestrator';

const orchestrator = new AgentOrchestrator();

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const corsHeaders = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

export async function POST(req: Request) {
  console.log('Chat API: Starting request processing');
  console.log('Headers:', Object.fromEntries(req.headers.entries()));

  try {
    let body;
    try {
      const text = await req.text();
      console.log('Raw request body:', text);
      body = JSON.parse(text);
      console.log('Chat API: Request body parsed:', body);
    } catch (error) {
      console.error('Chat API: JSON parsing error:', error);
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400, headers: corsHeaders }
      );
    }

    const { query, sessionId } = body;

    console.log('Chat API: Extracted sessionId:', sessionId);
    console.log('Chat API: Extracted query:', query);

    if (!query?.trim()) {
      console.log('Chat API: Empty query received');
      return NextResponse.json(
        { error: 'Query is required' },
        { status: 400, headers: corsHeaders }
      );
    }

    if (!sessionId?.trim()) {
      console.log('Chat API: No sessionId received');
      return NextResponse.json(
        { 
          error: 'Session ID is required',
          debug: { 
            body,
            headers: Object.fromEntries(req.headers.entries())
          }
        },
        { status: 400, headers: corsHeaders }
      );
    }

    console.log('Chat API: Starting chat pipeline for query:', query);
    console.log('Chat API: Using session ID:', sessionId);

    const result = await orchestrator.processQuery(query, sessionId);

    console.log('Chat API: Pipeline complete. Analysis:', result.analysis.classification.primaryIntent);
    console.log('Chat API: Generated response:', result.response);

    return NextResponse.json(
      {
        response: result.response,
        data: result.aggregatorData,
        analysis: result.analysis,
        suggestions: result.suggestions,
        contextAnalysis: result.contextAnalysis
      },
      { status: 200, headers: corsHeaders }
    );
  } catch (error) {
    console.error('Chat API error:', error);

    let errorMessage = 'Failed to process chat request';
    let statusCode = 500;

    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        errorMessage = 'Service configuration error';
        statusCode = 503;
      } else if (error.message.includes('rate limit')) {
        errorMessage = 'Service is busy, please try again in a moment';
        statusCode = 429;
      } else if (error.message.includes('validation')) {
        errorMessage = error.message;
        statusCode = 400;
      } else if (error.message.includes('Session ID is required')) {
        errorMessage = 'Session ID is required for conversation memory';
        statusCode = 400;
      } else {
        errorMessage = error.message;
      }
    }

    return NextResponse.json(
      { error: errorMessage },
      { status: statusCode, headers: corsHeaders }
    );
  }
}

================================================================================
File: app/api/token-data/route.ts
================================================================================

import { NextResponse } from 'next/server';
import { getTrendingTokens, getTokenPrices } from '@/lib/token-data';
import { withRateLimit } from '@/lib/rate-limit';
import { withAuth } from '@/lib/middleware';

const handler = withAuth(
  withRateLimit(async (req: Request) => {
    try {
      const trendingTokens = await getTrendingTokens();
      const tokenIds = trendingTokens.map(trend => trend.item.id);
      const tokenPrices = await getTokenPrices(tokenIds);

      const enrichedTrends = trendingTokens.map(trend => ({
        ...trend,
        price_data: tokenPrices[trend.item.id] || null,
      }));

      return NextResponse.json({ data: enrichedTrends });
    } catch (error) {
      console.error('Token data error:', error);
      return NextResponse.json(
        { error: 'Failed to fetch token data' },
        { status: 500 }
      );
    }
  })
);

export { handler as GET };

================================================================================
File: app/blockchain-test/page.tsx
================================================================================

"use client";

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Separator } from '@/components/ui/separator';
import { Loader2, Wallet, Send, FileCode, Blocks, AlertCircle } from 'lucide-react';
import { WalletConnect } from '@/components/WalletConnect';
import { blockchainApi } from '@/lib/api/blockchain-api';
import { USE_MOCKS, USE_HARDHAT, USE_TESTNET, DEFAULT_NETWORK } from '@/lib/blockchain/config';

export default function BlockchainTestPage() {
  const [activeTab, setActiveTab] = useState('wallet');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [environment, setEnvironment] = useState('');
  
  // Transfer state
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  const [tokenAddress, setTokenAddress] = useState('');
  const [txHash, setTxHash] = useState('');
  
  // Contract deployment state
  const [templates, setTemplates] = useState<any[]>([]);
  const [selectedTemplate, setSelectedTemplate] = useState('');
  const [tokenName, setTokenName] = useState('Test Token');
  const [tokenSymbol, setTokenSymbol] = useState('TEST');
  const [tokenDecimals, setTokenDecimals] = useState('18');
  const [tokenSupply, setTokenSupply] = useState('1000000');
  
  useEffect(() => {
    // Determine environment
    let envType = 'Unknown';
    if (USE_MOCKS) envType = 'Mock Implementation';
    else if (USE_HARDHAT) envType = 'Local Hardhat Network';
    else if (USE_TESTNET) envType = 'Public Testnet (Sepolia)';
    else envType = 'Mainnet';
    
    setEnvironment(`${envType} (${DEFAULT_NETWORK})`);
    
    // Load contract templates
    loadTemplates();
  }, []);
  
  const loadTemplates = async () => {
    try {
      const templates = await blockchainApi.getContractTemplates();
      setTemplates(templates);
      if (templates.length > 0) {
        setSelectedTemplate(templates[0].id);
      }
    } catch (err) {
      console.error('Failed to load templates:', err);
    }
  };
  
  const handleTransfer = async () => {
    setLoading(true);
    setError(null);
    setSuccess(null);
    
    try {
      const result = await blockchainApi.transferTokens(
        recipient,
        amount,
        tokenAddress || undefined
      );
      
      setTxHash(result.transactionHash);
      setSuccess(`Transaction submitted: ${result.transactionHash}`);
    } catch (err: any) {
      setError(err.message || 'Transfer failed');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeploy = async () => {
    setLoading(true);
    setError(null);
    setSuccess(null);
    
    try {
      // For SimpleToken template, provide parameters
      const params = {
        name: tokenName,
        symbol: tokenSymbol,
        decimals: parseInt(tokenDecimals, 10),
        initialSupply: tokenSupply
      };
      
      const result = await blockchainApi.deployContract(
        selectedTemplate,
        params
      );
      
      setTxHash(result.transactionHash);
      setSuccess(`Contract deployed: ${result.contractAddress}`);
    } catch (err: any) {
      setError(err.message || 'Deployment failed');
    } finally {
      setLoading(false);
    }
  };
  
  const handleRefreshStatus = async () => {
    if (!txHash) return;
    
    setLoading(true);
    try {
      if (activeTab === 'transfer') {
        const status = await blockchainApi.getTransferStatus(txHash);
        setSuccess(`Status: ${status.status}, Confirmations: ${status.confirmations}`);
      } else if (activeTab === 'deploy') {
        const status = await blockchainApi.getDeploymentStatus(txHash);
        setSuccess(`Status: ${status.status}, Contract: ${status.contractAddress}, Confirmations: ${status.confirmations}`);
      }
    } catch (err: any) {
      setError(err.message || 'Failed to get status');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="container mx-auto py-10">
      <Card>
        <CardHeader>
          <CardTitle>Blockchain Testing Interface</CardTitle>
          <CardDescription>
            Test blockchain functionality in isolation
          </CardDescription>
          <div className="bg-muted p-2 rounded-md text-sm mt-2">
            <strong>Environment:</strong> {environment}
          </div>
        </CardHeader>
        <CardContent>
          <div className="mb-6">
            <WalletConnect />
          </div>
          
          <Tabs defaultValue="wallet" value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid grid-cols-3 mb-6">
              <TabsTrigger value="wallet">
                <Wallet className="h-4 w-4 mr-2" />
                Wallet
              </TabsTrigger>
              <TabsTrigger value="transfer">
                <Send className="h-4 w-4 mr-2" />
                Transfer
              </TabsTrigger>
              <TabsTrigger value="deploy">
                <FileCode className="h-4 w-4 mr-2" />
                Deploy Contract
              </TabsTrigger>
            </TabsList>
            
            <TabsContent value="wallet">
              <Card>
                <CardHeader>
                  <CardTitle>Wallet Information</CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-muted-foreground mb-4">
                    Connect your wallet using the button above to interact with blockchain functionality.
                  </p>
                </CardContent>
              </Card>
            </TabsContent>
            
            <TabsContent value="transfer">
              <Card>
                <CardHeader>
                  <CardTitle>Transfer Tokens</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="grid grid-cols-1 gap-4">
                      <div className="space-y-2">
                        <Label htmlFor="recipient">Recipient Address</Label>
                        <Input
                          id="recipient"
                          placeholder="0x..."
                          value={recipient}
                          onChange={(e) => setRecipient(e.target.value)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="amount">Amount</Label>
                        <Input
                          id="amount"
                          placeholder="1.0"
                          value={amount}
                          onChange={(e) => setAmount(e.target.value)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="tokenAddress">Token Address (Optional, leave empty for ETH)</Label>
                        <Input
                          id="tokenAddress"
                          placeholder="0x..."
                          value={tokenAddress}
                          onChange={(e) => setTokenAddress(e.target.value)}
                        />
                      </div>
                    </div>
                    
                    <Button
                      onClick={handleTransfer}
                      disabled={loading || !recipient || !amount}
                      className="w-full"
                    >
                      {loading ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Processing...
                        </>
                      ) : (
                        <>Send Transaction</>
                      )}
                    </Button>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>
            
            <TabsContent value="deploy">
              <Card>
                <CardHeader>
                  <CardTitle>Deploy Contract</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="space-y-2">
                      <Label htmlFor="template">Contract Template</Label>
                      <Select value={selectedTemplate} onValueChange={setSelectedTemplate}>
                        <SelectTrigger>
                          <SelectValue placeholder="Select template" />
                        </SelectTrigger>
                        <SelectContent>
                          {templates.length === 0 ? (
                            <SelectItem value="simple-token">Simple Token (ERC20)</SelectItem>
                          ) : (
                            templates.map(template => (
                              <SelectItem key={template.id} value={template.id}>
                                {template.name}
                              </SelectItem>
                            ))
                          )}
                        </SelectContent>
                      </Select>
                    </div>
                    
                    <Separator />
                    
                    <div className="space-y-2">
                      <Label htmlFor="tokenName">Token Name</Label>
                      <Input
                        id="tokenName"
                        value={tokenName}
                        onChange={(e) => setTokenName(e.target.value)}
                      />
                    </div>
                    
                    <div className="space-y-2">
                      <Label htmlFor="tokenSymbol">Token Symbol</Label>
                      <Input
                        id="tokenSymbol"
                        value={tokenSymbol}
                        onChange={(e) => setTokenSymbol(e.target.value)}
                      />
                    </div>
                    
                    <div className="grid grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <Label htmlFor="tokenDecimals">Decimals</Label>
                        <Input
                          id="tokenDecimals"
                          value={tokenDecimals}
                          onChange={(e) => setTokenDecimals(e.target.value)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="tokenSupply">Initial Supply</Label>
                        <Input
                          id="tokenSupply"
                          value={tokenSupply}
                          onChange={(e) => setTokenSupply(e.target.value)}
                        />
                      </div>
                    </div>
                    
                    <Button
                      onClick={handleDeploy}
                      disabled={loading || !tokenName || !tokenSymbol}
                      className="w-full"
                    >
                      {loading ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Deploying...
                        </>
                      ) : (
                        <>Deploy Contract</>
                      )}
                    </Button>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>
          </Tabs>
          
          {txHash && (
            <div className="mt-6">
              <Card>
                <CardHeader>
                  <CardTitle>Transaction Status</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="bg-muted p-2 rounded-md text-sm break-all">
                      <strong>Transaction Hash:</strong> {txHash}
                    </div>
                    
                    <Button onClick={handleRefreshStatus} disabled={loading}>
                      {loading ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ) : (
                        <Blocks className="mr-2 h-4 w-4" />
                      )}
                      Refresh Status
                    </Button>
                  </div>
                </CardContent>
              </Card>
            </div>
          )}
          
          {error && (
            <Alert variant="destructive" className="mt-6">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          {success && (
            <Alert className="mt-6 bg-green-50 border-green-300 text-green-800">
              <AlertDescription>{success}</AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>
    </div>
  );
} 

================================================================================
File: collectcode.js
================================================================================

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const DEFAULT_CONFIG = {
  extensions: ['.ts', '.tsx', '.js', '.jsx', '.json', '.css', '.sql'],
  excludeDirs: [
    'node_modules',
    '.git',
    'dist',
    '.next',
    'coverage',
    'tests',
    'scripts',
    'components/ui',
  ],
  excludeFiles: [
    '.test.',
    '.spec.',
    '.d.ts',
    '.map',
    'next-env.d.ts',
    '.gitignore',
    '.eslintrc.json',
    '.env.example',
    'components.json',
    'package-lock.json',
  ],
  excludePaths: [
    'lib/supabase.ts',
    'lib/rate-limit.ts',
    'lib/monitoring.ts',
    'lib/cache.ts',
    'lib/auth.ts',
    'scripts/test-agent1.ts',
    'scripts/test-agent2.ts',
    'scripts/test-agent3.ts',
    'scripts/test-orchestrator.ts',
    'lib/graphql/queries.ts',
    'lib/graphql/client.ts',
    'hooks/use-toast.ts',
    'components/WalletConnect.tsx',
    'components/Learn.tsx',
    'components/ContractInteraction.tsx',
    'components/Analytics.tsx',
    'app/providers.tsx',
    'app/page.tsx',
    'app/globals.css',
    'app/layout.tsx',
  ],
  maxFileSize: 1024 * 1024, // 1MB
};

function getRelativePath(fullPath, rootDir) {
  return path.relative(rootDir, fullPath);
}

function shouldExcludeFile(filePath, config) {
  const normalizedPath = path.normalize(filePath);

  if (config.excludeFiles.some((pattern) => normalizedPath.includes(pattern))) {
    return true;
  }

  if (config.excludePaths.some((excludePath) =>
    normalizedPath.includes(path.normalize(excludePath))
  )) {
    return true;
  }

  return false;
}

function shouldExcludeDir(dirPath, config) {
  const normalizedPath = path.normalize(dirPath);
  return config.excludeDirs.some((excludeDir) =>
    normalizedPath.includes(path.normalize(excludeDir))
  );
}

function collectFiles(dir, rootDir, config) {
  let results = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });

  for (const item of items) {
    const fullPath = path.join(dir, item.name);
    const relativePath = getRelativePath(fullPath, rootDir);

    if (item.isDirectory()) {
      if (!shouldExcludeDir(fullPath, config)) {
        results = results.concat(collectFiles(fullPath, rootDir, config));
      }
    } else {
      const ext = path.extname(item.name).toLowerCase();

      if (config.extensions.includes(ext) && !shouldExcludeFile(relativePath, config)) {
        const stats = fs.statSync(fullPath);
        if (stats.size <= config.maxFileSize) {
          results.push({ path: fullPath, relativePath });
        }
      }
    }
  }

  return results;
}

function collectCode(outputFile, customConfig = {}) {
  const config = { ...DEFAULT_CONFIG, ...customConfig };

  try {
    fs.writeFileSync(outputFile, '');

    const rootDir = process.cwd();
    console.log(`Processing project directory: ${rootDir}`);
    const files = collectFiles(rootDir, rootDir, config);

    files.sort((a, b) => a.relativePath.localeCompare(b.relativePath));

    files.forEach(({ path: filePath, relativePath }) => {
      const content = fs.readFileSync(filePath, 'utf8');
      const separator = '='.repeat(80);
      fs.appendFileSync(
        outputFile,
        `\n\n${separator}\nFile: ${relativePath}\n${separator}\n\n${content}`
      );
    });

    console.log('Collection complete!');
  } catch (error) {
    console.error('Error during collection:', error);
    process.exit(1);
  }
}

const isMainModule = process.argv[1] === fileURLToPath(import.meta.url);

if (isMainModule) {
  const outputFile = process.argv[2] || 'code-collection.txt';
  collectCode(outputFile);
}

export { collectCode };

================================================================================
File: components/ChatInterface.tsx
================================================================================

"use client";

import React, { useState, useRef, useEffect } from 'react';
import { Bot, Send, Loader2, RefreshCcw, ChevronDown, AlertCircle, Info, Wallet } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { v4 as uuidv4 } from 'uuid';
import { blockchainApi } from '@/lib/api/blockchain-api';
import { ContractTemplateSelector } from './ContractTemplateSelector';
import { TransactionForm } from './TransactionForm';

interface ErrorAlert {
  type: 'rate-limit' | 'api-error' | 'not-found' | 'network' | 'unknown';
  message: string;
  suggestion?: string;
  retryable: boolean;
}

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  error?: ErrorAlert;
  data?: any;
  suggestions?: string[];
  contextAnalysis?: {
    isCoherent: boolean;
    confidence: number;
  };
}

const ErrorAlertComponent = ({ error, onRetry }: { error: ErrorAlert; onRetry?: () => void }) => (
  <Alert variant="destructive" className="mb-4">
    <AlertCircle className="h-4 w-4" />
    <AlertDescription className="flex items-center justify-between">
      <div>
        <p className="font-medium">{error.message}</p>
        {error.suggestion && (
          <p className="text-sm mt-1 text-muted-foreground">{error.suggestion}</p>
        )}
      </div>
      {error.retryable && onRetry && (
        <Button variant="outline" size="sm" onClick={onRetry} className="ml-4">
          <RefreshCcw className="h-4 w-4 mr-2" />
          Retry
        </Button>
      )}
    </AlertDescription>
  </Alert>
);

const MessageComponent = ({ 
  message, 
  onRetry, 
  onSuggestionClick 
}: { 
  message: Message; 
  onRetry: () => void;
  onSuggestionClick: (suggestion: string) => void;
}) => {
  const isError = message.error !== undefined;
  const hasApiSource = message.data?.source === 'coingecko' || message.data?.source === 'coinmarketcap';
  const hasTxData = message.data?.transactionHash;
  const txStatus = message.data?.status || 'pending';

  const messageClasses = [
    "max-w-[80%] rounded-lg px-4 py-2",
    message.role === 'user' 
      ? "bg-primary text-primary-foreground" 
      : isError 
        ? "bg-destructive/10 text-destructive" 
        : "bg-muted"
  ].join(' ');

  const containerClasses = [
    "flex gap-2",
    message.role === 'user' ? "justify-end" : "justify-start"
  ].join(' ');

  return (
    <div className={containerClasses}>
      {message.role === 'assistant' && (
        <div className="w-6 h-6 rounded-full bg-primary/10 flex items-center justify-center">
          <Bot className="h-4 w-4" />
        </div>
      )}
      <div className={messageClasses}>
        <p className="whitespace-pre-wrap">{message.content}</p>
        
        {hasApiSource && (
          <div className="flex items-center gap-1 text-xs opacity-70 mt-1">
            <Info className="h-3 w-3" />
            <span>Data source: {message.data.source}</span>
          </div>
        )}

        {hasTxData && (
          <div className="mt-2 text-xs border-t pt-2">
            <div className="flex items-center gap-2">
              <span className={
                txStatus === 'success' ? 'text-green-500' :
                txStatus === 'failed' ? 'text-red-500' :
                'text-yellow-500'
              }>
                {txStatus === 'success' ? '✓' :
                 txStatus === 'failed' ? '✗' : '⟳'}
              </span>
              <span className="font-mono">{message.data.transactionHash.slice(0, 6)}...{message.data.transactionHash.slice(-4)}</span>
              {txStatus === 'pending' && (
                <Loader2 className="h-3 w-3 animate-spin ml-2" />
              )}
            </div>
          </div>
        )}

        {message.contextAnalysis && (
          <div className="flex items-center gap-2 text-xs opacity-70 mt-1 border-t pt-1">
            {message.contextAnalysis.isCoherent ? (
              <>
                <span className="text-green-500">✓</span>
                <span>Context aligned</span>
                <span className="text-muted-foreground">
                  ({(message.contextAnalysis.confidence * 100).toFixed(0)}% confidence)
                </span>
              </>
            ) : (
              <>
                <span className="text-yellow-500">⚠</span>
                <span>Context shift detected</span>
                <span className="text-muted-foreground">
                  ({(message.contextAnalysis.confidence * 100).toFixed(0)}% confidence)
                </span>
              </>
            )}
          </div>
        )}

        <p className="text-xs opacity-70 mt-1">
          {message.timestamp.toLocaleTimeString()}
        </p>

        {isError && message.error?.retryable && (
          <Button
            variant="ghost"
            size="sm"
            onClick={onRetry}
            className="mt-2"
          >
            <RefreshCcw className="h-4 w-4 mr-2" />
            Retry
          </Button>
        )}

        {message.suggestions && message.suggestions.length > 0 && (
          <div className="mt-3 space-y-2">
            <p className="text-sm font-medium">Suggested queries:</p>
            <div className="flex flex-wrap gap-2">
              {message.suggestions.map((suggestion, i) => (
                <Button
                  key={i}
                  variant="outline"
                  size="sm"
                  onClick={() => onSuggestionClick(suggestion)}
                >
                  {suggestion}
                </Button>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

const QUICK_QUERIES = [
  {
    label: 'Bitcoin price',
    query: 'What is the current price of Bitcoin?',
  },
  {
    label: 'ETH price',
    query: 'What is the current price of Ethereum?',
  },
  {
    label: 'Compare BTC & ETH',
    query: 'Compare Bitcoin and Ethereum prices',
  },
];

const BLOCKCHAIN_ACTIONS = [
  {
    label: 'Deploy ERC20 Token',
    query: 'I want to deploy an ERC20 token called MyToken with symbol MTK',
  },
  {
    label: 'Send ETH',
    query: 'I want to send 0.01 ETH',
  },
  {
    label: 'Connect Wallet',
    query: 'Connect my wallet',
  },
];

export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const [sessionId, setSessionId] = useState<string>(uuidv4());
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const [showWelcome, setShowWelcome] = useState(true);
  const [showScrollButton, setShowScrollButton] = useState(false);
  const [walletAddress, setWalletAddress] = useState<string | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [transactions, setTransactions] = useState<{
    hash: string;
    status: 'pending' | 'success' | 'failed';
    type: 'transfer' | 'deploy';
  }[]>([]);
  const [pendingTransaction, setPendingTransaction] = useState<{
    type: 'transfer' | 'deploy';
    params: any;
  } | null>(null);
  const [showTemplateSelector, setShowTemplateSelector] = useState(false);
  const [showTransactionForm, setShowTransactionForm] = useState(false);
  const [transactionFormValues, setTransactionFormValues] = useState({});

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  useEffect(() => {
    setSessionId(uuidv4());
  }, []);

  useEffect(() => {
    blockchainApi.setSessionId(sessionId);
    
    setMessages([]);
    
    try {
      const savedMessages = localStorage.getItem(`chat_messages_${sessionId}`);
      if (savedMessages) {
        const parsedMessages = JSON.parse(savedMessages);
        setMessages(parsedMessages.map((msg: any) => ({
          ...msg,
          timestamp: new Date(msg.timestamp)
        })));
      }
    } catch (error) {
      console.error('Failed to restore messages:', error);
    }
  }, [sessionId]);
  
  useEffect(() => {
    if (messages.length > 0) {
      try {
        localStorage.setItem(`chat_messages_${sessionId}`, JSON.stringify(messages));
      } catch (error) {
        console.error('Failed to save messages:', error);
      }
    }
  }, [messages, sessionId]);

  const handleError = (error: unknown): ErrorAlert => {
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        return {
          type: 'rate-limit',
          message: 'API rate limit exceeded',
          suggestion: 'Please wait a moment before trying again',
          retryable: true
        };
      }
      
      if (error.message.includes('API key')) {
        return {
          type: 'api-error',
          message: 'Service configuration error',
          suggestion: 'Please contact support if this persists',
          retryable: false
        };
      }

      if (error.message.includes('not found') || error.message.includes('No data available')) {
        return {
          type: 'not-found',
          message: 'Token not found',
          suggestion: 'Try checking the token symbol or searching for a different token',
          retryable: false
        };
      }

      if (error.message.includes('network') || error.message.includes('ECONNRESET')) {
        return {
          type: 'network',
          message: 'Network connection error',
          suggestion: 'Please check your internet connection',
          retryable: true
        };
      }

      return {
        type: 'unknown',
        message: error.message,
        retryable: true
      };
    }

    return {
      type: 'unknown',
      message: 'An unexpected error occurred',
      retryable: true
    };
  };

  const handleSubmit = async (e: React.FormEvent | string, isRetry = false) => {
    if (typeof e !== 'string' && e?.preventDefault) {
      e.preventDefault();
    }
    const queryText = typeof e === 'string' ? e : input;
    
    if (!queryText.trim() || !sessionId || isLoading) return;

    if (!isRetry) {
      setRetryCount(0);
    }

    const userMessage: Message = {
      role: 'user',
      content: queryText,
      timestamp: new Date(),
    };

    if (!isRetry) {
      setMessages(prev => [...prev, userMessage]);
    }
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          query: queryText,
          sessionId
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: `Server error: ${response.status}` }));
        throw new Error(errorData.error || `Server error: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.error) {
        throw new Error(data.error);
      }

      const assistantMessage: Message = {
        role: 'assistant',
        content: data.response,
        timestamp: new Date(),
        data: data.data,
        suggestions: data.suggestions,
        contextAnalysis: data.contextAnalysis
      };

      setMessages(prev => {
        if (isRetry) {
          return [...prev.slice(0, -1), assistantMessage];
        }
        return [...prev, assistantMessage];
      });
    } catch (error) {
      const errorAlert = handleError(error);
      
      const errorMessage: Message = {
        role: 'assistant',
        content: errorAlert.message + (errorAlert.suggestion ? `\n\n${errorAlert.suggestion}` : ''),
        timestamp: new Date(),
        error: errorAlert,
      };

      setMessages(prev => {
        if (isRetry) {
          return [...prev.slice(0, -1), errorMessage];
        }
        return [...prev, errorMessage];
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleSuggestionClick = (suggestion: string) => {
    handleSubmit(suggestion);
  };

  const connectWallet = async () => {
    try {
      blockchainApi.setSessionId(sessionId);
      
      const address = await blockchainApi.connectWallet('metamask');
      
      const newMessage: Message = {
        role: 'assistant',
        content: `✅ Wallet connected successfully!\n\nAddress: \`${address.slice(0, 6)}...${address.slice(-4)}\`\n\nYou can now perform blockchain operations like deploying contracts and sending transactions.`,
        timestamp: new Date(),
        data: {
          blockchain: {
            actionType: 'CONNECT_WALLET',
            address
          }
        }
      };
      
      setMessages(prev => [...prev, newMessage]);
      
    } catch (error) {
      console.error('Wallet connection error:', error);
      
      const newMessage: Message = {
        role: 'assistant',
        content: 'Failed to connect wallet. Please try again.',
        timestamp: new Date(),
        error: {
          type: 'api-error',
          message: 'Failed to connect wallet',
          suggestion: error instanceof Error ? error.message : 'Please check if MetaMask is installed and unlocked.',
          retryable: true
        }
      };
      
      setMessages(prev => [...prev, newMessage]);
    }
  };

  const checkTransactionStatus = async (hash: string, type: 'transfer' | 'deploy') => {
    try {
      if (type === 'transfer') {
        const result = await blockchainApi.getTransferStatus(hash);
        return {
          hash,
          status: result.status as 'pending' | 'success' | 'failed',
          type
        };
      } else {
        const result = await blockchainApi.getDeploymentStatus(hash);
        return {
          hash,
          status: result.deploymentStatus as 'pending' | 'success' | 'failed',
          type
        };
      }
    } catch (error) {
      console.error('Error checking transaction status:', error);
      return {
        hash,
        status: 'failed' as const,
        type
      };
    }
  };

  useEffect(() => {
    const txMessages = messages.filter(msg => msg.data?.transactionHash);
    const newTxs = txMessages.map(msg => ({
      hash: msg.data.transactionHash as string,
      status: 'pending' as const,
      type: msg.content.includes('Contract') ? 'deploy' as const : 'transfer' as const
    })).filter(tx => !transactions.some(t => t.hash === tx.hash));
    
    if (newTxs.length > 0) {
      setTransactions(prev => [...prev, ...newTxs]);
    }
    
    const interval = setInterval(async () => {
      const pending = transactions.filter(tx => tx.status === 'pending');
      if (pending.length === 0) {
        clearInterval(interval);
        return;
      }
      
      const updates = await Promise.all(
        pending.map(tx => checkTransactionStatus(tx.hash, tx.type))
      );
      
      setTransactions(prev => 
        prev.map(tx => {
          const update = updates.find(u => u.hash === tx.hash);
          return update || tx;
        })
      );
      
      updates
        .filter(u => u.status !== 'pending')
        .forEach(tx => {
          setMessages(prev => [...prev, {
            role: 'assistant',
            content: tx.status === 'success'
              ? `${tx.type === 'deploy' ? 'Contract deployment' : 'Transaction'} successful! Hash: ${tx.hash}`
              : `${tx.type === 'deploy' ? 'Contract deployment' : 'Transaction'} failed. Hash: ${tx.hash}`,
            timestamp: new Date(),
            data: { transactionHash: tx.hash, status: tx.status }
          }]);
        });
        
    }, 5000);
    
    return () => clearInterval(interval);
  }, [messages, transactions]);

  useEffect(() => {
    const lastAssistantMsg = messages
      .filter(msg => msg.role === 'assistant')
      .pop();
      
    if (lastAssistantMsg?.data?.blockchain?.actionType === 'TRANSFER_TOKENS') {
      setPendingTransaction({
        type: 'transfer',
        params: lastAssistantMsg.data.blockchain.data
      });
    } else if (lastAssistantMsg?.data?.blockchain?.actionType === 'DEPLOY_CONTRACT') {
      setPendingTransaction({
        type: 'deploy',
        params: lastAssistantMsg.data.blockchain.data
      });
    }
  }, [messages]);

  useEffect(() => {
    const lastUserMsg = messages
      .filter(msg => msg.role === 'user')
      .pop();
      
    if (lastUserMsg) {
      const content = lastUserMsg.content.toLowerCase();
      
      if (content.includes('deploy') && 
          content.includes('contract') && 
          !content.includes('erc20') &&
          !content.includes('erc721') &&
          !content.includes('erc1155')) {
        setShowTemplateSelector(true);
      }
      
      if ((content.includes('send') || 
           content.includes('transfer')) &&
          !content.match(/0x[a-fA-F0-9]{40}/)) {
        
        setShowTransactionForm(true);
        
        const amount = content.match(/\d+(\.\d+)?/)?.[0];
        if (amount) {
          setTransactionFormValues({ amount });
        }
      }
    }
  }, [messages]);

  return (
    <Card className="h-[calc(100vh-12rem)]">
      <CardHeader className="border-b">
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Bot className="h-5 w-5" />
            Blockchain Assistant
          </div>
          <div className="flex items-center gap-2">
            {walletAddress ? (
              <div className="flex items-center gap-2 text-xs text-muted-foreground py-1 px-3 bg-muted rounded-full">
                <Wallet className="h-3 w-3" />
                {walletAddress.slice(0, 6)}...{walletAddress.slice(-4)}
              </div>
            ) : (
              <Button 
                size="sm" 
                variant="outline" 
                onClick={connectWallet} 
                disabled={isConnecting}
              >
                <Wallet className="h-4 w-4 mr-2" />
                {isConnecting ? 'Connecting...' : 'Connect Wallet'}
              </Button>
            )}
          </div>
        </CardTitle>
      </CardHeader>
      <CardContent className="flex flex-col h-[calc(100%-5rem)]">
        {pendingTransaction && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-background p-6 rounded-lg max-w-md w-full">
              <h3 className="text-lg font-medium mb-4">
                Confirm {pendingTransaction.type === 'transfer' ? 'Transaction' : 'Contract Deployment'}
              </h3>
              
              {pendingTransaction.type === 'transfer' && (
                <div className="space-y-2 mb-4">
                  <p><span className="font-medium">Send:</span> {pendingTransaction.params.amount} {pendingTransaction.params.tokenAddress ? 'tokens' : 'ETH'}</p>
                  <p><span className="font-medium">To:</span> {pendingTransaction.params.to}</p>
                  {pendingTransaction.params.tokenAddress && (
                    <p><span className="font-medium">Token:</span> {pendingTransaction.params.tokenAddress}</p>
                  )}
                </div>
              )}
              
              {pendingTransaction.type === 'deploy' && (
                <div className="space-y-2 mb-4">
                  <p><span className="font-medium">Contract:</span> {pendingTransaction.params.templateId}</p>
                  <p><span className="font-medium">Name:</span> {pendingTransaction.params.templateParams?.name}</p>
                  <p><span className="font-medium">Symbol:</span> {pendingTransaction.params.templateParams?.symbol}</p>
                </div>
              )}
              
              <div className="flex gap-2 justify-end">
                <Button 
                  variant="outline" 
                  onClick={() => setPendingTransaction(null)}
                >
                  Cancel
                </Button>
                <Button 
                  onClick={async () => {
                    try {
                      let result;
                      if (pendingTransaction.type === 'transfer') {
                        result = await blockchainApi.transferTokens(
                          pendingTransaction.params.to,
                          pendingTransaction.params.amount,
                          pendingTransaction.params.tokenAddress
                        );
                      } else {
                        result = await blockchainApi.deployContract(
                          pendingTransaction.params.templateId,
                          pendingTransaction.params.templateParams
                        );
                      }
                      
                      setMessages(prev => [...prev, {
                        role: 'assistant',
                        content: pendingTransaction.type === 'transfer' 
                          ? `Transaction sent with hash: ${result.transactionHash}` 
                          : `Contract deployment initiated with hash: ${result.transactionHash}`,
                        timestamp: new Date(),
                        data: { transactionHash: result.transactionHash }
                      }]);
                    } catch (error) {
                      console.error('Transaction error:', error);
                      setMessages(prev => [...prev, {
                        role: 'assistant',
                        content: `Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                        timestamp: new Date(),
                        error: {
                          type: 'api-error',
                          message: 'Transaction failed',
                          retryable: true
                        }
                      }]);
                    } finally {
                      setPendingTransaction(null);
                    }
                  }}
                >
                  Confirm
                </Button>
              </div>
            </div>
          </div>
        )}

        {showTemplateSelector && (
          <ContractTemplateSelector
            onSelect={(templateId) => {
              handleSubmit(`I want to deploy a ${templateId} contract`);
              setShowTemplateSelector(false);
            }}
            onCancel={() => setShowTemplateSelector(false)}
          />
        )}

        {showTransactionForm && (
          <TransactionForm
            initialValues={transactionFormValues}
            onSubmit={(data) => {
              const query = `I want to send ${data.amount} ${data.tokenAddress ? 'tokens' : 'ETH'} to ${data.to}${data.tokenAddress ? ' using token ' + data.tokenAddress : ''}`;
              handleSubmit(query);
              setShowTransactionForm(false);
            }}
            onCancel={() => setShowTransactionForm(false)}
          />
        )}

        <div className="flex-1 overflow-y-auto space-y-4 mb-4 p-4">
          {messages.length === 0 && (
            <div className="text-center text-muted-foreground p-4">
              <p>👋 Hi! I can help you explore blockchain data and perform transactions.</p>
              <p className="mt-2">Try asking about token prices or connecting your wallet to make transactions.</p>
            </div>
          )}
          {messages.map((message, index) => (
            <MessageComponent
              key={index}
              message={message}
              onRetry={() => handleSubmit(messages[messages.length - 2].content, true)}
              onSuggestionClick={handleSuggestionClick}
            />
          ))}
          {isLoading && (
            <div className="flex gap-2">
              <div className="w-6 h-6 rounded-full bg-primary/10 flex items-center justify-center">
                <Bot className="h-4 w-4" />
              </div>
              <div className="bg-muted rounded-lg px-4 py-2">
                <div className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <p>Processing your request...</p>
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
        <div className="border-t pt-4 px-4">
          <form onSubmit={handleSubmit} className="flex gap-2">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="icon">
                  <ChevronDown className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start">
                {QUICK_QUERIES.map((item, index) => (
                  <DropdownMenuItem
                    key={index}
                    onClick={() => handleSubmit(item.query)}
                  >
                    {item.label}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
            
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="icon">
                  <Wallet className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start">
                {BLOCKCHAIN_ACTIONS.map((item, index) => (
                  <DropdownMenuItem
                    key={index}
                    onClick={() => walletAddress || item.label === 'Connect Wallet' ? 
                                   handleSubmit(item.query) : 
                                   connectWallet()}
                    disabled={!walletAddress && item.label !== 'Connect Wallet'}
                  >
                    {item.label}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
            
            <Input
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Ask about tokens or blockchain operations..."
              disabled={isLoading}
              className="flex-1"
            />
            <Button type="submit" disabled={isLoading || !input.trim()}>
              <Send className="h-4 w-4" />
            </Button>
          </form>
        </div>
      </CardContent>
    </Card>
  );
}

================================================================================
File: components/ContractTemplateSelector.tsx
================================================================================

"use client";

import { useEffect, useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { blockchainApi } from '@/lib/api/blockchain-api';
import { Loader2 } from 'lucide-react';

type ContractTemplate = {
  id: string;
  name: string;
  description: string;
  category: string;
};

interface ContractTemplateSelectorProps {
  onSelect: (templateId: string) => void;
  onCancel: () => void;
}

export function ContractTemplateSelector({ onSelect, onCancel }: ContractTemplateSelectorProps) {
  const [templates, setTemplates] = useState<ContractTemplate[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const loadTemplates = async () => {
      try {
        const allTemplates = await blockchainApi.getContractTemplates();
        setTemplates(allTemplates);
      } catch (error) {
        console.error('Error loading templates:', error);
        // Fallback templates if API fails
        setTemplates([
          {
            id: 'ERC20',
            name: 'ERC20 Token',
            description: 'Standard fungible token for currencies and assets',
            category: 'token'
          },
          {
            id: 'ERC721',
            name: 'ERC721 NFT',
            description: 'Non-fungible token for unique digital assets',
            category: 'nft'
          },
          {
            id: 'ERC1155',
            name: 'ERC1155 Multi-Token',
            description: 'Multi-token standard for both fungible and non-fungible tokens',
            category: 'token'
          }
        ]);
      } finally {
        setLoading(false);
      }
    };
    
    loadTemplates();
  }, []);
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <Card className="max-w-2xl w-full max-h-[80vh] overflow-auto">
        <CardHeader>
          <CardTitle>Select Contract Template</CardTitle>
          <CardDescription>
            Choose a template to deploy your smart contract
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {loading ? (
              <div className="col-span-2 py-8 text-center">
                <div className="flex justify-center">
                  <Loader2 className="h-8 w-8 animate-spin" />
                </div>
                <p className="mt-4">Loading templates...</p>
              </div>
            ) : (
              <>
                {templates.map((template) => (
                  <Card 
                    key={template.id} 
                    className="cursor-pointer hover:border-primary transition-colors"
                    onClick={() => onSelect(template.id)}
                  >
                    <CardHeader className="p-4">
                      <CardTitle className="text-base">{template.name}</CardTitle>
                      <CardDescription>{template.category}</CardDescription>
                    </CardHeader>
                    <CardContent className="p-4 pt-0">
                      <p className="text-sm">{template.description}</p>
                    </CardContent>
                  </Card>
                ))}
              </>
            )}
          </div>
          
          <div className="flex justify-end mt-6">
            <Button variant="outline" onClick={onCancel}>
              Cancel
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
} 

================================================================================
File: components/ErrorBoundary.tsx
================================================================================

"use client";

import React from 'react';
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { AlertCircle, RefreshCcw, Home } from 'lucide-react';
import Link from 'next/link';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log error to monitoring service
    console.error('Error caught by boundary:', error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <Card className="max-w-lg mx-auto my-8 shadow-lg">
          <CardHeader className="space-y-1">
            <CardTitle className="flex items-center gap-2 text-destructive">
              <AlertCircle className="h-5 w-5" />
              Something went wrong
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-muted-foreground">
              {process.env.NODE_ENV === 'development' 
                ? this.state.error?.message || 'An unexpected error occurred'
                : 'An unexpected error occurred. Our team has been notified.'}
            </p>
            {process.env.NODE_ENV === 'development' && this.state.error?.stack && (
              <pre className="p-4 bg-muted rounded-lg text-xs overflow-auto max-h-[200px]">
                {this.state.error.stack}
              </pre>
            )}
          </CardContent>
          <CardFooter className="flex gap-2">
            <Button
              onClick={() => window.location.reload()}
              variant="default"
              size="sm"
            >
              <RefreshCcw className="h-4 w-4 mr-2" />
              Retry
            </Button>
            <Link href="/" passHref>
              <Button
                variant="outline"
                size="sm"
                onClick={this.handleReset}
              >
                <Home className="h-4 w-4 mr-2" />
                Back to Home
              </Button>
            </Link>
          </CardFooter>
        </Card>
      );
    }

    return this.props.children;
  }
}

================================================================================
File: components/TransactionForm.tsx
================================================================================

"use client";

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

interface TransactionFormProps {
  onSubmit: (data: any) => void;
  onCancel: () => void;
  initialValues?: {
    recipient?: string;
    amount?: string;
    tokenAddress?: string;
  };
}

export function TransactionForm({ onSubmit, onCancel, initialValues = {} }: TransactionFormProps) {
  const [formData, setFormData] = useState({
    recipient: initialValues.recipient || '',
    amount: initialValues.amount || '0.01',
    tokenAddress: initialValues.tokenAddress || '',
    type: initialValues.tokenAddress ? 'token' : 'eth'
  });
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit({
      to: formData.recipient,
      amount: formData.amount,
      tokenAddress: formData.type === 'token' ? formData.tokenAddress : null
    });
  };
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <Card className="max-w-md w-full">
        <CardHeader>
          <CardTitle>Send Transaction</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit}>
            <Tabs defaultValue={formData.type} onValueChange={value => setFormData(prev => ({ ...prev, type: value }))}>
              <TabsList className="grid grid-cols-2 mb-4">
                <TabsTrigger value="eth">Send ETH</TabsTrigger>
                <TabsTrigger value="token">Send Tokens</TabsTrigger>
              </TabsList>
              
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="recipient">Recipient Address</Label>
                  <Input
                    id="recipient"
                    name="recipient"
                    value={formData.recipient}
                    onChange={handleChange}
                    placeholder="0x..."
                    required
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="amount">Amount</Label>
                  <Input
                    id="amount"
                    name="amount"
                    type="number"
                    step="0.000001"
                    min="0"
                    value={formData.amount}
                    onChange={handleChange}
                    required
                  />
                </div>
                
                <TabsContent value="token">
                  <div className="space-y-2">
                    <Label htmlFor="tokenAddress">Token Contract Address</Label>
                    <Input
                      id="tokenAddress"
                      name="tokenAddress"
                      value={formData.tokenAddress}
                      onChange={handleChange}
                      placeholder="0x..."
                      required={formData.type === 'token'}
                    />
                  </div>
                </TabsContent>
              </div>
              
              <div className="flex justify-end gap-2 mt-6">
                <Button type="button" variant="outline" onClick={onCancel}>
                  Cancel
                </Button>
                <Button type="submit">
                  Send
                </Button>
              </div>
            </Tabs>
          </form>
        </CardContent>
      </Card>
    </div>
  );
} 

================================================================================
File: hardhat.config.ts
================================================================================

import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";

// Load environment variables if available
const PRIVATE_KEY = process.env.PRIVATE_KEY || "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"; // Default hardhat account
const SEPOLIA_RPC_URL = process.env.SEPOLIA_RPC_URL || "https://eth-sepolia.g.alchemy.com/v2/demo";
const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY || "";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    hardhat: {
      chainId: 1337, // Standard for local hardhat network
      mining: {
        auto: true,
        interval: 5000, // ms
      },
    },
    localhost: {
      url: "http://127.0.0.1:8545",
    },
    sepolia: {
      url: SEPOLIA_RPC_URL,
      accounts: [PRIVATE_KEY],
    },
  },
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts",
  },
  etherscan: {
    apiKey: ETHERSCAN_API_KEY,
  },
  gasReporter: {
    enabled: process.env.REPORT_GAS !== undefined,
    currency: "USD",
  },
};

export default config; 

================================================================================
File: jsconfig.json
================================================================================

{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  }
} 

================================================================================
File: lib/agents/aggregator.ts
================================================================================

import { RobustAnalysis, AggregatorSpec } from './types';
import { getTokenDetails, getTokenPrices } from '@/lib/token-data';

export async function buildAggregatorCalls(analysis: RobustAnalysis): Promise<AggregatorSpec> {
  console.log('buildAggregatorCalls: Starting with analysis:', {
    primaryIntent: analysis.classification.primaryIntent,
    tokens: analysis.queryAnalysis.detectedTokens,
    needsApiCall: analysis.classification.needsApiCall
  });

  const spec: AggregatorSpec = {
    primary: {},
    fallback: {}
  };

  // Handle different intent types
  switch (analysis.classification.primaryIntent) {
    case 'MARKET_DATA':
    case 'COMPARISON':
    case 'DEFI':
      // Market data logic with actual API calls
      if (analysis.classification.needsApiCall) {
        spec.primary.coingecko = {
          method: 'GET',
          tokens: analysis.queryAnalysis.detectedTokens,
          timeframe: analysis.queryAnalysis.timeContext || 'current'
        };
      }
      break;

    case 'NEWS_EVENTS':
    case 'REGULATORY':
      if (analysis.classification.requiresWebSearch) {
        const contentTypes = analysis.dataRequirements.newsData?.types || ['announcement'];
        const timeRange = analysis.dataRequirements.newsData?.timeRange;
        
        spec.primary.news = {
          method: 'GET',
          contentTypes,
          timeRange,
          tokens: analysis.queryAnalysis.detectedTokens
        };

        // Add regulatory data requirements if needed
        if (analysis.classification.primaryIntent === 'REGULATORY') {
          spec.primary.regulatory = {
            method: 'GET',
            jurisdiction: 'global',
            timeRange
          };
        }
      }
      break;

    case 'SECURITY':
      if (analysis.classification.requiresWebSearch) {
        spec.primary.security = {
          method: 'GET',
          contentTypes: ['security_incident'],
          tokens: analysis.queryAnalysis.detectedTokens
        };
      }
      break;
  }

  return spec;
}

export async function executeAggregatorCalls(spec: AggregatorSpec) {
  console.log('executeAggregatorCalls: Starting with spec:', spec);
  const results: Record<string, any> = {
    primary: {},
    fallback: {}
  };

  try {
    // Validate spec
    if (!spec || typeof spec !== 'object') {
      throw new Error('Invalid aggregator specification');
    }

    // Handle CoinGecko data requests
    if (spec.primary.coingecko) {
      const { tokens } = spec.primary.coingecko;
      
      // Validate tokens array
      if (!Array.isArray(tokens)) {
        throw new Error('Invalid tokens specification');
      }

      if (tokens.length === 0) {
        throw new Error('No tokens specified for price lookup');
      }

      if (tokens.length > 5) {
        throw new Error('Too many tokens requested (maximum 5)');
      }

      // Get token details for each token with error handling
      const tokenDetailsPromises = tokens.map(async token => {
        try {
          if (!token || typeof token !== 'string') {
            throw new Error(`Invalid token: ${token}`);
          }

          const details = await getTokenDetails(token);
          if (!details) {
            console.warn(`No details found for token: ${token}`);
            return null;
          }
          return details;
        } catch (error) {
          console.error(`Error fetching details for token ${token}:`, error);
          return null;
        }
      });

      const tokenDetails = await Promise.all(tokenDetailsPromises);
      
      // Filter out failed lookups and get valid token IDs
      const validTokenDetails = tokenDetails.filter(detail => detail !== null);
      
      if (validTokenDetails.length === 0) {
        throw new Error('No valid token details found');
      }

      const tokenIds = validTokenDetails
        .filter((detail): detail is NonNullable<typeof detail> => detail !== null)
        .map(detail => detail.id);
      
      // Get token prices with error handling
      try {
        const prices = await getTokenPrices(tokenIds);
        
        results.primary.coingecko = {
          tokenDetails: validTokenDetails,
          prices
        };
      } catch (error) {
        console.error('Error fetching token prices:', error);
        throw new Error('Failed to fetch token prices');
      }
    }

    // Handle news data requests
    if (spec.primary.news) {
      // News data would be handled by a separate service
      results.primary.news = {
        status: 'success',
        message: 'News data would be fetched here'
      };
    }

    // Handle regulatory data requests
    if (spec.primary.regulatory) {
      // Regulatory data would be handled by a separate service
      results.primary.regulatory = {
        status: 'success',
        message: 'Regulatory data would be fetched here'
      };
    }

    // Handle security data requests
    if (spec.primary.security) {
      // Security data would be handled by a separate service
      results.primary.security = {
        status: 'success',
        message: 'Security data would be fetched here'
      };
    }

    return results;

  } catch (error) {
    console.error('Error executing aggregator calls:', error);
    
    // Enhanced error handling with specific error types
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('API rate limit exceeded. Please try again in a moment.');
      }
      if (error.message.includes('API key')) {
        throw new Error('API configuration error. Please check your settings.');
      }
      if (error.message.includes('No valid token')) {
        throw new Error('Could not find data for the requested tokens. Please verify the token symbols.');
      }
      if (error.message.includes('Too many tokens')) {
        throw new Error('Please request fewer tokens (maximum 5 at a time).');
      }
      if (error.message.includes('Invalid token')) {
        throw new Error('Invalid token symbol provided. Please check the token name.');
      }
    }
    
    throw new Error('Failed to fetch token data. Please try again.');
  }
}

================================================================================
File: lib/agents/blockchain-orchestrator.ts
================================================================================

import { contractDeploymentAgent, DeploymentParams, DeploymentResult } from './deployment/contract-deployment-agent';
import { tokenTransferAgent, TransferParams, TransferResult } from './transaction/token-transfer-agent';
import { WalletConnectionOptions } from '../blockchain/wallet-integration';
import { sessionManager } from '../blockchain/session-manager';
import { tokenRegistry, TokenInfo } from '../blockchain/token-registry';
import { getTemplate, ContractTemplate } from './deployment/contract-templates';

// Helper functions for contract templates
async function getAllTemplates(): Promise<ContractTemplate[]> {
  // In a real implementation, this would fetch all templates from a database or API
  // For now, we'll return a simple array of templates
  const templates: ContractTemplate[] = [];
  
  const erc20Template = await getTemplate('ERC20');
  const erc721Template = await getTemplate('ERC721');
  const erc1155Template = await getTemplate('ERC1155');
  
  if (erc20Template) templates.push(erc20Template);
  if (erc721Template) templates.push(erc721Template);
  if (erc1155Template) templates.push(erc1155Template);
  
  return templates;
}

async function getTemplatesByCategory(category: string): Promise<ContractTemplate[]> {
  // In a real implementation, this would filter templates by category
  const allTemplates = await getAllTemplates();
  return allTemplates.filter(template => template.category === category);
}

// Blockchain action types
export type BlockchainActionType = 
  | 'CONNECT_WALLET'
  | 'DISCONNECT_WALLET'
  | 'DEPLOY_CONTRACT'
  | 'TRANSFER_TOKENS'
  | 'GET_TOKEN_INFO'
  | 'GET_CONTRACT_TEMPLATES'
  | 'GET_DEPLOYMENT_STATUS'
  | 'GET_TRANSFER_STATUS';

// Blockchain action parameters
export interface BlockchainActionParams {
  actionType: BlockchainActionType;
  sessionId?: string;
  walletParams?: WalletConnectionOptions;
  deploymentParams?: DeploymentParams;
  transferParams?: TransferParams;
  tokenAddress?: `0x${string}`;
  chainId?: number;
  templateCategory?: string;
  transactionHash?: `0x${string}`;
}

// Blockchain action result
export interface BlockchainActionResult {
  success: boolean;
  actionType: BlockchainActionType;
  data?: any;
  error?: string;
}

export class BlockchainOrchestrator {
  // Handle blockchain actions
  async handleAction(params: BlockchainActionParams): Promise<BlockchainActionResult> {
    try {
      // Ensure a session ID is provided for operations that require it
      const sessionId = params.sessionId || 'default-session';
      
      switch (params.actionType) {
        case 'CONNECT_WALLET':
          return await this.connectWallet(sessionId, params.walletParams!);
          
        case 'DISCONNECT_WALLET':
          return this.disconnectWallet(sessionId);
          
        case 'DEPLOY_CONTRACT':
          return await this.deployContract(sessionId, params.deploymentParams!);
          
        case 'TRANSFER_TOKENS':
          return await this.transferTokens(sessionId, params.transferParams!);
          
        case 'GET_TOKEN_INFO':
          return await this.getTokenInfo(params.tokenAddress!, params.chainId!);
          
        case 'GET_CONTRACT_TEMPLATES':
          return await this.getContractTemplates(params.templateCategory);
          
        case 'GET_DEPLOYMENT_STATUS':
          return this.getDeploymentStatus(params.transactionHash!);
          
        case 'GET_TRANSFER_STATUS':
          return this.getTransferStatus(params.transactionHash!);
          
        default:
          throw new Error(`Unknown action type: ${params.actionType}`);
      }
    } catch (error) {
      console.error('Blockchain action error:', error);
      return {
        success: false,
        actionType: params.actionType,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
  
  // Connect wallet
  async connectWallet(sessionId: string, options: WalletConnectionOptions): Promise<BlockchainActionResult> {
    try {
      const address = await sessionManager.connectWallet(
        sessionId,
        options.type,
        options.chainId
      );
      
      return {
        success: true,
        actionType: 'CONNECT_WALLET',
        data: {
          address
        }
      };
    } catch (error) {
      console.error('Wallet connection error:', error);
      return {
        success: false,
        actionType: 'CONNECT_WALLET',
        error: `Failed to connect wallet: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
  
  // Disconnect wallet
  disconnectWallet(sessionId: string): BlockchainActionResult {
    try {
      sessionManager.removeConnection(sessionId);
      
      return {
        success: true,
        actionType: 'DISCONNECT_WALLET'
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'DISCONNECT_WALLET',
        error: `Failed to disconnect wallet: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
  
  // Deploy contract
  async deployContract(sessionId: string, params: DeploymentParams): Promise<BlockchainActionResult> {
    try {
      // Get wallet service for the session
      const walletService = sessionManager.getWalletService(sessionId);
      
      if (!walletService) {
        throw new Error('Wallet not connected');
      }
      
      // Use the contract deployment agent with the session's wallet
      const result = await contractDeploymentAgent.deployContract(walletService, params);
      
      return {
        success: true,
        actionType: 'DEPLOY_CONTRACT',
        data: result
      };
    } catch (error) {
      console.error('Contract deployment error:', error);
      return {
        success: false,
        actionType: 'DEPLOY_CONTRACT',
        error: `Failed to deploy contract: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
  
  // Transfer tokens
  async transferTokens(sessionId: string, params: TransferParams): Promise<BlockchainActionResult> {
    try {
      // Get wallet service for the session
      const walletService = sessionManager.getWalletService(sessionId);
      
      if (!walletService) {
        throw new Error('Wallet not connected');
      }
      
      // Use the token transfer agent with the session's wallet
      const result = await tokenTransferAgent.transferTokens(walletService, params);
      
      return {
        success: true,
        actionType: 'TRANSFER_TOKENS',
        data: result
      };
    } catch (error) {
      console.error('Token transfer error:', error);
      return {
        success: false,
        actionType: 'TRANSFER_TOKENS',
        error: `Failed to transfer tokens: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  // Get token info
  private async getTokenInfo(tokenAddress: `0x${string}`, chainId: number): Promise<BlockchainActionResult> {
    try {
      let tokenInfo = tokenRegistry.getToken(tokenAddress, chainId);
      
      if (!tokenInfo) {
        // Try to load token info from blockchain
        tokenInfo = await tokenRegistry.loadTokenInfo(tokenAddress, chainId);
      }
      
      return {
        success: true,
        actionType: 'GET_TOKEN_INFO',
        data: tokenInfo
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_TOKEN_INFO',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get contract templates
  private async getContractTemplates(category?: string): Promise<BlockchainActionResult> {
    try {
      let templates: ContractTemplate[];
      
      if (category) {
        templates = await getTemplatesByCategory(category);
      } else {
        templates = await getAllTemplates();
      }
      
      return {
        success: true,
        actionType: 'GET_CONTRACT_TEMPLATES',
        data: templates
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_CONTRACT_TEMPLATES',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get deployment status
  private getDeploymentStatus(transactionHash: `0x${string}`): BlockchainActionResult {
    try {
      const deployment = contractDeploymentAgent.getDeployment(transactionHash);
      
      if (!deployment) {
        throw new Error(`Deployment with hash ${transactionHash} not found`);
      }
      
      return {
        success: true,
        actionType: 'GET_DEPLOYMENT_STATUS',
        data: deployment
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_DEPLOYMENT_STATUS',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Get transfer status
  private getTransferStatus(transactionHash: `0x${string}`): BlockchainActionResult {
    try {
      const transfer = tokenTransferAgent.getTransfer(transactionHash);
      
      if (!transfer) {
        throw new Error(`Transfer with hash ${transactionHash} not found`);
      }
      
      return {
        success: true,
        actionType: 'GET_TRANSFER_STATUS',
        data: transfer
      };
    } catch (error) {
      return {
        success: false,
        actionType: 'GET_TRANSFER_STATUS',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
}

// Export singleton instance
export const blockchainOrchestrator = new BlockchainOrchestrator(); 

================================================================================
File: lib/agents/deployment/contract-deployment-agent.ts
================================================================================

import { parseAbi, encodeAbiParameters } from 'viem';
import { walletService, TransactionOptions, WalletIntegrationService } from '../../blockchain/wallet-integration';
import { publicClient } from '../../blockchain/providers';
import { validateContract } from '../security/contract-validator';
import { ContractTemplate, getTemplate } from './contract-templates';
import { compile } from './solidity-compiler';

export interface DeploymentParams {
  // Contract source or template information
  source?: string;
  templateId?: string;
  templateParams?: Record<string, any>;
  
  // Constructor parameters (if any)
  constructorArgs?: any[];
  
  // Deployment options
  value?: string; // ETH value in string format (e.g. "0.1")
  gasLimit?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
  
  // Verification options
  verify?: boolean;
  compilerVersion?: string;
  optimizationRuns?: number;
}

export interface DeploymentResult {
  transactionHash: `0x${string}`;
  contractAddress: `0x${string}` | null;
  deploymentStatus: 'pending' | 'success' | 'failed';
  abi: any[];
  bytecode: `0x${string}`;
  constructorArgs: any[];
  gasUsed?: bigint;
  effectiveGasPrice?: bigint;
  receipt?: any;
  error?: string;
}

export class ContractDeploymentAgent {
  private deployments = new Map<string, DeploymentResult>();

  // Generate contract from template or use provided source
  private async getContractSource(params: DeploymentParams): Promise<string> {
    // If source is provided directly, use it
    if (params.source) {
      return params.source;
    }
    
    // If template ID is provided, get template and fill parameters
    if (params.templateId) {
      const template = await getTemplate(params.templateId);
      if (!template) {
        throw new Error(`Template with ID ${params.templateId} not found`);
      }
      
      // Replace template parameters
      let source = template.source;
      if (params.templateParams) {
        for (const [key, value] of Object.entries(params.templateParams)) {
          const placeholder = `{{${key}}}`;
          source = source.replace(new RegExp(placeholder, 'g'), String(value));
        }
      }
      
      return source;
    }
    
    throw new Error('Either source or templateId must be provided');
  }

  // Deploy a contract
  async deployContract(
    walletServiceInstance: WalletIntegrationService,
    params: DeploymentParams
  ): Promise<DeploymentResult> {
    try {
      // Check if wallet is connected
      if (!walletServiceInstance.isConnected()) {
        throw new Error('Wallet not connected');
      }
      
      // Get contract source
      const source = await this.getContractSource(params);
      
      // Compile contract
      const compilation = await compile(source);
      
      // Check for compilation errors
      if (compilation.errors && compilation.errors.length > 0) {
        const errorMessages = compilation.errors
          .filter(error => error.severity === 'error')
          .map(error => error.message)
          .join('\n');
        
        throw new Error(`Compilation failed:\n${errorMessages}`);
      }
      
      // Get contract info
      const contractName = Object.keys(compilation.contracts)[0];
      const contract = compilation.contracts[contractName];
      
      // Ensure contract has bytecode
      if (!contract.evm || !contract.evm.bytecode || !contract.evm.bytecode.object) {
        throw new Error('Compiled contract has no bytecode');
      }
      
      // Get ABI and bytecode
      const abi = contract.abi;
      const bytecode = `0x${contract.evm.bytecode.object}` as `0x${string}`;
      
      // Validate contract
      const securityCheck = validateContract(abi, bytecode);
      if (!securityCheck.valid) {
        throw new Error(`Contract security check failed: ${securityCheck.issues.map(i => i.title).join(', ')}`);
      }
      
      // Prepare constructor args
      const constructorArgs = params.constructorArgs || [];
      
      // Prepare transaction options
      const txOptions: any = {
        data: bytecode
      };
      
      // Add value if provided (for payable constructors)
      if (params.value) {
        txOptions.value = WalletIntegrationService.parseEther(params.value);
      }
      
      // Add gas parameters if provided
      if (params.gasLimit) {
        txOptions.gasLimit = BigInt(params.gasLimit);
      }
      if (params.maxFeePerGas) {
        txOptions.maxFeePerGas = BigInt(params.maxFeePerGas);
      }
      if (params.maxPriorityFeePerGas) {
        txOptions.maxPriorityFeePerGas = BigInt(params.maxPriorityFeePerGas);
      }
      
      // Deploy contract
      const txHash = await walletServiceInstance.sendTransaction(txOptions);
      
      // Create deployment result
      const deploymentResult: DeploymentResult = {
        transactionHash: txHash,
        contractAddress: null, // Will be updated after confirmation
        deploymentStatus: 'pending',
        abi,
        bytecode,
        constructorArgs
      };
      
      // Store the deployment
      this.deployments.set(txHash, deploymentResult);
      
      // Wait for deployment confirmation in the background
      this.waitForDeployment(txHash, params.verify || false, walletServiceInstance);
      
      return deploymentResult;
    } catch (error) {
      console.error('Contract deployment error:', error);
      throw new Error(`Contract deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Wait for deployment confirmation
  private async waitForDeployment(
    hash: `0x${string}`, 
    verify: boolean = false,
    walletServiceInstance: WalletIntegrationService
  ): Promise<void> {
    try {
      // Wait for transaction receipt
      const receipt = await walletServiceInstance.waitForTransaction(hash);
      
      // Update deployment result
      const deployment = this.deployments.get(hash);
      if (deployment) {
        deployment.deploymentStatus = receipt.status === 'success' ? 'success' : 'failed';
        deployment.contractAddress = receipt.contractAddress as `0x${string}` || null;
        deployment.receipt = receipt;
        deployment.gasUsed = receipt.gasUsed;
        deployment.effectiveGasPrice = receipt.effectiveGasPrice;
        
        this.deployments.set(hash, deployment);
      }
      
      // Verify contract if requested
      if (verify && deployment && deployment.contractAddress) {
        // TODO: Implement contract verification
      }
    } catch (error) {
      console.error('Deployment confirmation error:', error);
      
      // Update deployment status to failed
      const deployment = this.deployments.get(hash);
      if (deployment) {
        deployment.deploymentStatus = 'failed';
        deployment.error = `Deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
        this.deployments.set(hash, deployment);
      }
    }
  }

  // Get deployment status
  getDeployment(hash: `0x${string}`): DeploymentResult | null {
    return this.deployments.get(hash) || null;
  }

  // Get all deployments
  getAllDeployments(): DeploymentResult[] {
    return Array.from(this.deployments.values());
  }
}

// Export singleton instance
export const contractDeploymentAgent = new ContractDeploymentAgent(); 

================================================================================
File: lib/agents/deployment/contract-templates.ts
================================================================================

// Contract template interface
export interface ContractTemplate {
  id: string;
  name: string;
  description: string;
  category: 'token' | 'nft' | 'defi' | 'utility' | 'governance';
  source: string;
  parameters: TemplateParameter[];
  defaultValues?: Record<string, any>;
  version: string;
  author: string;
}

// Template parameter interface
export interface TemplateParameter {
  name: string;
  description: string;
  type: 'string' | 'number' | 'boolean' | 'address' | 'uint256' | 'uint8';
  required: boolean;
  defaultValue?: any;
  options?: any[];
}

// Template registry
const templates: Map<string, ContractTemplate> = new Map();

// Get a template by ID
export async function getTemplate(id: string): Promise<ContractTemplate | null> {
  return templates.get(id) || null;
}

// Get all templates
export async function getAllTemplates(): Promise<ContractTemplate[]> {
  return Array.from(templates.values());
}

// Get templates by category
export async function getTemplatesByCategory(category: string): Promise<ContractTemplate[]> {
  return Array.from(templates.values()).filter(template => template.category === category);
}

// Register a template
export function registerTemplate(template: ContractTemplate): void {
  templates.set(template.id, template);
}

// ERC20 Token Template
const erc20TokenTemplate: ContractTemplate = {
  id: 'erc20-token',
  name: 'ERC20 Token',
  description: 'Standard ERC20 token with name, symbol, and supply',
  category: 'token',
  source: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract {{name}} is ERC20, Ownable {
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply,
        address _owner
    ) ERC20(_name, _symbol) Ownable(_owner) {
        _mint(_owner, _initialSupply * 10 ** decimals());
    }
    
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}`,
  parameters: [
    {
      name: 'name',
      description: 'Token name',
      type: 'string',
      required: true,
      defaultValue: 'My Token'
    },
    {
      name: '_name',
      description: 'Token name parameter',
      type: 'string',
      required: true,
      defaultValue: 'My Token'
    },
    {
      name: '_symbol',
      description: 'Token symbol',
      type: 'string',
      required: true,
      defaultValue: 'MTK'
    },
    {
      name: '_initialSupply',
      description: 'Initial token supply',
      type: 'uint256',
      required: true,
      defaultValue: '1000000'
    },
    {
      name: '_owner',
      description: 'Token owner address',
      type: 'address',
      required: true
    }
  ],
  defaultValues: {
    name: 'MyToken'
  },
  version: '1.0.0',
  author: 'BlockchainGPT'
};

// NFT Collection Template
const nftCollectionTemplate: ContractTemplate = {
  id: 'nft-collection',
  name: 'NFT Collection',
  description: 'ERC721 NFT collection with metadata',
  category: 'nft',
  source: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract {{name}} is ERC721Enumerable, Ownable {
    using Strings for uint256;
    
    string public baseURI;
    uint256 public maxSupply;
    uint256 public price;
    bool public saleIsActive = false;
    
    constructor(
        string memory _name,
        string memory _symbol,
        string memory _initBaseURI,
        uint256 _maxSupply,
        uint256 _price,
        address _owner
    ) ERC721(_name, _symbol) Ownable(_owner) {
        baseURI = _initBaseURI;
        maxSupply = _maxSupply;
        price = _price;
    }
    
    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }
    
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";
    }
    
    function mint(uint256 numberOfTokens) public payable {
        require(saleIsActive, "Sale is not active");
        require(numberOfTokens > 0, "Must mint at least 1 token");
        require(totalSupply() + numberOfTokens <= maxSupply, "Would exceed max supply");
        require(msg.value >= price * numberOfTokens, "Insufficient payment");
        
        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = totalSupply() + 1;
            _safeMint(msg.sender, tokenId);
        }
    }
    
    function setSaleState(bool _saleIsActive) public onlyOwner {
        saleIsActive = _saleIsActive;
    }
    
    function setBaseURI(string memory _newBaseURI) public onlyOwner {
        baseURI = _newBaseURI;
    }
    
    function setPrice(uint256 _newPrice) public onlyOwner {
        price = _newPrice;
    }
    
    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }
}`,
  parameters: [
    {
      name: 'name',
      description: 'Contract name',
      type: 'string',
      required: true,
      defaultValue: 'MyNFTCollection'
    },
    {
      name: '_name',
      description: 'Collection name',
      type: 'string',
      required: true,
      defaultValue: 'My NFT Collection'
    },
    {
      name: '_symbol',
      description: 'Collection symbol',
      type: 'string',
      required: true,
      defaultValue: 'MNFT'
    },
    {
      name: '_initBaseURI',
      description: 'Base URI for token metadata',
      type: 'string',
      required: true,
      defaultValue: 'https://example.com/metadata/'
    },
    {
      name: '_maxSupply',
      description: 'Maximum supply of NFTs',
      type: 'uint256',
      required: true,
      defaultValue: '10000'
    },
    {
      name: '_price',
      description: 'Price per NFT in wei',
      type: 'uint256',
      required: true,
      defaultValue: '50000000000000000' // 0.05 ETH
    },
    {
      name: '_owner',
      description: 'Collection owner address',
      type: 'address',
      required: true
    }
  ],
  defaultValues: {
    name: 'MyNFTCollection'
  },
  version: '1.0.0',
  author: 'BlockchainGPT'
};

// Simple Storage Template
const simpleStorageTemplate: ContractTemplate = {
  id: 'simple-storage',
  name: 'Simple Storage',
  description: 'Basic contract for storing and retrieving a value',
  category: 'utility',
  source: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract {{name}} {
    uint256 private value;
    address public owner;
    
    event ValueChanged(uint256 newValue);
    
    constructor(uint256 _initialValue) {
        value = _initialValue;
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }
    
    function setValue(uint256 _newValue) public onlyOwner {
        value = _newValue;
        emit ValueChanged(_newValue);
    }
    
    function getValue() public view returns (uint256) {
        return value;
    }
    
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "Invalid address");
        owner = _newOwner;
    }
}`,
  parameters: [
    {
      name: 'name',
      description: 'Contract name',
      type: 'string',
      required: true,
      defaultValue: 'SimpleStorage'
    },
    {
      name: '_initialValue',
      description: 'Initial stored value',
      type: 'uint256',
      required: true,
      defaultValue: '0'
    }
  ],
  defaultValues: {
    name: 'SimpleStorage'
  },
  version: '1.0.0',
  author: 'BlockchainGPT'
};

// Register templates
registerTemplate(erc20TokenTemplate);
registerTemplate(nftCollectionTemplate);
registerTemplate(simpleStorageTemplate); 

================================================================================
File: lib/agents/deployment/solidity-compiler.ts
================================================================================

export interface CompilerOptions {
  optimizer?: {
    enabled: boolean;
    runs: number;
  };
  version?: string;
  evmVersion?: string;
}

export interface CompilationResult {
  contracts: Record<string, any>;
  sources: Record<string, any>;
  errors?: Array<{
    message: string;
    severity: 'error' | 'warning';
    type: string;
  }>;
}

// This is a server-side only module
// We'll use dynamic imports to ensure it only runs on the server
export async function compile(source: string, options: CompilerOptions = {}): Promise<CompilationResult> {
  // Check if we're in a browser environment
  if (typeof window !== 'undefined') {
    console.error('Solidity compiler cannot run in browser environment');
    return {
      contracts: {},
      sources: {},
      errors: [{
        message: 'Solidity compilation is only available on the server side',
        severity: 'error',
        type: 'EnvironmentError'
      }]
    };
  }
  
  try {
    // Dynamic import to ensure this only runs on the server
    const solc = await import('solc');
    
    // Prepare input for the compiler
    const input = {
      language: 'Solidity',
      sources: {
        'contract.sol': {
          content: source
        }
      },
      settings: {
        outputSelection: {
          '*': {
            '*': ['abi', 'evm.bytecode']
          }
        },
        optimizer: options.optimizer || {
          enabled: false,
          runs: 200
        },
        evmVersion: options.evmVersion || 'london'
      }
    };
    
    // Compile the contract
    const output = JSON.parse(solc.compile(JSON.stringify(input)));
    
    // Check for errors
    if (output.errors) {
      const hasError = output.errors.some((error: any) => error.severity === 'error');
      if (hasError) {
        return {
          contracts: {},
          sources: {},
          errors: output.errors
        };
      }
    }
    
    return {
      contracts: output.contracts['contract.sol'],
      sources: output.sources,
      errors: output.errors
    };
  } catch (error) {
    console.error('Solidity compilation error:', error);
    return {
      contracts: {},
      sources: {},
      errors: [{
        message: error instanceof Error ? error.message : 'Unknown error',
        severity: 'error',
        type: 'CompilationError'
      }]
    };
  }
} 

================================================================================
File: lib/agents/index.ts
================================================================================

export { analyzeUserQuery } from './intent';
export { buildAggregatorCalls, executeAggregatorCalls } from './aggregator';
export { generateSummary } from './summarization';
export * from './types';

================================================================================
File: lib/agents/intent.ts
================================================================================

import { Configuration, OpenAIApi } from 'openai';
import { RobustAnalysis, Agent1Input, PreprocessingStep, QueryMetadata } from './types';
import { validateAnalysis, validateLLMResponse, PreprocessingError, LLMError } from './validation';

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
let openai: OpenAIApi | null = null;

function getOpenAIClient() {
  if (!openai) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    const configuration = new Configuration({ apiKey });
    openai = new OpenAIApi(configuration);
  }
  return openai;
}

const SYSTEM_PROMPT = `You are an advanced blockchain and cryptocurrency analysis system specializing in intent classification. Your task is to analyze and categorize user queries across multiple domains while being resilient to ambiguous, malformed, or complex inputs.

CLASSIFICATION CATEGORIES:

1. MARKET_DATA
   - Price inquiries and market statistics
   - Trading volume and liquidity information
   - Market cap and supply metrics
   - Historical price data requests
   Examples: "What's BTC price?", "Show ETH trading volume"

2. COMPARISON
   - Direct token comparisons
   - Performance analysis between assets
   - Market metric comparisons
   - Technology or feature comparisons
   Examples: "Compare BTC and ETH", "Which has better performance?"

3. TECHNICAL
   - Smart contract inquiries
   - Blockchain architecture questions
   - Protocol specifications
   - Development and implementation
   Examples: "How do ERC20 tokens work?", "Explain Ethereum's consensus"

4. DEFI
   - Yield farming and liquidity
   - Lending protocols
   - DEX mechanics
   - Tokenomics
   Examples: "How does liquidity mining work?", "Explain impermanent loss"

5. REGULATORY
   - Legal and compliance questions
   - Regulatory updates
   - Policy impact analysis
   - Jurisdictional inquiries
   Examples: "Latest crypto regulations", "Is mining legal in China?"

6. NEWS_EVENTS
   - Recent developments
   - Project updates
   - Market events
   - Industry announcements
   Examples: "Latest Bitcoin news", "Updates on ETH merge"

7. SECURITY
   - Network security
   - Wallet safety
   - Smart contract audits
   - Attack vectors and risks
   Examples: "Is hardware wallet safe?", "Common DeFi exploits"

8. CONCEPTUAL
   - Basic blockchain concepts
   - Cryptocurrency fundamentals
   - General educational queries
   Examples: "What are gas fees?", "How does mining work?"

9. HYBRID
   - Queries spanning multiple categories
   - Complex multi-part questions
   Example: "Compare ETH price and explain smart contracts"

10. NEEDS_CONTEXT
    - Ambiguous queries
    - Incomplete information
    - Context-dependent questions
    Example: "Is it better?", "What's the difference?"

11. DEPLOY_CONTRACT
    - Requests to deploy smart contracts
    - Specific contract template mentions
    - Contract deployment parameters
    Examples: "Deploy an ERC20 token", "Create a new token called MyToken"

12. TRANSFER_TOKENS
    - Requests to send tokens or ETH
    - Mentions of specific recipients and amounts
    Examples: "Send 0.1 ETH to 0x123...", "Transfer 100 USDC to my friend"

13. CONNECT_WALLET
    - Requests to connect a wallet
    - MetaMask or wallet connection mentions
    Examples: "Connect my wallet", "Link MetaMask"

DETECTION RULES:

1. Token Detection:
   - Common tokens: BTC, ETH, SOL, DOGE, ADA, BNB, XRP, DOT, MATIC, AVAX, LINK, UNI, ATOM, LTC
   - Special cases: LUNA -> terra-luna-2, LUNC -> terra-luna
   - Handle both symbols and full names: Bitcoin, Ethereum, etc.
   - Process token pairs in comparisons
   - Maximum 5 tokens per query
   - Normalize token names consistently

2. Intent Analysis:
   - Primary intent based on strongest category match
   - Secondary intents for hybrid queries
   - Confidence level assessment
   - Ambiguity detection

3. Market Indicators:
   - Price-related terms
   - Volume and liquidity metrics
   - Trading signals
   - Technical analysis terms

4. Conceptual Indicators:
   - Educational keywords
   - Definition requests
   - How-to questions
   - Explanation markers

5. Time Context:
   - Current vs historical
   - Specific timeframes
   - Trend analysis periods
   - Future predictions

6. Blockchain Transaction Detection:
   - Wallet addresses (0x...)
   - Token amounts and symbols
   - Contract template names (ERC20, ERC721)
   - Transaction verbs (send, transfer, deploy, create)
   - Wallet connection terms (connect, link, integrate)

CRITICAL RESPONSE REQUIREMENTS:

Return a valid JSON response with EXACTLY this structure:

{
  "classification": {
    "primaryIntent": "MARKET_DATA" | "COMPARISON" | "TECHNICAL" | "DEFI" | 
                    "REGULATORY" | "NEWS_EVENTS" | "SECURITY" | "CONCEPTUAL" | 
                    "HYBRID" | "NEEDS_CONTEXT" | "DEPLOY_CONTRACT" | 
                    "TRANSFER_TOKENS" | "CONNECT_WALLET",
    "confidence": <number between 0 and 1>,
    "needsApiCall": <boolean>,
    "ambiguityLevel": "LOW" | "MEDIUM" | "HIGH",
    "requiresWebSearch": <boolean>
  },
  "queryAnalysis": {
    "sanitizedQuery": <string>,
    "detectedTokens": <string[]>,
    "comparisonRequest": {
      "isComparison": <boolean>,
      "tokens": <string[]>,
      "aspects": <string[]>,
      "primaryMetric": <string | null>
    },
    "detectedIntents": <string[]>,
    "timeContext": "current" | "24h" | "7d" | "30d" | null,
    "marketIndicators": <string[]>,
    "conceptualIndicators": <string[]>,
    "webSearchContext": {
      "needed": <boolean>,
      "reason": <string | null>,
      "suggestedQueries": <string[]>
    },
    "detectedEntities": <string[]>,
    "entityParams": {
      "name": <string | null>,
      "symbol": <string | null>,
      "initialSupply": <string | null>
    },
    "recipient": <string | null>,
    "amount": <string | null>,
    "tokenAddress": <string | null>
  },
  "dataRequirements": {
    "marketData": {
      "needed": <boolean>,
      "types": <string[]>,
      "timeframe": "current" | "24h" | "7d" | "30d" | null,
      "tokenCount": <number>
    },
    "conceptualData": {
      "needed": <boolean>,
      "aspects": <string[]>
    }
  }
}

CRITICAL REQUIREMENTS:
1. ALWAYS include ALL fields exactly as shown above
2. NEVER omit any fields or change the structure
3. ALWAYS validate token count <= 5
4. ENSURE all string arrays contain valid strings
5. SET needsApiCall=true for any market data requests
6. SET requiresWebSearch=true for news/regulatory queries
7. INCLUDE clear reason when webSearchContext.needed=true
8. VALIDATE all enums match specified values exactly
9. For market data:
   - Set tokenCount accurately
   - Include all required data types
   - Set timeframe appropriately
10. For comparisons:
    - Set comparisonRequest.isComparison = true
    - Include all detected tokens in comparisonRequest.tokens
    - List relevant aspects in comparisonRequest.aspects
    - Set primaryMetric based on query focus
11. For news/regulatory/security queries:
    - Set requiresWebSearch = true
    - Include clear reason in webSearchContext
    - Provide relevant suggestedQueries
12. For conceptual/technical queries:
    - Set marketData.needed = false
    - Set marketData.tokenCount = 0
    - Include relevant aspects in conceptualData
13. For blockchain transactions:
    - For DEPLOY_CONTRACT: Extract templateId, name, symbol, initialSupply, etc.
    - For TRANSFER_TOKENS: Extract to (recipient address), amount, tokenAddress (if specified)
    - For CONNECT_WALLET: Extract wallet type (metamask, walletconnect)
    - Include detectedEntities, entityParams, recipient, amount, tokenAddress as appropriate`;

function preprocessQuery(query: string): PreprocessingStep[] {
  const steps: PreprocessingStep[] = [];
  
  try {
    if (!query?.trim()) {
      throw new PreprocessingError('Empty query', 'sanitize');
    }

    let processed = query.trim();
    steps.push({
      operation: 'sanitize',
      input: query,
      output: processed
    });

    processed = processed.toLowerCase();
    const tokenMappings: Record<string, string> = {
      'btc': 'bitcoin',
      'eth': 'ethereum',
      'sol': 'solana',
      'doge': 'dogecoin',
      'ada': 'cardano',
      'bnb': 'binancecoin',
      'xrp': 'ripple',
      'dot': 'polkadot',
      'matic': 'polygon',
      'avax': 'avalanche-2',
      'link': 'chainlink',
      'uni': 'uniswap',
      'atom': 'cosmos',
      'ltc': 'litecoin',
      'luna': 'terra-luna-2',
      'lunc': 'terra-luna'
    };

    for (const [abbr, full] of Object.entries(tokenMappings)) {
      processed = processed.replace(new RegExp(`\\b${abbr}\\b`, 'g'), full);
    }
    steps.push({
      operation: 'normalize_tokens',
      input: processed,
      output: processed
    });

    return steps;
  } catch (error) {
    if (error instanceof PreprocessingError) {
      throw error;
    }
    throw new PreprocessingError(
      'Preprocessing failed',
      'unknown',
      query
    );
  }
}

function extractMetadata(query: string, steps: PreprocessingStep[]): QueryMetadata {
  try {
    const processedQuery = steps[steps.length - 1].output;
    
    const commonTokens = [
      'bitcoin', 'ethereum', 'solana', 'dogecoin', 'cardano',
      'binancecoin', 'ripple', 'polkadot', 'polygon', 'avalanche-2',
      'chainlink', 'uniswap', 'cosmos', 'litecoin', 'terra-luna-2',
      'terra-luna'
    ];

    const tokens = processedQuery
      .split(/\s+/)
      .filter(token => 
        token.length > 1 && 
        !['price', 'show', 'me', 'what', 'is', 'the', 'of', 'and', 'vs', 'versus', 'compare'].includes(token)
      );

    const uniqueTokens = Array.from(new Set(tokens))
      .filter(token => 
        commonTokens.includes(token) || 
        /^[a-z0-9]+$/.test(token)
      )
      .slice(0, 5);

    const hints = [];
    if (query.includes('price')) hints.push('PRICE_QUERY');
    if (query.includes('compare') || query.includes('vs') || query.includes('versus')) hints.push('COMPARISON');
    if (query.includes('trend')) hints.push('TREND_ANALYSIS');
    if (query.includes('how') || query.includes('what')) hints.push('EDUCATIONAL');
    if (uniqueTokens.length > 1) hints.push('MULTI_TOKEN');
    if (query.includes('news') || query.includes('latest')) hints.push('NEWS');
    if (query.includes('regulation') || query.includes('legal')) hints.push('REGULATORY');
    if (query.includes('security') || query.includes('safe')) hints.push('SECURITY');
    if (query.includes('defi') || query.includes('yield')) hints.push('DEFI');

    return {
      tokens: uniqueTokens,
      entities: uniqueTokens.filter(token => commonTokens.includes(token)),
      contextualHints: hints
    };
  } catch (error) {
    throw new PreprocessingError(
      'Metadata extraction failed',
      'metadata',
      query
    );
  }
}

async function retryWithExponentialBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      if (error instanceof Error && error.message.includes('rate limit')) {
        const delay = initialDelay * Math.pow(2, i);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      throw error;
    }
  }
  
  throw lastError || new Error('Operation failed after retries');
}

export async function analyzeUserQuery(input: Agent1Input): Promise<RobustAnalysis> {
  try {
    const startTime = Date.now();
    const preprocessingSteps = preprocessQuery(input.query);
    const metadata = extractMetadata(input.query, preprocessingSteps);

    const client = getOpenAIClient();
    const completion = await retryWithExponentialBackoff(async () => {
      return client.createChatCompletion({
        model: OPENAI_MODEL,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: preprocessingSteps[preprocessingSteps.length - 1].output }
        ],
        temperature: 0.1,
        max_tokens: 1000,
      });
    });

    const response = completion.data.choices[0]?.message?.content;
    if (!response) {
      throw new LLMError('No response from OpenAI');
    }

    const parsedResponse = validateLLMResponse(response);
    
    const analysis: RobustAnalysis = {
      originalContext: {
        rawQuery: input.query,
        timestamp: startTime,
        preprocessingSteps,
        metadata
      },
      classification: parsedResponse.classification,
      queryAnalysis: parsedResponse.queryAnalysis,
      dataRequirements: parsedResponse.dataRequirements
    };

    validateAnalysis(analysis);

    return analysis;

  } catch (error) {
    console.error('Intent analysis error:', error);
    
    if (error instanceof PreprocessingError) {
      throw new Error(`Preprocessing failed at ${error.step}: ${error.message}`);
    }
    if (error instanceof LLMError) {
      throw new Error(`LLM error: ${error.message}`);
    }
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('Unknown error during analysis');
  }
}

================================================================================
File: lib/agents/regulatory.ts
================================================================================

import { TokenCache } from './token-cache';

interface RegulatoryUpdate {
  id: string;
  title: string;
  summary: string;
  jurisdiction: string;
  authority: string;
  date: string;
  url: string;
  category: string;
  impact: 'HIGH' | 'MEDIUM' | 'LOW';
  status: 'PROPOSED' | 'ENACTED' | 'UNDER_REVIEW';
  relatedAssets?: string[];
}

interface CrystalRiskData {
  address?: string;
  riskScore: number;
  riskLevel: 'HIGH' | 'MEDIUM' | 'LOW';
  categories: string[];
  lastUpdated: string;
}

interface RegulatorySearchParams {
  jurisdiction?: string;
  timeRange?: string;
  category?: string;
  asset?: string;
  status?: string;
}

class RegulatoryCache extends TokenCache {
  constructor() {
    super(1800000); // 30 minutes cache for regulatory data
  }
}

const regulatoryCache = new RegulatoryCache();

async function fetchCrystalData(address: string): Promise<CrystalRiskData> {
  const apiKey = process.env.CRYSTAL_API_KEY;
  if (!apiKey) {
    throw new Error('Crystal API key not configured');
  }

  const cacheKey = `crystal-${address}`;
  const cachedData = regulatoryCache.get(cacheKey);
  if (cachedData) return cachedData;

  try {
    const response = await fetch(
      `https://api.crystalblockchain.com/v1/risk/${address}`,
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Crystal API error: ${response.status}`);
    }

    const data = await response.json();
    const riskData: CrystalRiskData = {
      address,
      riskScore: data.risk_score,
      riskLevel: data.risk_level,
      categories: data.risk_categories,
      lastUpdated: new Date().toISOString()
    };

    regulatoryCache.set(cacheKey, riskData);
    return riskData;
  } catch (error) {
    console.error('Crystal API error:', error);
    throw error;
  }
}

async function fetchChainalysisData(asset: string): Promise<any> {
  const apiKey = process.env.CHAINALYSIS_API_KEY;
  if (!apiKey) {
    throw new Error('Chainalysis API key not configured');
  }

  const cacheKey = `chainalysis-${asset}`;
  const cachedData = regulatoryCache.get(cacheKey);
  if (cachedData) return cachedData;

  try {
    const response = await fetch(
      `https://api.chainalysis.com/api/v1/asset/${asset}/compliance`,
      {
        headers: {
          'X-API-Key': apiKey,
          'Content-Type': 'application/json'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Chainalysis API error: ${response.status}`);
    }

    const data = await response.json();
    regulatoryCache.set(cacheKey, data);
    return data;
  } catch (error) {
    console.error('Chainalysis API error:', error);
    throw error;
  }
}

export async function getRegulatoryUpdates(
  params: RegulatorySearchParams
): Promise<RegulatoryUpdate[]> {
  const cacheKey = `regulatory-${JSON.stringify(params)}`;
  const cachedData = regulatoryCache.get(cacheKey);
  if (cachedData) return cachedData;

  try {
    // Fetch from multiple sources and combine results
    const [crystalUpdates, chainalysisUpdates] = await Promise.all([
      params.asset ? fetchCrystalData(params.asset).then(data => ({
        id: `crystal-${params.asset}`,
        title: `Risk assessment for ${params.asset}`,
        summary: `Crystal Blockchain risk assessment for ${params.asset}`,
        jurisdiction: 'GLOBAL',
        authority: 'Crystal Blockchain',
        date: data.lastUpdated,
        url: 'https://crystalblockchain.com/',
        category: data.categories[0] || 'RISK_ASSESSMENT',
        impact: data.riskLevel,
        status: 'ENACTED',
        relatedAssets: [params.asset]
      })) : Promise.resolve(null),
      params.asset ? fetchChainalysisData(params.asset).then(data => ({
        id: `chainalysis-${params.asset}`,
        title: `Chainalysis report for ${params.asset}`,
        summary: data.summary || `Chainalysis report for ${params.asset}`,
        jurisdiction: 'GLOBAL',
        authority: 'Chainalysis',
        date: new Date().toISOString(),
        url: 'https://chainalysis.com/',
        category: 'RISK_ASSESSMENT',
        impact: data.riskLevel || 'MEDIUM',
        status: 'ENACTED',
        relatedAssets: [params.asset]
      })) : Promise.resolve(null)
    ]);

    // Use type assertion to help TypeScript understand the filter
    const updates = [
      crystalUpdates,
      chainalysisUpdates
    ].filter(Boolean) as RegulatoryUpdate[];

    regulatoryCache.set(cacheKey, updates);
    return updates;
  } catch (error) {
    console.error('Regulatory data fetch error:', error);
    throw error;
  }
}

export async function getComplianceRisk(
  asset: string
): Promise<{
  riskScore: number;
  riskLevel: string;
  details: string[];
}> {
  try {
    const [crystalData, chainalysisData] = await Promise.all([
      fetchCrystalData(asset),
      fetchChainalysisData(asset)
    ]);

    return {
      riskScore: (crystalData.riskScore + chainalysisData.riskScore) / 2,
      riskLevel: crystalData.riskLevel,
      details: [
        ...crystalData.categories,
        ...chainalysisData.riskFactors || []
      ]
    };
  } catch (error) {
    console.error('Compliance risk assessment error:', error);
    throw error;
  }
}

================================================================================
File: lib/agents/security/contract-validator.ts
================================================================================

// Security issue interface
export interface SecurityIssue {
  severity: 'high' | 'medium' | 'low' | 'info';
  title: string;
  description: string;
  line?: number;
  column?: number;
}

// Validation result interface
export interface ValidationResult {
  valid: boolean;
  issues: SecurityIssue[];
}

// Basic patterns to check for common security issues
const SECURITY_PATTERNS = [
  {
    pattern: /selfdestruct|suicide/i,
    severity: 'high' as const,
    title: 'Self-destruct found',
    description: 'The contract contains a self-destruct function which can permanently destroy the contract.'
  },
  {
    pattern: /tx\.origin/i,
    severity: 'high' as const,
    title: 'tx.origin used for authentication',
    description: 'Using tx.origin for authentication is vulnerable to phishing attacks.'
  },
  {
    pattern: /block\.(timestamp|number|difficulty)/i,
    severity: 'medium' as const,
    title: 'Block properties used as source of randomness',
    description: 'Block properties like timestamp, number, or difficulty are not secure sources of randomness.'
  },
  {
    pattern: /function\s+\w+\s*\(\s*\)\s*public\s+payable\s*\{\s*\}/i,
    severity: 'medium' as const,
    title: 'Empty payable function',
    description: 'Contract has an empty payable function which can lock funds.'
  },
  {
    pattern: /assembly\s*\{/i,
    severity: 'medium' as const,
    title: 'Assembly code used',
    description: 'Contract uses assembly code which bypasses Solidity safety features.'
  },
  {
    pattern: /\.call\.value\s*\(/i,
    severity: 'medium' as const,
    title: 'Low-level call with value',
    description: 'Low-level calls with value can lead to reentrancy attacks if not properly guarded.'
  },
  {
    pattern: /\.transfer\s*\(/i,
    severity: 'low' as const,
    title: 'Transfer used',
    description: 'Consider using call instead of transfer as transfer has a gas limit of 2300 gas.'
  },
  {
    pattern: /pragma\s+solidity\s+(\^|>|>=|<|<=)\s*0\.8/i,
    severity: 'info' as const,
    title: 'Solidity version',
    description: 'Contract uses Solidity version 0.8.x which has built-in overflow protection.'
  }
];

/**
 * Validate contract ABI and bytecode
 * @param abiOrSource Contract ABI or source code
 * @param bytecode Contract bytecode (optional)
 * @returns Validation result
 */
export function validateContract(abiOrSource: any, bytecode?: string): ValidationResult {
  try {
    // Determine if we're validating source code or ABI
    const isSourceCode = typeof abiOrSource === 'string' && !abiOrSource.startsWith('[');
    
    if (isSourceCode) {
      // Validate source code
      return validateSourceCode(abiOrSource);
    } else {
      // Validate ABI
      return validateABI(abiOrSource, bytecode);
    }
  } catch (error) {
    console.error('Contract validation error:', error);
    return {
      valid: false,
      issues: [{
        severity: 'high',
        title: 'Validation error',
        description: `Failed to validate contract: ${error instanceof Error ? error.message : 'Unknown error'}`
      }]
    };
  }
}

/**
 * Validate contract source code
 * @param source Contract source code
 * @returns Validation result
 */
function validateSourceCode(source: string): ValidationResult {
  // Start with empty issues array
  const issues: SecurityIssue[] = [];
  
  // Check for security patterns in the source code
  for (const pattern of SECURITY_PATTERNS) {
    if (pattern.pattern.test(source)) {
      issues.push({
        severity: pattern.severity,
        title: pattern.title,
        description: pattern.description
      });
    }
  }
  
  // Check for high-risk patterns more precisely (with context)
  const lines = source.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check for reentrancy vulnerabilities
    if (
      /\.call\s*\{/.test(line) &&
      !/(\s|^)if\s*\(/.test(line) &&
      !/(return|revert|require)\s/.test(line)
    ) {
      // Look for state changes after external calls
      let j = i + 1;
      let stateChangeAfterCall = false;
      
      while (j < Math.min(lines.length, i + 10)) {
        if (/\=\s/.test(lines[j])) {
          stateChangeAfterCall = true;
          break;
        }
        j++;
      }
      
      if (stateChangeAfterCall) {
        issues.push({
          severity: 'high',
          title: 'Potential reentrancy vulnerability',
          description: 'External call is followed by state changes, which could lead to reentrancy attacks.',
          line: i + 1
        });
      }
    }
  }
  
  return {
    valid: issues.filter(issue => issue.severity === 'high').length === 0,
    issues
  };
}

/**
 * Validate contract ABI and bytecode
 * @param abi Contract ABI
 * @param bytecode Contract bytecode
 * @returns Validation result
 */
function validateABI(abi: any, bytecode?: string): ValidationResult {
  const issues: SecurityIssue[] = [];
  
  // Check for common issues in ABI
  try {
    // Parse ABI if it's a string
    const parsedAbi = typeof abi === 'string' ? JSON.parse(abi) : abi;
    
    // Check for payable fallback function
    const hasFallback = parsedAbi.some((item: any) => 
      item.type === 'fallback' && item.stateMutability === 'payable'
    );
    
    if (hasFallback) {
      issues.push({
        severity: 'medium',
        title: 'Payable fallback function',
        description: 'Contract has a payable fallback function which can receive ETH without explicit function calls.'
      });
    }
    
    // Check for selfdestruct
    const hasSelfDestruct = parsedAbi.some((item: any) => 
      item.type === 'function' && 
      (item.name === 'selfdestruct' || item.name === 'suicide' || 
       item.name.toLowerCase().includes('destruct') || item.name.toLowerCase().includes('kill'))
    );
    
    if (hasSelfDestruct) {
      issues.push({
        severity: 'high',
        title: 'Self-destruct function',
        description: 'Contract contains a function that may destroy the contract permanently.'
      });
    }
  } catch (error) {
    issues.push({
      severity: 'medium',
      title: 'Invalid ABI',
      description: 'Could not parse the contract ABI.'
    });
  }
  
  // Check bytecode if provided
  if (bytecode) {
    // Check if bytecode is empty
    if (bytecode === '0x' || bytecode === '') {
      issues.push({
        severity: 'high',
        title: 'Empty bytecode',
        description: 'Contract bytecode is empty, which means it cannot be deployed.'
      });
    }
    
    // Additional bytecode checks can be added here
  }
  
  return {
    valid: issues.filter(issue => issue.severity === 'high').length === 0,
    issues
  };
}

/**
 * Validate transaction parameters
 * @param to Recipient address
 * @param value Transaction value
 * @param data Transaction data (optional)
 * @returns Validation result
 */
export function validateTransaction(
  to: string, 
  value: bigint,
  data?: string
): ValidationResult {
  const issues: SecurityIssue[] = [];
  
  // Check if sending to address(0)
  if (to === '0x0000000000000000000000000000000000000000') {
    issues.push({
      severity: 'high',
      title: 'Sending to zero address',
      description: 'Transaction is sending to the zero address, which will burn the funds.'
    });
  }
  
  // Check if sending a large amount of ETH
  if (value > 10000000000000000000n) { // > 10 ETH
    issues.push({
      severity: 'medium',
      title: 'Large value transfer',
      description: 'Transaction is sending a large amount of ETH. Please verify the recipient address.'
    });
  }
  
  // Check if the transaction has data but no value (potential contract interaction)
  if (data && data !== '0x' && value === 0n) {
    // This is likely a contract interaction, which is fine
  }
  
  // Check if the transaction has both value and data (potential contract interaction with value)
  if (data && data !== '0x' && value > 0n) {
    issues.push({
      severity: 'low',
      title: 'Contract interaction with value',
      description: 'Transaction is sending ETH to a contract. Ensure the contract can handle ETH transfers.'
    });
  }
  
  return {
    valid: !issues.some(issue => issue.severity === 'high'),
    issues
  };
} 

================================================================================
File: lib/agents/summarization.ts
================================================================================

import { Configuration, OpenAIApi } from 'openai';
import { SummarizationInput } from './types';
import { ConversationStore, ChatMessage } from '../conversation-store';

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
let openai: OpenAIApi | null = null;

function getOpenAIClient() {
  if (!openai) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    const configuration = new Configuration({ apiKey });
    openai = new OpenAIApi(configuration);
  }
  return openai;
}

function generateTokenPriceResponse(tokenName: string, data: any): string {
  // Check if we have error information
  if (data?.error) {
    return `### ${tokenName} Price Information

I apologize, but I couldn't retrieve the current price for **${tokenName}**. This could be because:
- The token might not be listed on major exchanges
- The token symbol might be different than expected
- The token might only be available on specific platforms

To find accurate price information, you could:
1. Check decentralized exchanges (DEXs)
2. Visit the token's official website or community channels
3. Search with alternative token symbols
4. Check specialized crypto tracking platforms

Would you like to:
- Search for another token?
- Get information about major cryptocurrencies instead?
- Learn more about finding prices for newer tokens?`;
  }

  // Handle successful price data
  if (data?.current_price) {
    return `### Current ${tokenName} Price Data

**Price**: $${data.current_price.toFixed(6)}
**24h Change**: ${data.price_change_percentage_24h.toFixed(2)}%
**Market Cap**: $${formatMarketCap(data.market_cap)}

*Data source: ${data.source}*

Would you like to:
- See detailed market metrics?
- Compare with other tokens?
- View historical price data?`;
  }

  // Generic fallback response
  return `### ${tokenName} Price Query

I apologize, but I couldn't find current price information for **${tokenName}**. 
The token data might be unavailable or the token symbol might need verification.

Try checking:
- Popular crypto exchanges
- Token tracking websites
- The project's official channels

Would you like to search for a different token or get information about major cryptocurrencies instead?`;
}

function formatMarketCap(marketCap: number): string {
  if (marketCap >= 1e9) {
    return `${(marketCap / 1e9).toFixed(2)}B`;
  }
  if (marketCap >= 1e6) {
    return `${(marketCap / 1e6).toFixed(2)}M`;
  }
  if (marketCap >= 1e3) {
    return `${(marketCap / 1e3).toFixed(2)}K`;
  }
  return marketCap.toString();
}

const SYSTEM_PROMPT = `You are an advanced blockchain and cryptocurrency analysis system providing detailed, accurate responses based on real-time market data, regulatory information, news, and comprehensive blockchain knowledge.

CONTEXT TYPES AND HANDLING:

1. Market Data (MARKET_DATA, COMPARISON):
   - Present prices with appropriate decimals (6 for < $1, 2 for >= $1)
   - Format market caps using B/M/K notation
   - Include percentage changes with +/- prefix
   - Show relevant volume and liquidity metrics
   - Compare multiple tokens when relevant

2. Technical Information (TECHNICAL):
   - Explain blockchain concepts clearly
   - Use appropriate technical terminology
   - Include code examples when relevant
   - Reference specific protocols or standards
   - Explain security implications

3. DeFi Analysis (DEFI):
   - Present TVL and yield data
   - Explain protocol mechanisms
   - Discuss risks and security considerations
   - Compare with similar protocols
   - Include liquidity metrics

4. Regulatory Updates (REGULATORY):
   - Summarize latest regulatory developments
   - Specify jurisdictions affected
   - Explain potential impact
   - Include compliance requirements
   - Reference official sources
   - Present risk assessments when available

5. News and Events (NEWS_EVENTS):
   - Summarize recent developments
   - Provide context and implications
   - Include relevant dates
   - Reference multiple sources
   - Maintain objectivity

6. Security Analysis (SECURITY):
   - Present risk assessments
   - Explain vulnerabilities
   - Provide security recommendations
   - Reference audits and incidents
   - Include best practices

7. Blockchain Operations (DEPLOY_CONTRACT, TRANSFER_TOKENS, CONNECT_WALLET):
   - Wallet Connection:
     - Confirm successful wallet connection
     - Show abbreviated wallet address
     - Emphasize transaction capabilities now enabled
   - Token Transfers:
     - Confirm transaction submission
     - Display transaction hash (abbreviated)
     - Explain next steps (confirmation, block time)
     - Provide transaction explorer link if available
   - Contract Deployment:
     - Confirm deployment transaction submission
     - Display transaction hash
     - Explain deployment process
     - Note contract address will be available after confirmation
     - Explain verification options if applicable

RESPONSE STRUCTURE:

1. Market Data Format:
   - Prices: 6 decimals for < $1, 2 decimals for >= $1
   - Market Cap: Use B/M/K notation (e.g., $50.5B)
   - Percentages: Include +/- prefix, 2 decimal places
   - Time References: Include timezone or relative time

2. Regulatory Format:
   - Jurisdiction: Clearly state affected regions
   - Status: Indicate if proposed/enacted/under review
   - Impact: HIGH/MEDIUM/LOW classification
   - Compliance: List specific requirements
   - Sources: Reference official documentation

3. News Format:
   - Date: Recent first, include timestamps
   - Source: Credit reputable sources
   - Impact: Explain significance
   - Context: Provide background
   - Follow-up: Suggest related queries

4. Technical Format:
   - Concepts: Clear explanations
   - Code: Properly formatted examples
   - Standards: Reference specifications
   - Security: Note important considerations
   - Resources: Link to documentation

5. Blockchain Transaction Format:
   - Status: Confirmed/Pending/Failed
   - Transaction Hash: Abbreviated (first 6, last 4 chars)
   - Details: Amount, recipient (abbreviated), token
   - Confirmations: Number needed and estimated time
   - Action Items: Verification steps, explorer links

CRITICAL REQUIREMENTS:

1. Accuracy:
   - Never invent or estimate missing data
   - Clearly indicate data sources
   - Acknowledge limitations
   - State when information is incomplete
   - Update timestamps for time-sensitive data

2. Clarity:
   - Use appropriate technical terms
   - Explain complex concepts
   - Structure information logically
   - Highlight important points
   - Maintain consistent formatting

3. Context:
   - Reference relevant background
   - Explain implications
   - Compare with alternatives
   - Note important caveats
   - Suggest related queries

4. Sources:
   - Credit data providers
   - Reference official documents
   - Link to specifications
   - Cite regulatory bodies
   - Include timestamps

5. Response Formatting:
   - Use markdown for formatting
   - Create clear sections with headers
   - Use bullet points for lists
   - Format code blocks properly
   - Include line breaks for readability

6. Error Handling:
   - Acknowledge missing data
   - Explain why data might be unavailable
   - Suggest alternative sources
   - Provide guidance for finding information
   - Recommend follow-up queries

7. Conversation Continuity:
   - Reference previous context when relevant
   - Build upon earlier discussions
   - Maintain consistent terminology
   - Track user preferences
   - Suggest logical next queries`;

export async function generateSummary(input: SummarizationInput): Promise<string> {
  const { userQuery, analysis, aggregatorResult, sessionId, enhancedContext } = input;

  try {
    const client = getOpenAIClient();
    
    // Check if we have any valid data
    const hasValidData = aggregatorResult?.primary?.coingecko || 
                        aggregatorResult?.primary?.coinmarketcap;

    // If this is a price query and we have token data, use the specialized formatter
    if (analysis.classification.primaryIntent === 'MARKET_DATA' && 
        analysis.queryAnalysis.detectedTokens.length === 1) {
      const tokenName = analysis.queryAnalysis.detectedTokens[0];
      const tokenData = aggregatorResult?.primary?.coingecko?.[tokenName] || 
                       aggregatorResult?.primary?.coinmarketcap?.[tokenName];
      
      if (tokenData) {
        return generateTokenPriceResponse(tokenName, tokenData);
      }
    }

    // Handle blockchain-specific responses
    if (aggregatorResult?.primary?.blockchain) {
      const blockchainData = aggregatorResult.primary.blockchain;
      
      if (blockchainData.actionType === 'CONNECT_WALLET' && blockchainData.success) {
        return `✅ **Wallet connected successfully!**\n\nAddress: \`${blockchainData.data.address.slice(0, 6)}...${blockchainData.data.address.slice(-4)}\`\n\nYou can now perform blockchain operations like deploying contracts and sending transactions.`;
      }
      
      if (blockchainData.actionType === 'DEPLOY_CONTRACT') {
        if (blockchainData.success) {
          return `🚀 **Contract deployment initiated!**\n\nTransaction hash: \`${blockchainData.data.transactionHash.slice(0, 6)}...${blockchainData.data.transactionHash.slice(-4)}\`\n\nYour contract is being deployed to the blockchain. This typically takes 15-60 seconds to confirm. Once confirmed, your contract address will be provided.`;
        } else {
          return `❌ **Contract deployment failed**\n\nError: ${blockchainData.error}\n\nPlease check your parameters and try again.`;
        }
      }
      
      if (blockchainData.actionType === 'TRANSFER_TOKENS') {
        if (blockchainData.success) {
          return `💸 **Transaction sent!**\n\nTransaction hash: \`${blockchainData.data.transactionHash.slice(0, 6)}...${blockchainData.data.transactionHash.slice(-4)}\`\n\nYour ${blockchainData.data.tokenAddress ? 'token transfer' : 'ETH transfer'} is being processed. This typically takes 15-60 seconds to confirm.`;
        } else {
          return `❌ **Transaction failed**\n\nError: ${blockchainData.error}\n\nPlease check your parameters and try again.`;
        }
      }
    }

    // Format the system message to include context handling instructions
    const systemMessage = `${SYSTEM_PROMPT}\n\nWhen generating responses:
1. Consider the user's technical level and interests
2. Maintain conversation continuity with previous topics
3. Use appropriate terminology based on user's expertise
4. Reference relevant history when appropriate
5. Adapt explanation depth based on user preferences`;

    // Build the conversation context
    const messages = [
      { role: "system" as const, content: systemMessage }
    ];

    // Add enhanced context if available
    if (enhancedContext) {
      messages.push({
        role: "system" as const,
        content: `Conversation Context:\n${enhancedContext}`
      });
    }

    // If no valid data, provide a helpful response
    if (!hasValidData && analysis.classification.needsApiCall) {
      messages.push({
        role: "system" as const,
        content: `Generate a helpful response for a failed data fetch. Query: "${userQuery}". 
Consider:
1. Common reasons for missing data
2. Alternative ways to find the information
3. Suggestions for similar tokens or topics
4. Guidance on verifying token information
5. Next steps the user can take`
      });
    } else {
      // Add the current query and data
      messages.push({
        role: "system" as const,
        content: `Query: ${userQuery}\n\nAnalysis Context:\n${JSON.stringify(analysis, null, 2)}\n\nAvailable Data:\n${JSON.stringify(aggregatorResult, null, 2)}`
      });
    }

    const completion = await client.createChatCompletion({
      model: OPENAI_MODEL,
      messages,
      temperature: 0.3,
      max_tokens: 700,
      presence_penalty: 0.1,
      frequency_penalty: 0.1
    });

    const response = completion.data.choices[0]?.message?.content;
    if (!response) {
      throw new Error('No response from GPT');
    }

    return response.trim();

  } catch (error) {
    console.error('Summary generation error:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        throw new Error('OpenAI API key is not configured');
      }
      if (error.message.includes('429')) {
        throw new Error('Rate limit exceeded. Please try again in a moment');
      }
      if (error.message.includes('401')) {
        throw new Error('Authentication failed. Please check API key configuration');
      }
      if (error.message.includes('insufficient_quota')) {
        throw new Error('OpenAI API quota exceeded. Please try again later');
      }
      throw error;
    }
    
    throw new Error('Failed to generate summary');
  }
}

================================================================================
File: lib/agents/token-cache.ts
================================================================================

interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

export class TokenCache {
  protected cache: Map<string, CacheEntry<any>>;
  protected readonly TTL: number;

  constructor(ttl: number = 60000) { // Default 1 minute cache
    this.cache = new Map();
    this.TTL = ttl;
  }

  get(key: string): any | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    if (Date.now() - entry.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  set(key: string, data: any): void {
    if (Object.keys(data).length > 0) {
      this.cache.set(key, {
        data,
        timestamp: Date.now()
      });
    }
  }

  getPartial(keys: string[]): Record<string, any> {
    const result: Record<string, any> = {};
    for (const key of keys) {
      const data = this.get(key);
      if (data) {
        Object.assign(result, { [key]: data });
      }
    }
    return result;
  }

  setPartial(keys: string[], data: Record<string, any>): void {
    // Store combined data
    this.set(keys.sort().join(','), data);
    
    // Store individual entries
    for (const [key, value] of Object.entries(data)) {
      this.set(key, { [key]: value });
    }
  }

  clear(): void {
    this.cache.clear();
  }

  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.TTL) {
        this.cache.delete(key);
      }
    }
  }
}

================================================================================
File: lib/agents/transaction/token-transfer-agent.ts
================================================================================

import { WalletIntegrationService } from '../../blockchain/wallet-integration';
import { tokenRegistry } from '../../blockchain/token-registry';
import { validateTransaction } from '../security/contract-validator';
import { publicClient } from '../../blockchain/providers';

export interface TransferParams {
  // Token information (null for ETH)
  tokenAddress?: `0x${string}` | null;
  
  // Transfer details
  to: `0x${string}`;
  amount: string;
  
  // Chain information
  chainId: number;
  
  // Transaction options
  gasLimit?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
}

export interface TransferResult {
  transactionHash: `0x${string}`;
  tokenAddress: `0x${string}` | null;
  to: `0x${string}`;
  amount: string;
  amountInWei: bigint;
  status: 'pending' | 'success' | 'failed';
  confirmations?: number;
  receipt?: any;
  error?: string;
}

export class TokenTransferAgent {
  private transfers = new Map<string, TransferResult>();

  // Transfer ETH or tokens
  async transferTokens(
    walletServiceInstance: WalletIntegrationService,
    params: TransferParams
  ): Promise<TransferResult> {
    try {
      // Validate wallet connection
      if (!walletServiceInstance) {
        throw new Error("Wallet service instance not provided");
      }
      
      // Get connected wallet address (don't check .isConnected() as it may be a mock)
      const fromAddress = walletServiceInstance.getAddress();
      if (!fromAddress) {
        throw new Error("Wallet not connected");
      }
      
      // Validate recipient address
      if (!params.to || !params.to.startsWith('0x')) {
        throw new Error("Invalid recipient address");
      }
      
      // Validate amount
      if (!params.amount || parseFloat(params.amount) <= 0) {
        throw new Error("Invalid amount");
      }
      
      // Determine if this is an ETH or token transfer
      const isEthTransfer = !params.tokenAddress;
      
      let amountInWei: bigint;
      let txHash: `0x${string}`;
      
      if (isEthTransfer) {
        // ETH transfer
        amountInWei = WalletIntegrationService.parseEther(params.amount);
        
        // Validate transaction
        const validationResult = await validateTransaction(params.to, amountInWei);
        if (!validationResult.valid) {
          throw new Error(`Transaction validation failed: ${validationResult.issues.map(i => i.title).join(', ')}`);
        }
        
        // Prepare transaction options
        const txOptions: any = {
          to: params.to,
          value: amountInWei
        };
        
        // Add gas parameters if provided
        if (params.gasLimit) {
          txOptions.gasLimit = BigInt(params.gasLimit);
        }
        if (params.maxFeePerGas) {
          txOptions.maxFeePerGas = BigInt(params.maxFeePerGas);
        }
        if (params.maxPriorityFeePerGas) {
          txOptions.maxPriorityFeePerGas = BigInt(params.maxPriorityFeePerGas);
        }
        
        // Send transaction
        txHash = await walletServiceInstance.sendTransaction(txOptions);
      } else {
        // Token transfer
        // Get token info
        const tokenInfo = await tokenRegistry.getToken(params.tokenAddress!, params.chainId);
        if (!tokenInfo) {
          // Try to load token info from blockchain
          await tokenRegistry.loadTokenInfo(params.tokenAddress!, params.chainId);
        }
        
        // Convert amount to token decimals
        const token = tokenRegistry.getToken(params.tokenAddress!, params.chainId);
        if (!token) {
          throw new Error(`Token information not found for ${params.tokenAddress}`);
        }
        
        // Calculate amount in wei based on token decimals
        amountInWei = WalletIntegrationService.parseEther(params.amount);
        if (token.decimals !== 18) {
          // Adjust for token decimals
          const decimalsDiff = 18 - token.decimals;
          if (decimalsDiff > 0) {
            amountInWei = amountInWei / BigInt(10 ** decimalsDiff);
          } else {
            amountInWei = amountInWei * BigInt(10 ** Math.abs(decimalsDiff));
          }
        }
        
        // Transfer tokens
        txHash = await tokenRegistry.transfer(
          walletServiceInstance,
          params.tokenAddress!,
          params.to,
          amountInWei,
          params.chainId
        );
      }
      
      // Create transfer result
      const transferResult: TransferResult = {
        transactionHash: txHash,
        tokenAddress: params.tokenAddress || null,
        to: params.to,
        amount: params.amount,
        amountInWei,
        status: 'pending'
      };
      
      // Store the transfer
      this.transfers.set(txHash, transferResult);
      
      // Wait for transaction confirmation in the background
      this.waitForTransfer(txHash, walletServiceInstance);
      
      return transferResult;
    } catch (error) {
      console.error('Token transfer error:', error);
      throw new Error(`Failed to transfer tokens: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Wait for transfer confirmation
  private async waitForTransfer(
    hash: `0x${string}`,
    walletServiceInstance: WalletIntegrationService
  ): Promise<void> {
    try {
      // Wait for transaction receipt
      const receipt = await walletServiceInstance.waitForTransaction(hash);
      
      // Update transfer result
      const transfer = this.transfers.get(hash);
      if (transfer) {
        transfer.status = receipt.status === 'success' ? 'success' : 'failed';
        transfer.confirmations = receipt.confirmations || 1;
        transfer.receipt = receipt;
        
        this.transfers.set(hash, transfer);
      }
    } catch (error) {
      console.error('Transfer confirmation error:', error);
      
      // Update transfer status to failed
      const transfer = this.transfers.get(hash);
      if (transfer) {
        transfer.status = 'failed';
        transfer.error = `Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
        this.transfers.set(hash, transfer);
      }
    }
  }

  // Get transfer status
  getTransfer(hash: `0x${string}`): TransferResult | null {
    return this.transfers.get(hash) || null;
  }

  // Get all transfers
  getAllTransfers(): TransferResult[] {
    return Array.from(this.transfers.values());
  }

  // Get pending transfers
  getPendingTransfers(): TransferResult[] {
    return Array.from(this.transfers.values()).filter(transfer => transfer.status === 'pending');
  }
}

// Export singleton instance
export const tokenTransferAgent = new TokenTransferAgent(); 

================================================================================
File: lib/agents/types.ts
================================================================================

// Core intent types
export type IntentType = 
  | 'MARKET_DATA' 
  | 'COMPARISON' 
  | 'TECHNICAL' 
  | 'DEFI'
  | 'REGULATORY'
  | 'NEWS_EVENTS'
  | 'SECURITY'
  | 'CONCEPTUAL'
  | 'HYBRID'
  | 'NEEDS_CONTEXT'
  | 'DEPLOY_CONTRACT'
  | 'TRANSFER_TOKENS'
  | 'CONNECT_WALLET';

// Market data types expanded
export type MarketDataType = 
  | 'price' 
  | 'market_cap' 
  | 'volume_24h' 
  | 'trending'
  | 'supply'
  | 'volume'
  | 'defi_tvl'
  | 'yield'
  | 'liquidity';

// Time frames
export type TimeFrame = 
  | 'current'
  | '24h'
  | '7d'
  | '30d'
  | null;

// Technical content types
export type TechnicalContentType =
  | 'smart_contract'
  | 'protocol'
  | 'architecture'
  | 'implementation'
  | 'code_example';

// News and regulatory content types
export type NewsContentType =
  | 'announcement'
  | 'update'
  | 'regulation'
  | 'policy'
  | 'security_incident'
  | 'market_event';

// DeFi specific types
export type DefiContentType =
  | 'protocol_metrics'
  | 'yield_data'
  | 'tvl_analysis'
  | 'pool_statistics'
  | 'farming_data';

// Enhanced comparison types
export interface ComparisonRequest {
  isComparison: boolean;
  tokens: string[];
  aspects: string[];
  primaryMetric: string | null;
  technicalAspects?: string[];
  defiMetrics?: string[];
}

// Web search context type
export interface WebSearchContext {
  needed: boolean;
  reason: string | null;
  suggestedQueries: string[];
  contentTypes: NewsContentType[];
  timeRange?: string;
}

// Analysis requirements
export interface DataRequirements {
  marketData: {
    needed: boolean;
    types: MarketDataType[];
    timeframe: TimeFrame;
    tokenCount: number;
  };
  conceptualData: {
    needed: boolean;
    aspects: string[];
  };
  technicalData?: {
    needed: boolean;
    types: TechnicalContentType[];
    codeLanguages?: string[];
  };
  defiData?: {
    needed: boolean;
    types: DefiContentType[];
    protocols?: string[];
  };
  newsData?: {
    needed: boolean;
    types: NewsContentType[];
    timeRange?: string;
  };
}

// Original context preservation
export interface OriginalContext {
  rawQuery: string;
  timestamp: number;
  preprocessingSteps: PreprocessingStep[];
  metadata: QueryMetadata;
}

export interface PreprocessingStep {
  operation: string;
  input: string;
  output: string;
}

export interface QueryMetadata {
  tokens: string[];
  entities: string[];
  contextualHints: string[];
  technicalTerms?: string[];
  defiProtocols?: string[];
}

// Main analysis interface
export interface RobustAnalysis {
  originalContext: OriginalContext;
  classification: {
    primaryIntent: IntentType;
    confidence: number;
    needsApiCall: boolean;
    ambiguityLevel: 'LOW' | 'MEDIUM' | 'HIGH';
    requiresWebSearch: boolean;
  };
  queryAnalysis: {
    sanitizedQuery: string;
    detectedTokens: string[];
    comparisonRequest: ComparisonRequest;
    detectedIntents: string[];
    timeContext: TimeFrame;
    marketIndicators: string[];
    conceptualIndicators: string[];
    webSearchContext: WebSearchContext;
    detectedEntities?: string[];
    entityParams?: {
      name?: string;
      symbol?: string;
      initialSupply?: string;
      [key: string]: any;
    };
    recipient?: string;
    amount?: string;
    tokenAddress?: string;
  };
  dataRequirements: DataRequirements;
}

// Input/Output types
export interface Agent1Input {
  query: string;
}

export interface SummarizationInput {
  userQuery: string;
  analysis: RobustAnalysis;
  aggregatorResult: AggregatorResult | null;
  sessionId?: string;
  enhancedContext?: string;
}

export interface AggregatorResult {
  primary?: {
    coingecko?: any;
    defiLlama?: any;
    theGraph?: any;
    coinmarketcap?: any;
  };
  fallback?: {
    googleSearch?: any;
    webSearch?: any;
    potentialCoinGeckoLinks?: string[];
    firstSnippet?: string;
  };
}

export interface OrchestrationResult {
  analysis: RobustAnalysis;
  aggregatorData: AggregatorResult | null;
  response: string;
  suggestions?: string[];
  contextAnalysis?: {
    isCoherent: boolean;
    confidence: number;
  };
}

// Aggregator specification
export interface AggregatorSpec {
  primary: {
    coingecko?: any;
    defiLlama?: any;
    theGraph?: any;
    news?: any;
    regulatory?: any;
    security?: any;
    blockchain?: any;
  };
  fallback: {
    coingecko?: any;
    webSearch?: any;
  };
}

================================================================================
File: lib/agents/validation.ts
================================================================================

import { z } from 'zod';
import type { RobustAnalysis } from './types';

// Custom error types
export class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public details?: z.ZodError
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class PreprocessingError extends Error {
  constructor(
    message: string,
    public step: string,
    public input?: string
  ) {
    super(message);
    this.name = 'PreprocessingError';
  }
}

export class LLMError extends Error {
  constructor(
    message: string,
    public response?: any
  ) {
    super(message);
    this.name = 'LLMError';
  }
}

// Validation schemas
const classificationSchema = z.object({
  primaryIntent: z.enum([
    'MARKET_DATA',
    'COMPARISON',
    'TECHNICAL',
    'DEFI',
    'REGULATORY',
    'NEWS_EVENTS',
    'SECURITY',
    'CONCEPTUAL',
    'HYBRID',
    'NEEDS_CONTEXT',
    'TRANSFER_TOKENS',
    'DEPLOY_CONTRACT',
    'CONNECT_WALLET',
    'BLOCKCHAIN_TRANSACTION',
    'NFT_INTERACTION'
  ] as const),
  confidence: z.number().min(0).max(1),
  needsApiCall: z.boolean(),
  ambiguityLevel: z.enum(['LOW', 'MEDIUM', 'HIGH'] as const),
  requiresWebSearch: z.boolean()
});

const comparisonRequestSchema = z.object({
  isComparison: z.boolean(),
  tokens: z.array(z.string()).max(5),
  aspects: z.array(z.string()),
  primaryMetric: z.string().nullable()
});

const webSearchContextSchema = z.object({
  needed: z.boolean(),
  reason: z.string().nullable(),
  suggestedQueries: z.array(z.string())
});

const queryAnalysisSchema = z.object({
  sanitizedQuery: z.string().min(1),
  detectedTokens: z.array(z.string()).max(5),
  comparisonRequest: comparisonRequestSchema,
  detectedIntents: z.array(z.string()),
  timeContext: z.enum(['current', '24h', '7d', '30d'] as const).nullable(),
  marketIndicators: z.array(z.string()),
  conceptualIndicators: z.array(z.string()),
  webSearchContext: webSearchContextSchema,
  // Optional blockchain-related fields
  detectedEntities: z.array(z.string()).optional(),
  entityParams: z.object({
    name: z.string().nullable(),
    symbol: z.string().nullable(),
    initialSupply: z.string().nullable()
  }).optional(),
  recipient: z.string().nullable().optional(),
  amount: z.string().nullable().optional(),
  tokenAddress: z.string().nullable().optional()
});

const marketDataSchema = z.object({
  needed: z.boolean(),
  types: z.array(z.string()),
  timeframe: z.enum(['current', '24h', '7d', '30d'] as const).nullable(),
  tokenCount: z.number().min(0).max(5)
});

const conceptualDataSchema = z.object({
  needed: z.boolean(),
  aspects: z.array(z.string())
});

const dataRequirementsSchema = z.object({
  marketData: marketDataSchema,
  conceptualData: conceptualDataSchema
});

const preprocessingStepSchema = z.object({
  operation: z.string(),
  input: z.string(),
  output: z.string()
});

const queryMetadataSchema = z.object({
  tokens: z.array(z.string()),
  entities: z.array(z.string()),
  contextualHints: z.array(z.string())
});

const originalContextSchema = z.object({
  rawQuery: z.string(),
  timestamp: z.number(),
  preprocessingSteps: z.array(preprocessingStepSchema),
  metadata: queryMetadataSchema
});

const llmResponseSchema = z.object({
  classification: classificationSchema,
  queryAnalysis: queryAnalysisSchema,
  dataRequirements: dataRequirementsSchema
});

const robustAnalysisSchema = z.object({
  originalContext: originalContextSchema,
  classification: classificationSchema,
  queryAnalysis: queryAnalysisSchema,
  dataRequirements: dataRequirementsSchema
});

export function validateLLMResponse(response: string): any {
  try {
    const parsed = JSON.parse(response);
    return llmResponseSchema.parse(parsed);
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new LLMError('Invalid JSON in LLM response', response);
    }
    if (error instanceof z.ZodError) {
      const details = error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');
      throw new LLMError(`Invalid response structure: ${details}`, response);
    }
    throw error;
  }
}

export function validateAnalysis(analysis: unknown): void {
  try {
    robustAnalysisSchema.parse(analysis);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      throw new ValidationError(
        `Invalid analysis: ${firstError.message}`,
        firstError.path.join('.'),
        error
      );
    }
    throw error;
  }
}

================================================================================
File: lib/api-client.ts
================================================================================

import { generateResponse } from './llm';
import { processBlockchainQuery } from './blockchain';

// Client-side API functions
export async function fetchBlockchainData(query: string) {
  try {
    const data = await processBlockchainQuery(query);
    if (!data) {
      throw new Error('No data returned from blockchain query');
    }
    return { data };
  } catch (error) {
    console.error('Blockchain query error:', error);
    throw error;
  }
}

export async function fetchChatResponse(query: string, context: any) {
  try {
    if (!query) {
      throw new Error('Query is required');
    }

    if (!context || !context.data) {
      throw new Error('Context data is required');
    }

    const response = await generateResponse(
      query,
      context.data,
      context.conversationHistory,
      {
        queryType: context.queryType || 'trending',
        temperature: 0.7,
        maxTokens: 500
      }
    );

    return { response };
  } catch (error) {
    console.error('Chat error:', error);
    throw error;
  }
}

================================================================================
File: lib/api/blockchain-api.ts
================================================================================

import { BlockchainActionParams, BlockchainActionResult } from '../agents/blockchain-orchestrator';
import { TokenInfo } from '../blockchain/token-registry';
import { DeploymentResult, DeploymentParams } from '../agents/deployment/contract-deployment-agent';
import { TransferResult, TransferParams } from '../agents/transaction/token-transfer-agent';
import { ContractTemplate } from '../agents/deployment/contract-templates';
import { WalletConnectionOptions } from '../blockchain/wallet-integration';
import { WalletIntegrationService } from '../blockchain/wallet-integration';

/**
 * Blockchain API Service
 * 
 * This service provides a simplified interface for frontend applications
 * to interact with blockchain functionality via server-side API.
 */
export class BlockchainApiService {
  // Session management
  private sessionId: string | null = null;

  /**
   * Set the session ID for blockchain operations
   * @param sessionId Session ID to use
   */
  setSessionId(sessionId: string): void {
    this.sessionId = sessionId;
  }

  /**
   * Get the current session ID
   * @returns Current session ID or null if not set
   */
  getSessionId(): string | null {
    return this.sessionId;
  }

  /**
   * Execute a blockchain action via the server API
   */
  private async executeBlockchainAction(action: BlockchainActionParams): Promise<BlockchainActionResult> {
    const response = await fetch('/api/blockchain', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        action,
        sessionId: this.sessionId || undefined
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: `Server error: ${response.status}` }));
      throw new Error(errorData.error || `Server error: ${response.status}`);
    }

    return await response.json();
  }

  /**
   * Connect to wallet
   * @param provider - Wallet provider (metamask, walletconnect, etc.)
   * @returns Connected wallet address
   */
  async connectWallet(provider: string): Promise<string> {
    const walletParams: WalletConnectionOptions = { 
      type: provider as any // Cast to any as a temporary solution
    };
    
    try {
      // First try to connect directly in the browser
      if (typeof window !== 'undefined') {
        // We're in the browser, try to connect directly
        const walletService = new WalletIntegrationService();
        const address = await walletService.connect(walletParams);
        return address;
      }
    } catch (error) {
      console.error('Browser wallet connection failed:', error);
      // Fall through to server-side approach if browser connection fails
    }
    
    // If we're not in the browser or direct connection failed, use the server API
    const result = await this.executeBlockchainAction({
      actionType: 'CONNECT_WALLET',
      walletParams
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to connect wallet');
    }
    
    // If the server indicates we need a browser connection, throw an appropriate error
    if (result.data.needsBrowserConnection) {
      throw new Error('Wallet connection requires a browser environment');
    }
    
    return result.data.address;
  }
  
  /**
   * Disconnect wallet
   */
  async disconnectWallet(): Promise<void> {
    await this.executeBlockchainAction({
      actionType: 'DISCONNECT_WALLET'
    });
  }
  
  /**
   * Deploy contract
   * @param templateId - Contract template ID
   * @param contractParams - Contract parameters
   * @param options - Deployment options
   * @returns Deployment result
   */
  async deployContract(
    templateId: string,
    contractParams: Record<string, any>,
    options: {
      value?: string;
      gasLimit?: string;
      maxFeePerGas?: string;
      maxPriorityFeePerGas?: string;
    } = {}
  ): Promise<DeploymentResult> {
    const deploymentParams: DeploymentParams = {
      templateId,
      templateParams: contractParams,
      value: options.value,
      gasLimit: options.gasLimit,
      maxFeePerGas: options.maxFeePerGas,
      maxPriorityFeePerGas: options.maxPriorityFeePerGas
    };
    
    const result = await this.executeBlockchainAction({
      actionType: 'DEPLOY_CONTRACT',
      deploymentParams
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to deploy contract');
    }
    
    return result.data;
  }
  
  /**
   * Transfer tokens
   * @param to - Recipient address
   * @param amount - Amount to transfer
   * @param tokenAddress - Token address (optional, if not provided, transfers ETH)
   * @param options - Transfer options
   * @returns Transfer result
   */
  async transferTokens(
    to: string,
    amount: string,
    tokenAddress?: string,
    options: {
      gasLimit?: string;
      maxFeePerGas?: string;
      maxPriorityFeePerGas?: string;
    } = {}
  ): Promise<TransferResult> {
    const transferParams: TransferParams = {
      to: to as `0x${string}`,
      amount,
      tokenAddress: tokenAddress as `0x${string}` | undefined,
      chainId: 1, // Default to Ethereum mainnet
      gasLimit: options.gasLimit,
      maxFeePerGas: options.maxFeePerGas,
      maxPriorityFeePerGas: options.maxPriorityFeePerGas
    };
    
    const result = await this.executeBlockchainAction({
      actionType: 'TRANSFER_TOKENS',
      transferParams
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to transfer tokens');
    }
    
    return result.data;
  }
  
  /**
   * Get token information
   * @param tokenAddress - Token address
   * @param chainId - Chain ID
   * @returns Token information
   */
  async getTokenInfo(tokenAddress: string, chainId: number): Promise<TokenInfo> {
    const result = await this.executeBlockchainAction({
      actionType: 'GET_TOKEN_INFO',
      tokenAddress: tokenAddress as `0x${string}`,
      chainId
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get token info');
    }
    
    return result.data;
  }
  
  /**
   * Get contract templates
   * @param category - Template category (optional)
   * @returns List of contract templates
   */
  async getContractTemplates(category?: string): Promise<ContractTemplate[]> {
    const result = await this.executeBlockchainAction({
      actionType: 'GET_CONTRACT_TEMPLATES',
      templateCategory: category
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get contract templates');
    }
    
    return result.data;
  }
  
  /**
   * Get deployment status
   * @param transactionHash - Transaction hash
   * @returns Deployment status
   */
  async getDeploymentStatus(transactionHash: string): Promise<DeploymentResult> {
    const result = await this.executeBlockchainAction({
      actionType: 'GET_DEPLOYMENT_STATUS',
      transactionHash: transactionHash as `0x${string}`
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get deployment status');
    }
    
    return result.data;
  }
  
  /**
   * Get transfer status
   * @param transactionHash - Transaction hash
   * @returns Transfer status
   */
  async getTransferStatus(transactionHash: string): Promise<TransferResult> {
    const result = await this.executeBlockchainAction({
      actionType: 'GET_TRANSFER_STATUS',
      transactionHash: transactionHash as `0x${string}`
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to get transfer status');
    }
    
    return result.data;
  }
  
  /**
   * Execute custom blockchain action
   * @param params - Action parameters
   * @returns Action result
   */
  async executeAction(params: BlockchainActionParams): Promise<BlockchainActionResult> {
    return this.executeBlockchainAction(params);
  }
}

// Export singleton instance
export const blockchainApi = new BlockchainApiService(); 

================================================================================
File: lib/blockchain.ts
================================================================================

import { getTrendingTokens, getTokenPrices, getTokenDetails } from './token-data';

type ConversationContext = {
  lastQuery?: string;
  lastResults?: any[];
  currentPage: number;
  messages: { role: 'user' | 'assistant'; content: string }[];
};

let conversationContext: ConversationContext = {
  currentPage: 1,
  messages: [],
};

export async function processBlockchainQuery(query: string) {
  if (!query?.trim()) {
    throw new Error('Query is required');
  }

  const lowercaseQuery = query.toLowerCase();
  
  try {
    // Store user message in context
    conversationContext.messages.push({ role: 'user', content: query });
    
    // Determine query type and get relevant data
    let data: any;
    
    if (lowercaseQuery.includes('trending') || lowercaseQuery.includes('popular')) {
      const trendingTokens = await getTrendingTokens();
      if (!trendingTokens?.length) {
        throw new Error('No trending tokens found');
      }

      const tokenIds = trendingTokens.map(trend => trend.item.id);
      const tokenPrices = await getTokenPrices(tokenIds);
      
      data = {
        trending: trendingTokens,
        prices: tokenPrices,
      };
    } else if (lowercaseQuery.includes('price') || 
               lowercaseQuery.includes('bitcoin') || 
               lowercaseQuery.includes('eth')) {
      // Extract token name from query
      const tokenQuery = lowercaseQuery.includes('bitcoin') ? 'bitcoin' :
                        lowercaseQuery.includes('eth') ? 'ethereum' :
                        lowercaseQuery.split(' ').find(word => 
                          !['what', 'is', 'the', 'price', 'of', 'show', 'me', 'tell'].includes(word)
                        );
      
      if (!tokenQuery) {
        throw new Error('Please specify which token you want to check');
      }

      const tokenInfo = await getTokenDetails(tokenQuery);
      if (!tokenInfo) {
        throw new Error(`Could not find information for token "${tokenQuery}"`);
      }

      data = { tokenInfo };
    } else {
      throw new Error('Please ask about trending tokens or specific token prices');
    }

    // Store data in context
    if (data) {
      conversationContext.lastResults = data;
      conversationContext.lastQuery = query;
    }

    return data;
  } catch (error) {
    console.error('Error processing blockchain query:', error);
    throw error;
  }
}

================================================================================
File: lib/blockchain/abis/erc20-abi.ts
================================================================================

// ERC20 ABI
export const erc20Abi = [
  // Read-only functions
  {
    inputs: [],
    name: 'name',
    outputs: [{ type: 'string', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'symbol',
    outputs: [{ type: 'string', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'decimals',
    outputs: [{ type: 'uint8', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'totalSupply',
    outputs: [{ type: 'uint256', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [{ type: 'address', name: 'account' }],
    name: 'balanceOf',
    outputs: [{ type: 'uint256', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      { type: 'address', name: 'owner' },
      { type: 'address', name: 'spender' }
    ],
    name: 'allowance',
    outputs: [{ type: 'uint256', name: '' }],
    stateMutability: 'view',
    type: 'function'
  },
  // Write functions
  {
    inputs: [
      { type: 'address', name: 'recipient' },
      { type: 'uint256', name: 'amount' }
    ],
    name: 'transfer',
    outputs: [{ type: 'bool', name: '' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      { type: 'address', name: 'sender' },
      { type: 'address', name: 'recipient' },
      { type: 'uint256', name: 'amount' }
    ],
    name: 'transferFrom',
    outputs: [{ type: 'bool', name: '' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      { type: 'address', name: 'spender' },
      { type: 'uint256', name: 'amount' }
    ],
    name: 'approve',
    outputs: [{ type: 'bool', name: '' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  // Events
  {
    anonymous: false,
    inputs: [
      { indexed: true, type: 'address', name: 'from' },
      { indexed: true, type: 'address', name: 'to' },
      { indexed: false, type: 'uint256', name: 'value' }
    ],
    name: 'Transfer',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, type: 'address', name: 'owner' },
      { indexed: true, type: 'address', name: 'spender' },
      { indexed: false, type: 'uint256', name: 'value' }
    ],
    name: 'Approval',
    type: 'event'
  }
] as const; 

================================================================================
File: lib/blockchain/config.ts
================================================================================

/**
 * Blockchain Configuration
 * 
 * This module provides configuration options for the blockchain integration.
 * It includes flags for enabling/disabling features based on the environment.
 */

// Environment detection
export const IS_DEVELOPMENT = process.env.NODE_ENV === 'development';
export const IS_TEST = process.env.NODE_ENV === 'test';
export const IS_BROWSER = typeof window !== 'undefined';
export const IS_SERVER = !IS_BROWSER;

// Feature flags (can be overridden by environment variables)
export const USE_MOCKS = process.env.USE_BLOCKCHAIN_MOCKS === 'true' || IS_TEST;
export const USE_HARDHAT = process.env.USE_HARDHAT === 'true' || (IS_DEVELOPMENT && !USE_MOCKS);
export const USE_TESTNET = process.env.USE_TESTNET === 'true' || (!IS_DEVELOPMENT && !IS_TEST);

// Network configuration
export const DEFAULT_NETWORK = USE_TESTNET ? 'sepolia' : (USE_HARDHAT ? 'localhost' : 'mainnet');
export const DEFAULT_CHAIN_ID = getChainIdForNetwork(DEFAULT_NETWORK);

// RPC URLs
export const RPC_URLS: Record<string, string> = {
  mainnet: process.env.MAINNET_RPC_URL || 'https://eth-mainnet.g.alchemy.com/v2/demo',
  sepolia: process.env.SEPOLIA_RPC_URL || 'https://eth-sepolia.g.alchemy.com/v2/demo',
  localhost: 'http://127.0.0.1:8545',
};

// Helper function to get chain ID for network
function getChainIdForNetwork(network: string): number {
  switch (network) {
    case 'mainnet': return 1;
    case 'sepolia': return 11155111;
    case 'localhost': return 1337;
    default: return 1;
  }
}

// Contract addresses for different networks
export const CONTRACT_ADDRESSES: Record<string, Record<string, string>> = {
  // Mainnet contract addresses
  mainnet: {
    SimpleToken: process.env.MAINNET_SIMPLE_TOKEN_ADDRESS || '',
  },
  
  // Sepolia contract addresses
  sepolia: {
    SimpleToken: process.env.SEPOLIA_SIMPLE_TOKEN_ADDRESS || '',
  },
  
  // Local Hardhat network addresses
  localhost: {
    SimpleToken: process.env.LOCAL_SIMPLE_TOKEN_ADDRESS || '0x5FbDB2315678afecb367f032d93F642f64180aa3', // Default first deployment address
  },
};

// Get contract address for current network
export function getContractAddress(contractName: string): string {
  return CONTRACT_ADDRESSES[DEFAULT_NETWORK]?.[contractName] || '';
} 

================================================================================
File: lib/blockchain/mock-provider.ts
================================================================================

/**
 * Mock Blockchain Provider
 * 
 * This module provides mock implementations of blockchain functionality for testing
 * and development without requiring a real blockchain connection.
 */

import { USE_MOCKS } from './config';

// Mock wallet state
let mockConnected = false;
let mockAddress = '0x0000000000000000000000000000000000000000';
let mockBalance = BigInt('1000000000000000000000'); // 1000 ETH
let mockTokenBalances: Record<string, bigint> = {};

// Mock transaction state
const mockTransactions = new Map<string, any>();
let txCounter = 1;

// Mock token data
const mockTokens: Record<string, any> = {
  '0x1234567890123456789012345678901234567890': {
    name: 'Test Token',
    symbol: 'TEST',
    decimals: 18,
    totalSupply: BigInt('1000000000000000000000000'), // 1 million tokens
  }
};

/**
 * Check if mocks are enabled
 */
export function isMockEnabled(): boolean {
  return USE_MOCKS;
}

/**
 * Mock connect to wallet
 */
export function mockConnect(address?: string): Promise<`0x${string}`> {
  return new Promise((resolve) => {
    setTimeout(() => {
      mockConnected = true;
      if (address) {
        mockAddress = address as `0x${string}`;
      } else {
        // Generate a random-looking address if none provided
        mockAddress = `0x${Math.floor(Math.random() * 10**16).toString(16).padStart(40, '0')}` as `0x${string}`;
      }
      resolve(mockAddress as `0x${string}`);
    }, 500); // Simulate network delay
  });
}

/**
 * Mock disconnect wallet
 */
export function mockDisconnect(): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(() => {
      mockConnected = false;
      resolve();
    }, 300);
  });
}

/**
 * Check if wallet is connected
 */
export function mockIsConnected(): boolean {
  return mockConnected;
}

/**
 * Get connected wallet address
 */
export function mockGetAddress(): `0x${string}` {
  return mockConnected ? mockAddress as `0x${string}` : '0x0000000000000000000000000000000000000000';
}

/**
 * Mock send transaction
 */
export function mockSendTransaction(options: any): Promise<`0x${string}`> {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Generate mock transaction hash
      const txHash = `0x${Math.floor(Math.random() * 10**16).toString(16).padStart(64, '0')}` as `0x${string}`;
      
      // Record the transaction
      mockTransactions.set(txHash, {
        hash: txHash,
        to: options.to,
        from: mockAddress,
        value: options.value || BigInt(0),
        data: options.data || '0x',
        status: 'pending',
        timestamp: Date.now(),
        gasUsed: BigInt(21000),
        blockNumber: null,
        confirmations: 0,
      });
      
      // Start confirmation simulation for this transaction
      simulateConfirmations(txHash);
      
      resolve(txHash);
    }, 1000);
  });
}

/**
 * Simulate transaction confirmations
 */
function simulateConfirmations(txHash: string): void {
  const tx = mockTransactions.get(txHash);
  if (!tx) return;
  
  // Initial confirmation after 2 seconds
  setTimeout(() => {
    const updatedTx = mockTransactions.get(txHash);
    if (updatedTx) {
      updatedTx.status = 'confirmed';
      updatedTx.blockNumber = 12345678 + txCounter++;
      updatedTx.confirmations = 1;
      mockTransactions.set(txHash, updatedTx);
      
      // Simulate more confirmations
      for (let i = 2; i <= 12; i++) {
        setTimeout(() => {
          const tx = mockTransactions.get(txHash);
          if (tx) {
            tx.confirmations = i;
            mockTransactions.set(txHash, tx);
          }
        }, i * 1000); // Each confirmation 1 second apart
      }
    }
  }, 2000);
}

/**
 * Mock wait for transaction
 */
export function mockWaitForTransaction(txHash: string, confirmations = 1): Promise<any> {
  return new Promise((resolve, reject) => {
    const checkConfirmation = () => {
      const tx = mockTransactions.get(txHash);
      if (!tx) {
        reject(new Error('Transaction not found'));
        return;
      }
      
      if (tx.confirmations >= confirmations) {
        resolve(tx);
      } else {
        setTimeout(checkConfirmation, 1000);
      }
    };
    
    checkConfirmation();
  });
}

/**
 * Mock get transaction
 */
export function mockGetTransaction(txHash: string): any {
  return mockTransactions.get(txHash) || null;
}

/**
 * Mock get pending transactions
 */
export function mockGetPendingTransactions(): any[] {
  return Array.from(mockTransactions.values())
    .filter(tx => tx.status === 'pending');
}

/**
 * Mock token transfer
 */
export function mockTransferToken(tokenAddress: string, to: string, amount: bigint): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const token = mockTokens[tokenAddress];
      if (!token) {
        reject(new Error('Token not found'));
        return;
      }
      
      // Mock successful transfer
      const txHash = `0x${Math.floor(Math.random() * 10**16).toString(16).padStart(64, '0')}`;
      
      // Record the transaction
      mockTransactions.set(txHash, {
        hash: txHash,
        to: tokenAddress,
        from: mockAddress,
        value: BigInt(0),
        data: `0xa9059cbb000000000000000000000000${to.substring(2)}${amount.toString(16).padStart(64, '0')}`,
        status: 'pending',
        timestamp: Date.now(),
        gasUsed: BigInt(65000),
        blockNumber: null,
        confirmations: 0,
        tokenTransfer: {
          token: tokenAddress,
          from: mockAddress,
          to: to,
          amount: amount
        }
      });
      
      // Start confirmation simulation
      simulateConfirmations(txHash);
      
      resolve(txHash);
    }, 1500);
  });
}

/**
 * Mock deploy contract
 */
export function mockDeployContract(abi: any[], bytecode: string, args: any[]): Promise<any> {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Generate a contract address
      const contractAddress = `0x${Math.floor(Math.random() * 10**16).toString(16).padStart(40, '0')}`;
      
      // Generate mock transaction hash
      const txHash = `0x${Math.floor(Math.random() * 10**16).toString(16).padStart(64, '0')}`;
      
      // Record the deployment transaction
      mockTransactions.set(txHash, {
        hash: txHash,
        from: mockAddress,
        to: null,
        value: BigInt(0),
        data: bytecode,
        status: 'pending',
        timestamp: Date.now(),
        gasUsed: BigInt(1500000),
        blockNumber: null,
        confirmations: 0,
        contractAddress: contractAddress
      });
      
      // Start confirmation simulation
      simulateConfirmations(txHash);
      
      // Return the contract
      resolve({
        address: contractAddress,
        deployTransaction: mockTransactions.get(txHash)
      });
    }, 2000);
  });
} 

================================================================================
File: lib/blockchain/providers.ts
================================================================================

import { createPublicClient, http } from 'viem';
import { mainnet, sepolia, arbitrum, optimism, polygon } from 'viem/chains';

// Get the RPC URL from environment variables or use default
const getRpcUrl = (network: string): string => {
  const envVar = `${network.toUpperCase()}_RPC_URL`;
  return process.env[envVar] || getDefaultRpcUrl(network);
};

// Default public RPC URLs (consider using your own for production)
const getDefaultRpcUrl = (network: string): string => {
  switch (network) {
    case 'mainnet': return 'https://eth-mainnet.g.alchemy.com/v2/demo';
    case 'sepolia': return 'https://eth-sepolia.g.alchemy.com/v2/demo';
    case 'arbitrum': return 'https://arb-mainnet.g.alchemy.com/v2/demo';
    case 'optimism': return 'https://opt-mainnet.g.alchemy.com/v2/demo';
    case 'polygon': return 'https://polygon-mainnet.g.alchemy.com/v2/demo';
    default: return 'https://eth-mainnet.g.alchemy.com/v2/demo';
  }
};

// Create public clients for different chains
export const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(getRpcUrl('mainnet'))
});

export const sepoliaClient = createPublicClient({
  chain: sepolia,
  transport: http(getRpcUrl('sepolia'))
});

export const arbitrumClient = createPublicClient({
  chain: arbitrum,
  transport: http(getRpcUrl('arbitrum'))
});

export const polygonClient = createPublicClient({
  chain: polygon,
  transport: http(getRpcUrl('polygon'))
});

export const getClientForChain = (chainId: number) => {
  switch (chainId) {
    case 1: return publicClient;
    case 11155111: return sepoliaClient;
    case 42161: return arbitrumClient;
    case 137: return polygonClient;
    default: return publicClient;
  }
}; 

================================================================================
File: lib/blockchain/session-manager.ts
================================================================================

/**
 * Blockchain Session Manager
 * 
 * This module provides session management for blockchain operations,
 * allowing wallet connections to persist between requests.
 */

import { WalletIntegrationService, WalletType } from './wallet-integration';
import { USE_MOCKS } from './config';

// Map to store wallet connections by session ID
interface SessionData {
  walletService: WalletIntegrationService;
  address: `0x${string}`;
  lastActive: number;
  chainId?: number;
}

class BlockchainSessionManager {
  private sessions: Map<string, SessionData> = new Map();
  
  // Session timeout in milliseconds (30 minutes)
  private readonly SESSION_TIMEOUT = 30 * 60 * 1000;
  
  /**
   * Get wallet service for a session
   * @param sessionId Session ID
   * @returns Wallet service if connected, undefined otherwise
   */
  getWalletService(sessionId: string): WalletIntegrationService | undefined {
    const session = this.sessions.get(sessionId);
    
    if (session) {
      // Update last active time
      session.lastActive = Date.now();
      return session.walletService;
    }
    
    return undefined;
  }
  
  /**
   * Get wallet address for a session
   * @param sessionId Session ID
   * @returns Wallet address if connected, undefined otherwise
   */
  getWalletAddress(sessionId: string): `0x${string}` | undefined {
    const session = this.sessions.get(sessionId);
    return session?.address;
  }
  
  /**
   * Check if a session has a connected wallet
   * @param sessionId Session ID
   * @returns true if wallet is connected, false otherwise
   */
  isWalletConnected(sessionId: string): boolean {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      return false;
    }
    
    // Verify wallet is still connected
    return session.walletService.isConnected();
  }
  
  /**
   * Store a wallet connection for a session
   * @param sessionId Session ID
   * @param walletService Wallet service instance
   * @param address Wallet address
   * @param chainId Chain ID
   */
  storeConnection(
    sessionId: string,
    walletService: WalletIntegrationService,
    address: `0x${string}`,
    chainId?: number
  ): void {
    // For mock connections, set the mock address
    if (address === '0x0000000000000000000000000000000000000000') {
      walletService.setMockAddress(address);
    }
    
    this.sessions.set(sessionId, {
      walletService,
      address,
      lastActive: Date.now(),
      chainId
    });
    
    console.log(`Stored connection for session ${sessionId}, address: ${address}`);
    
    // Make sure cleanup is scheduled
    this.scheduleCleanup();
  }
  
  /**
   * Remove a wallet connection for a session
   * @param sessionId Session ID
   */
  removeConnection(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    
    if (session) {
      // Disconnect wallet
      session.walletService.disconnect();
      // Remove session
      this.sessions.delete(sessionId);
    }
  }
  
  /**
   * Create and connect a new wallet for a session
   * @param sessionId Session ID
   * @param provider Wallet provider
   * @param chainId Chain ID
   * @returns Connected wallet address
   */
  async connectWallet(
    sessionId: string,
    provider: string,
    chainId?: number
  ): Promise<`0x${string}`> {
    // Check if we're in a server environment
    if (typeof window === 'undefined') {
      console.log('Server-side wallet connection requested, returning mock address');
      const mockAddress = '0x0000000000000000000000000000000000000000';
      
      // Create a mock wallet service
      const walletService = new WalletIntegrationService();
      walletService.setMockAddress(mockAddress);
      
      // Store the connection
      this.storeConnection(sessionId, walletService, mockAddress, chainId);
      
      return mockAddress;
    }
    
    // For browser environments, use the real wallet connection
    const walletService = new WalletIntegrationService();
    const address = await walletService.connect(provider as WalletType, { 
      type: provider as WalletType,
      chainId 
    });
    
    // Store the connection
    this.storeConnection(sessionId, walletService, address, chainId);
    
    return address;
  }
  
  /**
   * Clean up expired sessions
   */
  private cleanupSessions(): void {
    const now = Date.now();
    
    for (const [sessionId, session] of this.sessions.entries()) {
      if (now - session.lastActive > this.SESSION_TIMEOUT) {
        this.removeConnection(sessionId);
      }
    }
  }
  
  /**
   * Schedule periodic cleanup of expired sessions
   */
  private scheduleCleanup(): void {
    // Run cleanup every 5 minutes
    setInterval(() => this.cleanupSessions(), 5 * 60 * 1000);
  }
}

// Export singleton instance
export const sessionManager = new BlockchainSessionManager(); 

================================================================================
File: lib/blockchain/token-registry.ts
================================================================================

import { createPublicClient, http, getContract, PublicClient } from 'viem';
import { mainnet, sepolia, optimism, arbitrum } from 'viem/chains';
import { erc20Abi } from './abis/erc20-abi';
import { TransactionOptions, WalletIntegrationService } from './wallet-integration';
import { parseAbi, encodeFunctionData } from 'viem';

// Token information interface
export interface TokenInfo {
  address: `0x${string}`;
  chainId: number;
  name: string;
  symbol: string;
  decimals: number;
  logoURI?: string;
  isVerified?: boolean;
}

// Chain configuration
interface ChainConfig {
  chainId: number;
  client: PublicClient;
}

// Common ERC20 ABI functions
const ERC20_ABI = parseAbi([
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address owner) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function transfer(address to, uint256 value) returns (bool)',
  'function approve(address spender, uint256 value) returns (bool)',
  'function transferFrom(address from, address to, uint256 value) returns (bool)'
]);

export class TokenRegistry {
  private tokens: Map<string, TokenInfo> = new Map();
  private chains: Map<number, ChainConfig> = new Map();
  
  constructor() {
    // Initialize supported chains
    this.initializeChains();
  }
  
  private initializeChains(): void {
    // Mainnet
    this.chains.set(1, {
      chainId: 1,
      client: createPublicClient({
        chain: mainnet,
        transport: http()
      })
    });
    
    // Sepolia (Ethereum testnet)
    this.chains.set(11155111, {
      chainId: 11155111,
      client: createPublicClient({
        chain: sepolia,
        transport: http()
      })
    });
    
    // Optimism
    this.chains.set(10, {
      chainId: 10,
      client: createPublicClient({
        chain: optimism,
        transport: http()
      })
    });
    
    // Arbitrum
    this.chains.set(42161, {
      chainId: 42161,
      client: createPublicClient({
        chain: arbitrum,
        transport: http()
      })
    });
  }
  
  // Get token key (chainId + address)
  private getTokenKey(address: `0x${string}`, chainId: number): string {
    return `${chainId}-${address.toLowerCase()}`;
  }
  
  // Add token to registry
  addToken(token: TokenInfo): void {
    const key = this.getTokenKey(token.address, token.chainId);
    this.tokens.set(key, token);
  }
  
  // Get token from registry
  getToken(address: `0x${string}`, chainId: number): TokenInfo | undefined {
    const key = this.getTokenKey(address, chainId);
    return this.tokens.get(key);
  }
  
  // Load token info from blockchain
  async loadTokenInfo(address: `0x${string}`, chainId: number): Promise<TokenInfo> {
    // Check if chain is supported
    const chainConfig = this.chains.get(chainId);
    if (!chainConfig) {
      throw new Error(`Chain ID ${chainId} is not supported`);
    }
    
    try {
      // Create contract instance
      const contract = getContract({
        address,
        abi: erc20Abi,
        publicClient: chainConfig.client
      });
      
      // Get token info
      const [name, symbol, decimals] = await Promise.all([
        contract.read.name(),
        contract.read.symbol(),
        contract.read.decimals()
      ]);
      
      // Create token info
      const tokenInfo: TokenInfo = {
        address,
        chainId,
        name: name as string,
        symbol: symbol as string,
        decimals: Number(decimals),
        isVerified: false
      };
      
      // Add to registry
      this.addToken(tokenInfo);
      
      return tokenInfo;
    } catch (error) {
      console.error('Error loading token info:', error);
      throw new Error(`Failed to load token info for ${address} on chain ${chainId}`);
    }
  }
  
  // Get all tokens
  getAllTokens(): TokenInfo[] {
    return Array.from(this.tokens.values());
  }
  
  // Get tokens by chain
  getTokensByChain(chainId: number): TokenInfo[] {
    return this.getAllTokens().filter(token => token.chainId === chainId);
  }
  
  // Check if token exists
  hasToken(address: `0x${string}`, chainId: number): boolean {
    const key = this.getTokenKey(address, chainId);
    return this.tokens.has(key);
  }
  
  // Remove token from registry
  removeToken(address: `0x${string}`, chainId: number): boolean {
    const key = this.getTokenKey(address, chainId);
    return this.tokens.delete(key);
  }
  
  // Clear registry
  clearRegistry(): void {
    this.tokens.clear();
  }
  
  // Get token balance
  async getBalance(tokenAddress: `0x${string}`, ownerAddress: `0x${string}`, chainId: number): Promise<bigint> {
    const chainConfig = this.chains.get(chainId);
    if (!chainConfig) {
      throw new Error(`Chain ID ${chainId} is not supported`);
    }
    
    const balance = await chainConfig.client.readContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: 'balanceOf',
      args: [ownerAddress]
    });
    
    return balance as bigint;
  }
  
  // Transfer tokens
  async transfer(
    walletServiceInstance: WalletIntegrationService,
    tokenAddress: `0x${string}`, 
    to: `0x${string}`, 
    amount: bigint, 
    chainId: number
  ): Promise<`0x${string}`> {
    if (!walletServiceInstance.isConnected()) {
      throw new Error('Wallet not connected');
    }
    
    // Encode the transfer function call
    const data = encodeFunctionData({
      abi: ERC20_ABI,
      functionName: 'transfer',
      args: [to, amount]
    });
    
    // Create transaction options
    const txOptions: TransactionOptions = {
      to: tokenAddress,
      data,
      value: 0n
    };
    
    // Send the transaction
    return walletServiceInstance.sendTransaction(txOptions);
  }
  
  // Approve token spending
  async approve(
    walletServiceInstance: WalletIntegrationService,
    tokenAddress: `0x${string}`, 
    spender: `0x${string}`, 
    amount: bigint, 
    chainId: number
  ): Promise<`0x${string}`> {
    if (!walletServiceInstance.isConnected()) {
      throw new Error('Wallet not connected');
    }
    
    // Encode the approve function call
    const data = encodeFunctionData({
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [spender, amount]
    });
    
    // Create transaction options
    const txOptions: TransactionOptions = {
      to: tokenAddress,
      data,
      value: 0n
    };
    
    // Send the transaction
    return walletServiceInstance.sendTransaction(txOptions);
  }
  
  // Get token allowance
  async getAllowance(
    tokenAddress: `0x${string}`,
    ownerAddress: `0x${string}`,
    spenderAddress: `0x${string}`,
    chainId: number
  ): Promise<bigint> {
    const chainConfig = this.chains.get(chainId);
    if (!chainConfig) {
      throw new Error(`Chain ID ${chainId} is not supported`);
    }
    
    const allowance = await chainConfig.client.readContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: 'allowance',
      args: [ownerAddress, spenderAddress]
    });
    
    return allowance as bigint;
  }
}

// Export singleton instance
export const tokenRegistry = new TokenRegistry();

// Common tokens
const COMMON_TOKENS: TokenInfo[] = [
  {
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' as `0x${string}`,
    name: 'Wrapped Ether',
    symbol: 'WETH',
    decimals: 18,
    chainId: 1,
    logoURI: 'https://assets.coingecko.com/coins/images/2518/thumb/weth.png'
  },
  {
    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' as `0x${string}`,
    name: 'USD Coin',
    symbol: 'USDC',
    decimals: 6,
    chainId: 1,
    logoURI: 'https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png'
  },
  {
    address: '0xdAC17F958D2ee523a2206206994597C13D831ec7' as `0x${string}`,
    name: 'Tether',
    symbol: 'USDT',
    decimals: 6,
    chainId: 1,
    logoURI: 'https://assets.coingecko.com/coins/images/325/thumb/Tether.png'
  }
];

// Initialize common tokens
COMMON_TOKENS.forEach(token => tokenRegistry.addToken(token)); 

================================================================================
File: lib/blockchain/wallet-integration.ts
================================================================================

import { createWalletClient, http, custom, parseEther, parseGwei } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet, sepolia, arbitrum } from 'viem/chains';
import { publicClient } from './providers';
import { USE_MOCKS } from './config';
import * as mockProvider from './mock-provider';

// Supported wallet types
export type WalletType = 'metamask' | 'walletconnect' | 'private-key' | 'hardware' | 'mock';

// Wallet connection options
export interface WalletConnectionOptions {
  type: WalletType;
  chainId?: number;
  privateKey?: string;
  rpcUrl?: string;
}

// Transaction options 
export interface TransactionOptions {
  to: `0x${string}`;
  value?: bigint;
  data?: `0x${string}`;
  gasLimit?: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
  nonce?: number;
}

export class WalletIntegrationService {
  private walletClient: any = null;
  private connectedChainId: number | null = null;
  private connectedAddress: `0x${string}` = '0x0000000000000000000000000000000000000000';
  private pendingTransactions = new Map<string, any>();
  private walletType: WalletType | null = null;
  private address: `0x${string}` | null = null;
  private provider: any = null;
  private signer: any = null;
  private chainId: number = 1;
  private isMockConnection: boolean = false;

  /**
   * Set a mock wallet address for server-side operations
   * This allows the wallet to appear as connected without an actual wallet
   * @param address Mock wallet address
   */
  setMockAddress(address: `0x${string}`): void {
    this.address = address;
    this.walletType = 'mock';
    this.isMockConnection = true;
    console.log(`Set mock wallet address: ${address}`);
  }

  /**
   * Connect to a wallet
   * @param type Type of wallet to connect to
   * @param options Connection options
   * @returns Connected wallet address
   */
  async connect(
    type: WalletType = 'metamask',
    options: WalletConnectionOptions = { type: 'metamask' }
  ): Promise<`0x${string}`> {
    try {
      // Check if we're in a server environment
      if (typeof window === 'undefined') {
        console.log('Server-side wallet connection requested, returning mock address');
        // Return a mock address for server-side rendering
        return '0x0000000000000000000000000000000000000000';
      }
      
      // Use mock provider if mocks are enabled
      if (USE_MOCKS) {
        console.log('Using mock provider for wallet connection');
        const address = await mockProvider.mockConnect();
        this.connectedAddress = address;
        return this.connectedAddress;
      }
      
      const chainId = options.chainId || 1; // Default to Ethereum mainnet
      let chain;
      
      // Determine the chain
      switch (chainId) {
        case 1:
          chain = mainnet;
          break;
        case 11155111:
          chain = sepolia;
          break;
        case 42161:
          chain = arbitrum;
          break;
        default:
          throw new Error(`Chain ID ${chainId} not supported`);
      }

      // Connect based on wallet type
      switch (type) {
        case 'metamask':
          if (!window.ethereum) {
            throw new Error('MetaMask not detected in browser');
          }
          
          this.walletClient = createWalletClient({
            chain,
            transport: custom(window.ethereum)
          });
          
          // Request accounts
          const accounts = await this.walletClient.requestAddresses();
          if (!accounts || accounts.length === 0) {
            throw new Error('No accounts found in MetaMask');
          }
          
          this.connectedAddress = accounts[0];
          break;
          
        case 'private-key':
          if (!options.privateKey) {
            throw new Error('Private key is required');
          }
          
          // Create account from private key
          const account = privateKeyToAccount(options.privateKey as `0x${string}`);
          
          this.walletClient = createWalletClient({
            account,
            chain,
            transport: http(options.rpcUrl || 'https://eth-mainnet.g.alchemy.com/v2/demo')
          });
          
          this.connectedAddress = account.address;
          break;
          
        case 'walletconnect':
          throw new Error('WalletConnect integration not implemented yet');
          
        case 'hardware':
          throw new Error('Hardware wallet integration not implemented yet');
          
        case 'mock':
          if (this.address) {
            this.connectedAddress = this.address;
          } else {
            this.connectedAddress = '0x0000000000000000000000000000000000000000';
          }
          break;
          
        default:
          throw new Error(`Wallet type ${type} not supported`);
      }

      this.connectedChainId = chainId;
      
      console.log(`Wallet connected: ${this.connectedAddress} on chain ${chainId}`);
      return this.connectedAddress;
      
    } catch (error) {
      console.error('Wallet connection error:', error);
      throw new Error(`Failed to connect wallet: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Check if wallet is connected
   * @returns True if wallet is connected
   */
  isConnected(): boolean {
    if (USE_MOCKS) {
      return mockProvider.mockIsConnected();
    }
    
    return !!this.walletClient && !!this.connectedAddress || this.isMockConnection;
  }

  /**
   * Get connected wallet address
   * @returns Wallet address or null if not connected
   */
  getAddress(): `0x${string}` | null {
    if (USE_MOCKS) {
      return mockProvider.mockGetAddress() as `0x${string}`;
    }
    
    if (!this.isConnected()) {
      throw new Error('Wallet not connected');
    }
    return this.connectedAddress!;
  }

  // Send a transaction
  async sendTransaction(options: TransactionOptions): Promise<`0x${string}`> {
    if (!this.isConnected()) {
      throw new Error('Wallet not connected');
    }
    
    if (USE_MOCKS) {
      return mockProvider.mockSendTransaction(options) as `0x${string}`;
    }
    
    try {
      // If gas parameters aren't provided, estimate them
      if (!options.maxFeePerGas || !options.maxPriorityFeePerGas) {
        const feeData = await publicClient.estimateFeesPerGas();
        options.maxFeePerGas = options.maxFeePerGas || feeData.maxFeePerGas;
        options.maxPriorityFeePerGas = options.maxPriorityFeePerGas || feeData.maxPriorityFeePerGas;
      }

      // If gas limit isn't provided, estimate it
      if (!options.gasLimit) {
        const gasLimit = await publicClient.estimateGas({
          account: this.connectedAddress!,
          to: options.to,
          value: options.value || 0n,
          data: options.data
        });
        
        // Add a 20% buffer to the gas limit to be safe
        options.gasLimit = (gasLimit * 120n) / 100n;
      }

      // If nonce isn't provided, get the next nonce
      if (options.nonce === undefined) {
        options.nonce = await publicClient.getTransactionCount({
          address: this.connectedAddress!
        });
      }

      // Send the transaction
      const hash = await this.walletClient.sendTransaction({
        account: this.walletClient.account || this.connectedAddress!,
        to: options.to,
        value: options.value || 0n,
        data: options.data,
        gasLimit: options.gasLimit,
        maxFeePerGas: options.maxFeePerGas,
        maxPriorityFeePerGas: options.maxPriorityFeePerGas,
        nonce: options.nonce
      });

      // Store the pending transaction
      this.pendingTransactions.set(hash, {
        ...options,
        hash,
        timestamp: Date.now(),
        status: 'pending'
      });

      return hash;
    } catch (error) {
      console.error('Transaction error:', error);
      throw new Error(`Failed to send transaction: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Wait for transaction confirmation
  async waitForTransaction(hash: `0x${string}`, confirmations = 1): Promise<any> {
    if (USE_MOCKS) {
      return mockProvider.mockWaitForTransaction(hash, confirmations);
    }
    
    try {
      const receipt = await publicClient.waitForTransactionReceipt({
        hash,
        confirmations
      });

      // Update the transaction status
      if (this.pendingTransactions.has(hash)) {
        const tx = this.pendingTransactions.get(hash);
        this.pendingTransactions.set(hash, {
          ...tx,
          status: receipt.status === 'success' ? 'confirmed' : 'failed',
          receipt
        });
      }

      return receipt;
    } catch (error) {
      console.error('Transaction confirmation error:', error);
      
      // Update the transaction status to failed
      if (this.pendingTransactions.has(hash)) {
        const tx = this.pendingTransactions.get(hash);
        this.pendingTransactions.set(hash, {
          ...tx,
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
      
      throw error;
    }
  }

  // Get pending transactions
  getPendingTransactions(): any[] {
    return Array.from(this.pendingTransactions.values()).filter(tx => tx.status === 'pending');
  }

  // Get transaction by hash
  getTransaction(hash: `0x${string}`): any {
    if (USE_MOCKS) {
      return mockProvider.mockGetTransaction(hash);
    }
    
    return this.pendingTransactions.get(hash) || null;
  }

  // Disconnect wallet
  disconnect(): void {
    if (USE_MOCKS) {
      mockProvider.mockDisconnect();
    }
    
    this.walletClient = null;
    this.connectedAddress = '0x0000000000000000000000000000000000000000';
    this.connectedChainId = null;
    console.log('Wallet disconnected');
  }

  // Helper function to convert ETH string to wei BigInt
  static parseEther(amount: string): bigint {
    return parseEther(amount);
  }

  // Helper function to convert Gwei string to wei BigInt
  static parseGwei(amount: string): bigint {
    return parseGwei(amount);
  }
}

// Export singleton instance
export const walletService = new WalletIntegrationService(); 

================================================================================
File: lib/conversation-store.ts
================================================================================

import { v4 as uuidv4 } from 'uuid';
import { IntentType } from './agents/types';

export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  metadata?: {
    tokens?: string[];
    intent?: IntentType;
    confidence?: number;
    topics?: string[];
    entities?: string[];
    contextualHints?: string[];
    followUp?: boolean;
    referenceMessageId?: string;
    contextConfidence?: number;
  };
  id: string;
}

export interface TopicMetadata {
  name: string;
  frequency: number;
  lastMentioned: number;
  relatedTokens: string[];
  confidence: number;
}

export interface UserPreferences {
  favoriteTokens: Map<string, number>; // token -> frequency
  preferredTimeframes: Set<string>;
  interests: Set<string>;
  technicalLevel: 'basic' | 'intermediate' | 'advanced';
  lastUpdated: number;
}

export interface ConversationMetadata {
  lastActive: number;
  messageCount: number;
  topics: Map<string, TopicMetadata>;
  userPreferences: UserPreferences;
  continuityScore: number; // Measure of conversation coherence
}

export class ConversationStore {
  private static conversations = new Map<string, ChatMessage[]>();
  private static metadata = new Map<string, ConversationMetadata>();
  private static readonly MAX_MESSAGES = 50; // Increased from 20
  private static readonly EXPIRY_TIME = 24 * 60 * 60 * 1000; // Extended to 24 hours
  private static readonly TOPIC_RELEVANCE_DECAY = 0.8; // Topic relevance decay factor

  static getMessages(sessionId: string): ChatMessage[] {
    this.cleanExpiredSessions();
    return this.conversations.get(sessionId) || [];
  }

  static addMessage(sessionId: string, message: Omit<ChatMessage, 'id'>): void {
    const convo = this.getMessages(sessionId);
    const messageWithId: ChatMessage = {
      ...message,
      id: uuidv4(),
      timestamp: message.timestamp || Date.now()
    };

    convo.push(messageWithId);

    // Update metadata
    const metadata = this.getMetadata(sessionId);
    metadata.lastActive = Date.now();
    metadata.messageCount++;

    // Update topic metadata
    if (message.metadata?.intent) {
      this.updateTopicMetadata(metadata, message);
    }

    // Update user preferences
    if (message.metadata?.tokens) {
      this.updateUserPreferences(metadata, message);
    }

    // Calculate conversation continuity
    this.updateContinuityScore(metadata, convo);

    this.metadata.set(sessionId, metadata);
    this.truncate(sessionId);
    this.conversations.set(sessionId, convo);
  }

  private static updateTopicMetadata(metadata: ConversationMetadata, message: Omit<ChatMessage, 'id'>): void {
    const { intent, tokens = [], confidence = 0 } = message.metadata!;
    const topics = metadata.topics;
    
    if (!topics.has(intent!)) {
      topics.set(intent!, {
        name: intent!,
        frequency: 1,
        lastMentioned: message.timestamp,
        relatedTokens: tokens,
        confidence
      });
    } else {
      const topic = topics.get(intent!)!;
      topic.frequency++;
      topic.lastMentioned = message.timestamp;
      topic.relatedTokens = Array.from(new Set([...topic.relatedTokens, ...tokens]));
      topic.confidence = Math.max(topic.confidence, confidence);
    }
  }

  private static updateUserPreferences(metadata: ConversationMetadata, message: Omit<ChatMessage, 'id'>): void {
    const { tokens = [], contextualHints = [] } = message.metadata!;
    const prefs = metadata.userPreferences;

    // Update token frequencies
    tokens.forEach(token => {
      prefs.favoriteTokens.set(token, (prefs.favoriteTokens.get(token) || 0) + 1);
    });

    // Update interests based on contextual hints
    contextualHints.forEach(hint => prefs.interests.add(hint));

    // Infer technical level
    if (contextualHints.includes('TECHNICAL') || contextualHints.includes('CODE')) {
      prefs.technicalLevel = 'advanced';
    } else if (contextualHints.includes('INTERMEDIATE')) {
      prefs.technicalLevel = 'intermediate';
    }

    prefs.lastUpdated = message.timestamp;
  }

  private static updateContinuityScore(metadata: ConversationMetadata, messages: ChatMessage[]): void {
    if (messages.length < 2) {
      metadata.continuityScore = 1;
      return;
    }

    // Calculate continuity based on:
    // 1. Time between messages
    // 2. Topic consistency
    // 3. Token overlap
    let totalScore = 0;
    for (let i = 1; i < messages.length; i++) {
      const current = messages[i];
      const previous = messages[i - 1];
      
      // Time factor (decay over time)
      const timeDiff = current.timestamp - previous.timestamp;
      const timeFactor = Math.exp(-timeDiff / (30 * 60 * 1000)); // 30 minute half-life

      // Topic consistency
      const topicFactor = current.metadata?.intent === previous.metadata?.intent ? 1 : 0.5;

      // Token overlap
      const currentTokens = new Set(current.metadata?.tokens || []);
      const previousTokens = new Set(previous.metadata?.tokens || []);
      const overlap = new Set([...currentTokens].filter(x => previousTokens.has(x)));
      const tokenFactor = overlap.size > 0 ? 1 : 0.7;

      totalScore += (timeFactor + topicFactor + tokenFactor) / 3;
    }

    metadata.continuityScore = totalScore / (messages.length - 1);
  }

  static truncate(sessionId: string, maxMessages = this.MAX_MESSAGES): void {
    const convo = this.getMessages(sessionId);
    if (convo.length > maxMessages) {
      // Keep system messages and recent messages
      const systemMessages = convo.filter(m => m.role === 'system');
      const recentMessages = convo.slice(-maxMessages + systemMessages.length);
      const truncated = [...systemMessages, ...recentMessages];
      
      this.conversations.set(sessionId, truncated);
      
      // Update metadata
      const metadata = this.getMetadata(sessionId);
      metadata.messageCount = truncated.length;
      this.metadata.set(sessionId, metadata);
    }
  }

  static getMetadata(sessionId: string): ConversationMetadata {
    if (!this.metadata.has(sessionId)) {
      this.metadata.set(sessionId, {
        lastActive: Date.now(),
        messageCount: 0,
        topics: new Map(),
        userPreferences: {
          favoriteTokens: new Map(),
          preferredTimeframes: new Set(),
          interests: new Set(),
          technicalLevel: 'basic',
          lastUpdated: Date.now()
        },
        continuityScore: 1
      });
    }
    return this.metadata.get(sessionId)!;
  }

  static createSession(): string {
    const sessionId = uuidv4();
    this.conversations.set(sessionId, []);
    this.metadata.set(sessionId, this.getMetadata(sessionId));
    return sessionId;
  }

  static cleanExpiredSessions(): void {
    const now = Date.now();
    for (const [sessionId, metadata] of this.metadata.entries()) {
      if (now - metadata.lastActive > this.EXPIRY_TIME) {
        this.conversations.delete(sessionId);
        this.metadata.delete(sessionId);
      }
    }
  }

  static getRecentContext(sessionId: string, maxMessages = 5): ChatMessage[] {
    const messages = this.getMessages(sessionId);
    const metadata = this.getMetadata(sessionId);
    
    // Apply topic relevance decay
    const now = Date.now();
    metadata.topics.forEach((topic, key) => {
      const age = (now - topic.lastMentioned) / (60 * 60 * 1000); // Hours
      const relevance = Math.pow(this.TOPIC_RELEVANCE_DECAY, age);
      if (relevance < 0.1) {
        metadata.topics.delete(key);
      }
    });

    // Get messages with high continuity
    return messages
      .slice(-maxMessages)
      .filter(msg => {
        // Keep messages that:
        // 1. Are recent (< 1 hour old)
        // 2. Share topics with current conversation
        // 3. Have overlapping tokens with recent messages
        const age = (now - msg.timestamp) / (60 * 60 * 1000);
        if (age < 1) return true;
        
        const hasRelevantTopic = msg.metadata?.intent && 
          metadata.topics.has(msg.metadata.intent);
        
        const hasTokenOverlap = msg.metadata?.tokens?.some(token => 
          metadata.userPreferences.favoriteTokens.has(token));
        
        return hasRelevantTopic || hasTokenOverlap;
      });
  }

  static getTopics(sessionId: string): TopicMetadata[] {
    const metadata = this.getMetadata(sessionId);
    return Array.from(metadata.topics.values())
      .sort((a, b) => b.lastMentioned - a.lastMentioned);
  }

  static getUserPreferences(sessionId: string): UserPreferences {
    return this.getMetadata(sessionId).userPreferences;
  }

  static getFavoriteTokens(sessionId: string, limit = 5): string[] {
    const prefs = this.getUserPreferences(sessionId);
    return Array.from(prefs.favoriteTokens.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([token]) => token);
  }

  static getConversationSummary(sessionId: string): {
    messageCount: number;
    continuityScore: number;
    dominantTopics: string[];
    userLevel: string;
    favoriteTokens: string[];
  } {
    const metadata = this.getMetadata(sessionId);
    const topics = Array.from(metadata.topics.values())
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 3)
      .map(t => t.name);

    return {
      messageCount: metadata.messageCount,
      continuityScore: metadata.continuityScore,
      dominantTopics: topics,
      userLevel: metadata.userPreferences.technicalLevel,
      favoriteTokens: this.getFavoriteTokens(sessionId)
    };
  }
}

================================================================================
File: lib/conversation/context-builder.ts
================================================================================

import { ChatMessage, ConversationStore } from '../conversation-store';
import { RobustAnalysis, IntentType } from '../agents/types';

export interface EnhancedContext {
  recentMessages: ChatMessage[];
  userPreferences: {
    favoriteTokens: string[];
    technicalLevel: string;
    interests: string[];
  };
  conversationMetrics: {
    continuityScore: number;
    dominantTopics: string[];
    messageCount: number;
  };
  currentQuery: {
    analysis: RobustAnalysis;
    relatedTopics: string[];
    detectedTokens: string[];
  };
}

export function buildEnhancedContext(
  sessionId: string,
  currentAnalysis: RobustAnalysis,
  maxMessages = 5
): EnhancedContext {
  // Get conversation summary
  const summary = ConversationStore.getConversationSummary(sessionId);
  const recentMessages = ConversationStore.getRecentContext(sessionId, maxMessages);
  const prefs = ConversationStore.getUserPreferences(sessionId);

  // Find related topics from history
  const relatedTopics = ConversationStore.getTopics(sessionId)
    .filter(topic => {
      // Topic is related if it:
      // 1. Shares tokens with current query
      // 2. Has the same intent
      // 3. Was recently discussed
      const hasSharedTokens = topic.relatedTokens.some(token => 
        currentAnalysis.queryAnalysis.detectedTokens.includes(token)
      );
      
      const hasSameIntent = topic.name === currentAnalysis.classification.primaryIntent;
      
      const isRecent = (Date.now() - topic.lastMentioned) < (30 * 60 * 1000); // 30 minutes
      
      return hasSharedTokens || hasSameIntent || isRecent;
    })
    .map(topic => topic.name);

  return {
    recentMessages,
    userPreferences: {
      favoriteTokens: Array.from(prefs.favoriteTokens.keys()),
      technicalLevel: prefs.technicalLevel,
      interests: Array.from(prefs.interests)
    },
    conversationMetrics: {
      continuityScore: summary.continuityScore,
      dominantTopics: summary.dominantTopics,
      messageCount: summary.messageCount
    },
    currentQuery: {
      analysis: currentAnalysis,
      relatedTopics,
      detectedTokens: currentAnalysis.queryAnalysis.detectedTokens
    }
  };
}

export function formatContextForPrompt(context: EnhancedContext): string {
  const sections: string[] = [];

  // Format conversation history
  if (context.recentMessages.length > 0) {
    sections.push('Recent Conversation:\n' + context.recentMessages
      .map(msg => {
        const tokens = msg.metadata?.tokens?.join(', ') || '';
        const intent = msg.metadata?.intent || '';
        return `${msg.role.toUpperCase()}: ${msg.content}\n[tokens: ${tokens}, intent: ${intent}]`;
      })
      .join('\n\n')
    );
  }

  // Format user preferences
  sections.push('User Context:\n' + JSON.stringify({
    technicalLevel: context.userPreferences.technicalLevel,
    interests: context.userPreferences.interests,
    favoriteTokens: context.userPreferences.favoriteTokens
  }, null, 2));

  // Format conversation metrics
  sections.push('Conversation Metrics:\n' + JSON.stringify({
    messageCount: context.conversationMetrics.messageCount,
    continuityScore: context.conversationMetrics.continuityScore.toFixed(2),
    dominantTopics: context.conversationMetrics.dominantTopics
  }, null, 2));

  // Format current query information
  sections.push('Current Query Context:\n' + JSON.stringify({
    intent: context.currentQuery.analysis.classification.primaryIntent,
    confidence: context.currentQuery.analysis.classification.confidence.toFixed(2),
    detectedTokens: context.currentQuery.detectedTokens,
    relatedTopics: context.currentQuery.relatedTopics,
    timeContext: context.currentQuery.analysis.queryAnalysis.timeContext,
    marketIndicators: context.currentQuery.analysis.queryAnalysis.marketIndicators,
    conceptualIndicators: context.currentQuery.analysis.queryAnalysis.conceptualIndicators
  }, null, 2));

  return sections.join('\n\n');
}

export function analyzeContextContinuity(context: EnhancedContext): {
  isCoherent: boolean;
  confidence: number;
  suggestedFollowUp?: string;
} {
  const continuityScore = context.conversationMetrics.continuityScore;
  const currentIntent = context.currentQuery.analysis.classification.primaryIntent;
  const recentIntents = context.recentMessages
    .filter(msg => msg.metadata?.intent)
    .map(msg => msg.metadata!.intent);

  // Check if current query follows conversation flow
  const isRelatedToRecent = recentIntents.includes(currentIntent) ||
    context.currentQuery.relatedTopics.some(topic => 
      recentIntents.includes(topic as IntentType)
    );

  // Calculate confidence based on multiple factors
  const intentConfidence = context.currentQuery.analysis.classification.confidence;
  const topicRelevance = isRelatedToRecent ? 1 : 0.5;
  const overallConfidence = (continuityScore * 0.3 + intentConfidence * 0.4 + topicRelevance * 0.3);

  // Generate follow-up suggestion if conversation seems disconnected
  let suggestedFollowUp: string | undefined;
  if (!isRelatedToRecent && context.recentMessages.length > 0) {
    const lastTopic = recentIntents[recentIntents.length - 1];
    suggestedFollowUp = `Would you like to know how this relates to our previous discussion about ${lastTopic?.toLowerCase()}?`;
  }

  return {
    isCoherent: continuityScore > 0.7 && isRelatedToRecent,
    confidence: overallConfidence,
    suggestedFollowUp
  };
}

export function predictNextTopics(context: EnhancedContext): string[] {
  const currentIntent = context.currentQuery.analysis.classification.primaryIntent;
  const suggestions: string[] = [];

  // Add suggestions based on current intent
  switch (currentIntent) {
    case 'MARKET_DATA':
      suggestions.push(
        'price trends',
        'market comparison',
        'volume analysis'
      );
      break;
    case 'TECHNICAL':
      suggestions.push(
        'security implications',
        'implementation details',
        'best practices'
      );
      break;
    case 'DEFI':
      suggestions.push(
        'yield strategies',
        'liquidity analysis',
        'protocol comparison'
      );
      break;
    case 'REGULATORY':
      suggestions.push(
        'compliance requirements',
        'jurisdictional analysis',
        'risk assessment'
      );
      break;
    case 'SECURITY':
      suggestions.push(
        'audit findings',
        'security measures',
        'risk mitigation'
      );
      break;
    case 'NEWS_EVENTS':
      suggestions.push(
        'market impact',
        'related developments',
        'future implications'
      );
      break;
    default:
      suggestions.push(
        'market overview',
        'technical details',
        'latest updates'
      );
  }

  // Add suggestions based on user preferences
  if (context.userPreferences.technicalLevel === 'advanced') {
    suggestions.push(
      'technical deep dive',
      'architecture analysis',
      'security audit'
    );
  }

  // Add token-specific suggestions
  context.userPreferences.favoriteTokens.slice(0, 2).forEach(token => {
    suggestions.push(`${token} analysis`, `${token} performance`);
  });

  // Return top 5 unique suggestions
  return Array.from(new Set(suggestions)).slice(0, 5);
}

================================================================================
File: lib/conversation/context.ts
================================================================================

import { ChatMessage } from '../conversation-store';

export interface ConversationContext {
  recentMessages: ChatMessage[];
  topics: string[];
  userPreferences?: {
    favoriteTokens?: string[];
    preferredTimeframes?: string[];
  };
}

export function buildContext(messages: ChatMessage[]): ConversationContext {
  const topics = new Set<string>();
  const favoriteTokens = new Set<string>();
  const preferredTimeframes = new Set<string>();

  messages.forEach(msg => {
    if (msg.metadata?.intent) {
      topics.add(msg.metadata.intent);
    }
    if (msg.metadata?.tokens) {
      msg.metadata.tokens.forEach(token => favoriteTokens.add(token));
    }
  });

  return {
    recentMessages: messages.slice(-5),
    topics: Array.from(topics),
    userPreferences: {
      favoriteTokens: Array.from(favoriteTokens),
      preferredTimeframes: Array.from(preferredTimeframes)
    }
  };
}

================================================================================
File: lib/conversation/manager.ts
================================================================================

import { ConversationContext, ConversationMemory, ConversationTopic } from '@/lib/types/conversation';
import { RobustAnalysis } from '@/lib/agents/types';

export class ConversationManager {
  private contexts: Map<string, ConversationContext>;
  private readonly MAX_TOPICS = 5;
  private readonly MAX_MESSAGES = 10;
  private readonly CONTEXT_EXPIRY = 30 * 60 * 1000; // 30 minutes

  constructor() {
    this.contexts = new Map();
    // Set up periodic cleanup
    setInterval(() => this.cleanupExpiredContexts(), 5 * 60 * 1000); // Every 5 minutes
  }

  private initializeContext(sessionId: string): ConversationContext {
    return {
      sessionId,
      memory: {
        topics: [],
        userPreferences: {},
        lastInteraction: Date.now()
      },
      recentMessages: [],
    };
  }

  getContext(sessionId: string): ConversationContext {
    let context = this.contexts.get(sessionId);
    
    if (!context) {
      context = this.initializeContext(sessionId);
      this.contexts.set(sessionId, context);
    }

    // Update last interaction time
    context.memory.lastInteraction = Date.now();
    return context;
  }

  updateContext(sessionId: string, analysis: RobustAnalysis, response: string): void {
    const context = this.getContext(sessionId);
    
    // Update messages
    context.recentMessages.push({
      role: 'user',
      content: analysis.originalContext.rawQuery,
      timestamp: Date.now()
    });
    context.recentMessages.push({
      role: 'assistant',
      content: response,
      timestamp: Date.now()
    });

    // Trim messages to keep only recent ones
    if (context.recentMessages.length > this.MAX_MESSAGES) {
      context.recentMessages = context.recentMessages.slice(-this.MAX_MESSAGES);
    }

    // Update topics based on analysis
    this.updateTopics(context, analysis);

    // Update user preferences if detected
    this.updateUserPreferences(context, analysis);

    // Set current topic
    context.currentTopic = analysis.classification.primaryIntent;

    this.contexts.set(sessionId, context);
  }

  private updateTopics(context: ConversationContext, analysis: RobustAnalysis): void {
    const newTopic: ConversationTopic = {
      name: analysis.classification.primaryIntent,
      confidence: analysis.classification.confidence,
      lastDiscussed: Date.now(),
      relatedTokens: analysis.queryAnalysis.detectedTokens
    };

    const existingTopicIndex = context.memory.topics.findIndex(
      t => t.name === newTopic.name
    );

    if (existingTopicIndex !== -1) {
      // Update existing topic
      context.memory.topics[existingTopicIndex] = {
        ...context.memory.topics[existingTopicIndex],
        lastDiscussed: Date.now(),
        confidence: Math.max(
          context.memory.topics[existingTopicIndex].confidence,
          newTopic.confidence
        ),
        relatedTokens: Array.from(new Set([
          ...context.memory.topics[existingTopicIndex].relatedTokens,
          ...newTopic.relatedTokens
        ]))
      };
    } else {
      // Add new topic
      context.memory.topics.push(newTopic);
    }

    // Keep only recent topics, sorted by last discussed
    context.memory.topics = context.memory.topics
      .sort((a, b) => b.lastDiscussed - a.lastDiscussed)
      .slice(0, this.MAX_TOPICS);
  }

  private updateUserPreferences(context: ConversationContext, analysis: RobustAnalysis): void {
    const prefs = context.memory.userPreferences;

    // Update favorite tokens
    if (analysis.queryAnalysis.detectedTokens.length > 0) {
      const tokenFrequency = new Map<string, number>();
      
      // Count token frequency
      analysis.queryAnalysis.detectedTokens.forEach(token => {
        tokenFrequency.set(token, (tokenFrequency.get(token) || 0) + 1);
      });

      // Update favorites based on frequency
      prefs.favoriteTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([token]) => token)
        .slice(0, 5);
    }

    // Update risk tolerance
    if (analysis.queryAnalysis.detectedIntents.includes('risk_assessment')) {
      const riskTerms = analysis.queryAnalysis.detectedIntents.filter(
        intent => ['high_risk', 'moderate_risk', 'low_risk'].includes(intent)
      );
      
      if (riskTerms.length > 0) {
        prefs.riskTolerance = riskTerms[0].includes('high') ? 'high' :
                             riskTerms[0].includes('low') ? 'low' : 'medium';
      }
    }

    // Update investment goals
    if (analysis.queryAnalysis.detectedIntents.includes('investment_strategy')) {
      const goals = analysis.queryAnalysis.conceptualIndicators
        .filter(indicator => 
          ['long_term', 'short_term', 'growth', 'income', 'trading'].includes(indicator)
        );
      
      if (goals.length > 0) {
        prefs.investmentGoals = Array.from(new Set([
          ...(prefs.investmentGoals || []),
          ...goals
        ]));
      }
    }
  }

  suggestNextTopics(sessionId: string): string[] {
    const context = this.getContext(sessionId);
    const suggestions: string[] = [];

    // Add topic-based suggestions
    switch (context.currentTopic) {
      case 'MARKET_DATA':
        suggestions.push(
          'How does this compare to other similar tokens?',
          'What are the recent market trends?',
          'Would you like to see the price history?'
        );
        break;
      case 'COMPARISON':
        suggestions.push(
          'Which token has better performance?',
          'What are the key differences in technology?',
          'How do their market caps compare?'
        );
        break;
      case 'CONCEPTUAL':
        suggestions.push(
          'Would you like to see some real-world examples?',
          'How does this relate to other blockchain concepts?',
          'What are the practical applications?'
        );
        break;
      case 'HYBRID':
        suggestions.push(
          'Would you like more detailed market data?',
          'Should we focus on technical analysis?',
          'Would you like to understand the underlying technology?'
        );
        break;
    }

    // Add personalized suggestions
    if (context.memory.userPreferences.favoriteTokens?.length) {
      const favoriteToken = context.memory.userPreferences.favoriteTokens[0];
      suggestions.push(
        `What's the latest price of ${favoriteToken}?`,
        `How has ${favoriteToken} performed recently?`
      );
    }

    // Add risk-based suggestions
    if (context.memory.userPreferences.riskTolerance) {
      switch (context.memory.userPreferences.riskTolerance) {
        case 'high':
          suggestions.push(
            'Show me high-potential emerging tokens',
            'What are the most volatile tokens today?'
          );
          break;
        case 'medium':
          suggestions.push(
            'Show me tokens with balanced risk-reward',
            'What are the trending mid-cap tokens?'
          );
          break;
        case 'low':
          suggestions.push(
            'What are the most stable tokens?',
            'Show me tokens with consistent performance'
          );
          break;
      }
    }

    // Randomize and limit suggestions
    return this.shuffleArray(suggestions).slice(0, 3);
  }

  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  cleanupExpiredContexts(): void {
    const now = Date.now();
    for (const [sessionId, context] of this.contexts.entries()) {
      if (now - context.memory.lastInteraction > this.CONTEXT_EXPIRY) {
        this.contexts.delete(sessionId);
      }
    }
  }
}

================================================================================
File: lib/env-config.ts
================================================================================

interface EnvConfig {
  COINGECKO_API_KEY: string;
  COINMARKETCAP_API_KEY: string;
  OPENAI_API_KEY: string;
  NODE_ENV: string;
  API_RATE_LIMITS: {
    COINGECKO: number;
    COINMARKETCAP: number;
  };
  API_BASE_URLS: {
    COINGECKO: string;
    COINMARKETCAP: string;
  };
}

function validateEnv(): EnvConfig {
  const requiredVars = [
    'COINGECKO_API_KEY',
    'COINMARKETCAP_API_KEY',
    'OPENAI_API_KEY'
  ];

  const missingVars = requiredVars.filter(
    varName => !process.env[varName]
  );

  // In development mode, use placeholder values for missing variables
  const isDev = process.env.NODE_ENV === 'development';
  
  if (missingVars.length > 0 && !isDev) {
    throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
  }

  return {
    COINGECKO_API_KEY: process.env.COINGECKO_API_KEY || (isDev ? 'development_key' : ''),
    COINMARKETCAP_API_KEY: process.env.COINMARKETCAP_API_KEY || (isDev ? 'development_key' : ''),
    OPENAI_API_KEY: process.env.OPENAI_API_KEY || (isDev ? 'development_key' : ''),
    NODE_ENV: process.env.NODE_ENV || 'development',
    API_RATE_LIMITS: {
      COINGECKO: parseInt(process.env.COINGECKO_RATE_LIMIT || '50'),
      COINMARKETCAP: parseInt(process.env.COINMARKETCAP_RATE_LIMIT || '30')
    },
    API_BASE_URLS: {
      COINGECKO: process.env.COINGECKO_API_BASE || 'https://api.coingecko.com/api/v3',
      COINMARKETCAP: process.env.COINMARKETCAP_API_BASE || 'https://pro-api.coinmarketcap.com/v1'
    }
  };
}

export const envConfig = validateEnv();

// Rate limit tracking
let lastCoinGeckoCall = 0;
let lastCoinMarketCapCall = 0;

export function canCallCoinGecko(): boolean {
  const now = Date.now();
  const timeSinceLastCall = now - lastCoinGeckoCall;
  const minInterval = (60 * 1000) / envConfig.API_RATE_LIMITS.COINGECKO; // Convert rate per minute to ms interval
  return timeSinceLastCall >= minInterval;
}

export function canCallCoinMarketCap(): boolean {
  const now = Date.now();
  const timeSinceLastCall = now - lastCoinMarketCapCall;
  const minInterval = (60 * 1000) / envConfig.API_RATE_LIMITS.COINMARKETCAP;
  return timeSinceLastCall >= minInterval;
}

export function recordCoinGeckoCall(): void {
  lastCoinGeckoCall = Date.now();
}

export function recordCoinMarketCapCall(): void {
  lastCoinMarketCapCall = Date.now();
}

// Environment helpers
export function isDevelopment(): boolean {
  return envConfig.NODE_ENV === 'development';
}

export function isProduction(): boolean {
  return envConfig.NODE_ENV === 'production';
}

// API key access
export function getApiKey(service: 'COINGECKO' | 'COINMARKETCAP' | 'OPENAI'): string {
  switch (service) {
    case 'COINGECKO':
      return envConfig.COINGECKO_API_KEY;
    case 'COINMARKETCAP':
      return envConfig.COINMARKETCAP_API_KEY;
    case 'OPENAI':
      return envConfig.OPENAI_API_KEY;
    default:
      throw new Error(`Unknown service: ${service}`);
  }
}

// API base URL access
export function getApiBaseUrl(service: 'COINGECKO' | 'COINMARKETCAP'): string {
  return envConfig.API_BASE_URLS[service];
}

// Rate limit info
export function getRateLimit(service: 'COINGECKO' | 'COINMARKETCAP'): number {
  return envConfig.API_RATE_LIMITS[service];
}

// Time until next allowed call
export function getTimeUntilNextCall(service: 'COINGECKO' | 'COINMARKETCAP'): number {
  const now = Date.now();
  const lastCall = service === 'COINGECKO' ? lastCoinGeckoCall : lastCoinMarketCapCall;
  const minInterval = (60 * 1000) / getRateLimit(service);
  const timeUntilNext = Math.max(0, minInterval - (now - lastCall));
  return timeUntilNext;
}

================================================================================
File: lib/llm.ts
================================================================================

import { Configuration, OpenAIApi } from 'openai';
import { TokenInfo, TokenPrice, TokenTrend } from './token-data';

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
let openai: OpenAIApi | null = null;

function getOpenAIClient() {
  if (!openai) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    const configuration = new Configuration({ apiKey });
    openai = new OpenAIApi(configuration);
  }
  return openai;
}

// System prompt template for different query types
const SYSTEM_PROMPTS = {
  trending: `You are an expert cryptocurrency analyst specializing in market trends and token analysis. Your role is to:
1. Analyze the provided trending token data and their price movements
2. Highlight significant price changes and market movements
3. Provide brief, factual insights about each trending token
4. Format the response in a clear, easy-to-read manner
5. Only use the data provided - do not make assumptions or predictions

When discussing tokens:
- Always include the token symbol in uppercase
- Show percentage changes with 2 decimal places
- Format large numbers for readability (e.g., "$1.2M" instead of "1200000")
- Highlight significant movements (>5% changes)
- If price data is missing, acknowledge it explicitly`,

  tokenInfo: `You are a cryptocurrency token specialist providing detailed token analysis. Your role is to:
1. Present the token's key metrics clearly and accurately
2. Explain price movements and market position
3. Compare current prices to ATH when relevant
4. Format numbers for easy reading
5. Only use the provided data - no speculation or predictions

When presenting token information:
- Lead with the token's full name and symbol
- Format market cap and volume figures clearly
- Show price changes as percentages with 2 decimal places
- Include supply information when available
- If any key data is missing, acknowledge it explicitly`,

  transactions: `You are a blockchain transaction analyst specializing in DeFi activities. Your role is to:
1. Summarize recent transaction patterns
2. Identify significant swaps or liquidity events
3. Present transaction volumes clearly
4. Group similar transactions when relevant
5. Only discuss transactions in the provided data

When analyzing transactions:
- Format amounts with appropriate decimals
- Group similar transaction types together
- Highlight large value movements
- Show timestamps in a human-readable format
- If transaction details are incomplete, state it clearly`
} as const;

interface GenerateResponseOptions {
  queryType: keyof typeof SYSTEM_PROMPTS;
  maxTokens?: number;
  temperature?: number;
}

export async function generateResponse(
  query: string,
  data: any,
  context?: string,
  options: GenerateResponseOptions = { queryType: 'trending' }
): Promise<string> {
  try {
    // Validate input data
    if (!query.trim()) {
      throw new Error('Query cannot be empty');
    }

    if (!data) {
      throw new Error('Data is required');
    }

    const client = getOpenAIClient();
    
    // Format data based on query type
    const formattedData = formatDataForPrompt(data, options.queryType);
    
    const systemPrompt = SYSTEM_PROMPTS[options.queryType];
    const userContext = context ? `Previous context:\n${context}\n\n` : '';
    
    const messages = [
      { role: "system" as const, content: systemPrompt },
      { role: "user" as const, content: `${userContext}Available Data:\n${formattedData}\n\nUser Question: ${query}` }
    ];

    const completion = await client.createChatCompletion({
      model: OPENAI_MODEL,
      messages,
      temperature: options.temperature ?? 0.7,
      max_tokens: options.maxTokens ?? 500,
      presence_penalty: 0.1,
      frequency_penalty: 0.1,
    });

    const response = completion.data.choices[0]?.message?.content;
    if (!response) {
      throw new Error('No response received from OpenAI');
    }

    return response;

  } catch (error) {
    console.error('LLM error:', error);
    
    // Improve error handling with specific error types
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        throw new Error('OpenAI API key is invalid or not configured');
      }
      if (error.message.includes('429')) {
        throw new Error('Rate limit exceeded. Please try again in a moment');
      }
      if (error.message.includes('401')) {
        throw new Error('Authentication failed. Please check API key configuration');
      }
      if (error.message.includes('insufficient_quota')) {
        throw new Error('OpenAI API quota exceeded. Please try again later');
      }
      throw error;
    }
    
    throw new Error('An unexpected error occurred while processing your request');
  }
}

function formatDataForPrompt(data: any, queryType: keyof typeof SYSTEM_PROMPTS): string {
  if (!data) return 'No data available.';
  
  switch (queryType) {
    case 'trending':
      return formatTrendingData(data);
    case 'tokenInfo':
      return formatTokenInfo(data);
    case 'transactions':
      return formatTransactionData(data);
    default:
      return JSON.stringify(data, null, 2);
  }
}

function formatTrendingData(data: { 
  trending: TokenTrend[], 
  prices: Record<string, TokenPrice> 
}): string {
  if (!data.trending?.length) return 'No trending data available.';
  
  return data.trending.map(trend => {
    const price = data.prices[trend.item.id];
    return `Token: ${trend.item.name} (${trend.item.symbol.toUpperCase()})
- Market Cap Rank: ${trend.item.market_cap_rank ?? 'N/A'}
- Current Price: ${price?.current_price ? `$${price.current_price.toFixed(6)}` : 'N/A'}
- 24h Change: ${price?.price_change_percentage_24h ? `${price.price_change_percentage_24h.toFixed(2)}%` : 'N/A'}
- Market Cap: ${price?.market_cap ? `$${formatNumber(price.market_cap)}` : 'N/A'}`;
  }).join('\n\n');
}

function formatTokenInfo(data: { tokenDetails: TokenInfo[], prices: Record<string, TokenPrice> }): string {
  if (!data.tokenDetails?.length) return 'No token information available.';
  
  return data.tokenDetails.map(token => {
    const price = data.prices[token.id];
    return `Token: ${token.name} (${token.symbol.toUpperCase()})
Current Price: $${token.current_price?.toFixed(6) ?? 'N/A'}
Market Cap: $${formatNumber(token.market_cap)} (Rank #${token.market_cap_rank ?? 'N/A'})
24h Trading Volume: $${formatNumber(token.total_volume)}
24h Price Change: ${token.price_change_percentage_24h?.toFixed(2) ?? 'N/A'}%
24h Range: $${token.low_24h?.toFixed(6) ?? 'N/A'} - $${token.high_24h?.toFixed(6) ?? 'N/A'}
All-Time High: $${token.ath?.toFixed(6) ?? 'N/A'} (${token.ath_date ? new Date(token.ath_date).toLocaleDateString() : 'N/A'})
Supply Information:
- Circulating: ${formatNumber(token.circulating_supply)}
- Total: ${token.total_supply ? formatNumber(token.total_supply) : 'N/A'}
- Max: ${token.max_supply ? formatNumber(token.max_supply) : 'N/A'}`;
  }).join('\n\n');
}

function formatTransactionData(data: any): string {
  if (!data?.transactions?.length) return 'No transaction data available.';
  
  return data.transactions.map((tx: any) => {
    let actionType = 'Unknown';
    let details = '';
    
    if (tx.swaps?.length) {
      actionType = 'Swap';
      const swap = tx.swaps[0];
      details = `${swap.pair.token0.symbol}/${swap.pair.token1.symbol} ($${parseFloat(swap.amountUSD).toFixed(2)})`;
    } else if (tx.mints?.length) {
      actionType = 'Liquidity Addition';
      const mint = tx.mints[0];
      details = `${mint.pair.token0.symbol}/${mint.pair.token1.symbol}`;
    } else if (tx.burns?.length) {
      actionType = 'Liquidity Removal';
      const burn = tx.burns[0];
      details = `${burn.pair.token0.symbol}/${burn.pair.token1.symbol}`;
    }

    return `Transaction Type: ${actionType}
Details: ${details}
Timestamp: ${new Date(tx.timestamp * 1000).toLocaleString()}`;
  }).join('\n\n');
}

function formatNumber(num: number | null | undefined): string {
  if (num === null || num === undefined) return 'N/A';
  
  if (num >= 1e9) {
    return `${(num / 1e9).toFixed(2)}B`;
  }
  if (num >= 1e6) {
    return `${(num / 1e6).toFixed(2)}M`;
  }
  if (num >= 1e3) {
    return `${(num / 1e3).toFixed(2)}K`;
  }
  return num.toString();
}

================================================================================
File: lib/middleware.ts
================================================================================

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { verifyToken, type UserRole, type AuthenticatedUser } from './auth';

export function withAuth(handler: Function, requiredRole?: UserRole) {
  return async function (req: NextRequest) {
    const token = req.headers.get('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const user = verifyToken(token);
    if (!user) {
      return NextResponse.json(
        { error: 'Invalid or expired token' },
        { status: 401 }
      );
    }

    if (requiredRole && user.role !== requiredRole) {
      return NextResponse.json(
        { error: 'Insufficient permissions' },
        { status: 403 }
      );
    }

    // Pass the user to the handler function instead of modifying the request
    return handler(req, user);
  };
}

================================================================================
File: lib/orchestrator.ts
================================================================================

import { 
  analyzeUserQuery,
  buildAggregatorCalls,
  executeAggregatorCalls,
  generateSummary,
  RobustAnalysis,
  OrchestrationResult,
  AggregatorResult
} from './agents';
import { ConversationStore, ChatMessage } from './conversation-store';
import { buildEnhancedContext, formatContextForPrompt, analyzeContextContinuity } from './conversation/context-builder';
import { blockchainOrchestrator, BlockchainActionParams, BlockchainActionType } from './agents/blockchain-orchestrator';

export class AgentOrchestrator {
  constructor() {
    // Clean up expired sessions periodically
    setInterval(() => {
      ConversationStore.cleanExpiredSessions();
    }, 5 * 60 * 1000); // Every 5 minutes
  }

  private checkApiKeys(): void {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('API configuration error: OpenAI API key is not configured');
    }

    if (!process.env.COINMARKETCAP_API_KEY) {
      console.warn('Warning: CoinMarketCap API key not configured - fallback functionality may be limited');
    }

    if (!process.env.COINGECKO_API_KEY) {
      console.warn('Warning: CoinGecko API key not configured - API rate limits may be restricted');
    }
  }

  private async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries = 3,
    initialDelay = 1000
  ): Promise<T> {
    let lastError: Error | null = null;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Operation timed out')), 30000); // 30s timeout
        });
        
        const operationPromise = operation();
        
        return await Promise.race([operationPromise, timeoutPromise]) as T;
      } catch (error) {
        lastError = error as Error;
        
        const isRetryable = error instanceof Error && (
          error.message.includes('socket hang up') ||
          error.message.includes('rate limit') ||
          error.message.includes('timeout') ||
          error.message.includes('ECONNRESET') ||
          error.message.includes('ETIMEDOUT')
        );
        
        if (isRetryable && i < maxRetries - 1) {
          const delay = initialDelay * Math.pow(2, i);
          console.log(`Retry ${i + 1}/${maxRetries} after ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        throw error;
      }
    }
    
    throw lastError || new Error('Operation failed after retries');
  }

  private async handleProcessingError(error: unknown): Promise<never> {
    console.error('Orchestration error:', error);
    
    if (error instanceof Error) {
      // Authentication errors
      if (error.message.includes('401') || error.message.includes('unauthorized') || error.message.includes('invalid api key')) {
        throw new Error('Service configuration error: API key is invalid or not configured properly. Please check your environment settings.');
      }

      // Rate limiting
      if (error.message.includes('429') || error.message.includes('rate limit')) {
        throw new Error('Service is currently busy. Please try again in a moment.');
      }

      // API errors
      if (error.message.includes('socket hang up') || error.message.includes('ECONNRESET')) {
        throw new Error('Connection interrupted. Please try again.');
      }

      if (error.message.includes('timeout')) {
        throw new Error('Request timed out. Please try again.');
      }

      // Service errors
      if (error.message.includes('503') || error.message.includes('502')) {
        throw new Error('Service is temporarily unavailable. Please try again later.');
      }

      // Return the original error message if it's from our own validation
      if (error.message.includes('API configuration error') || 
          error.message.includes('Session ID is required')) {
        throw error;
      }
    }
    
    // Generic error for unhandled cases
    throw new Error('An unexpected error occurred. Please try again later.');
  }

  async processQuery(query: string, sessionId?: string): Promise<OrchestrationResult> {
    console.log('Starting query processing:', { query, sessionId });
    
    try {
      // Check API keys first
      this.checkApiKeys();

      if (!sessionId) {
        throw new Error('Session ID is required for conversation memory');
      }

      // Step 1: Intent Analysis with retry
      console.log('Running intent analysis...');
      const analysis = await this.withRetry(
        () => analyzeUserQuery({ query }),
        3,
        1000
      );

      // Step 2: Build Enhanced Context
      const enhancedContext = buildEnhancedContext(sessionId, analysis);
      const formattedContext = formatContextForPrompt(enhancedContext);
      
      // Analyze conversation continuity
      const continuityAnalysis = analyzeContextContinuity(enhancedContext);
      console.log('Context analysis:', {
        isCoherent: continuityAnalysis.isCoherent,
        confidence: continuityAnalysis.confidence
      });

      // Store user message with metadata
      ConversationStore.addMessage(sessionId, {
        role: 'user',
        content: query,
        timestamp: Date.now(),
        metadata: {
          intent: analysis.classification.primaryIntent,
          confidence: analysis.classification.confidence,
          tokens: analysis.queryAnalysis.detectedTokens,
          contextConfidence: continuityAnalysis.confidence
        }
      });

      let aggregatorData: AggregatorResult | null = null;
      let response: string;

      // Step 3: Process based on intent and context with retry
      try {
        // Check for blockchain intents
        if (analysis.classification.primaryIntent === 'DEPLOY_CONTRACT' || 
            analysis.classification.primaryIntent === 'TRANSFER_TOKENS' ||
            analysis.classification.primaryIntent === 'CONNECT_WALLET') {
          
          // Extract blockchain action parameters
          const blockchainParams = this.extractBlockchainParams(analysis, query);
          
          // Execute blockchain action
          const blockchainResult = await blockchainOrchestrator.handleAction(blockchainParams);
          
          // Include the blockchain result in the aggregatorData
          aggregatorData = {
            primary: {
              blockchain: blockchainResult
            }
          };
        } 
        // Continue with standard processing for non-blockchain intents
        else if (analysis.classification.needsApiCall || analysis.classification.requiresWebSearch) {
          console.log('Building aggregator spec...');
          const aggregatorSpec = await buildAggregatorCalls(analysis);
          
          console.log('Executing aggregator calls with retry...');
          aggregatorData = await this.withRetry(
            () => executeAggregatorCalls(aggregatorSpec),
            3,
            2000
          );
        }

        // Step 4: Generate Response with Enhanced Context and retry
        console.log('Generating response with enhanced context...');
        response = await this.withRetry(
          () => generateSummary({
            userQuery: query,
            analysis,
            aggregatorResult: aggregatorData,
            sessionId,
            enhancedContext: formattedContext
          }),
          3,
          1000
        );

        // Store assistant response with metadata
        ConversationStore.addMessage(sessionId, {
          role: 'assistant',
          content: response,
          timestamp: Date.now(),
          metadata: {
            intent: analysis.classification.primaryIntent,
            tokens: analysis.queryAnalysis.detectedTokens,
            contextConfidence: continuityAnalysis.confidence
          }
        });

        // Add follow-up suggestion if conversation flow needs bridging
        if (continuityAnalysis.suggestedFollowUp) {
          response += `\n\n${continuityAnalysis.suggestedFollowUp}`;
        }

        // Generate contextual suggestions
        const suggestions = this.generateSuggestions(
          analysis,
          enhancedContext
        );

        return {
          analysis,
          aggregatorData,
          response,
          suggestions,
          contextAnalysis: {
            isCoherent: continuityAnalysis.isCoherent,
            confidence: continuityAnalysis.confidence
          }
        };

      } catch (error) {
        console.error('Branch processing error:', error);
        
        // Attempt recovery with fallback processing
        response = await this.withRetry(
          () => generateSummary({
            userQuery: query,
            analysis,
            aggregatorResult: null,
            sessionId,
            enhancedContext: formattedContext
          }),
          3,
          1000
        );

        return {
          analysis,
          aggregatorData: null,
          response,
          suggestions: []
        };
      }

    } catch (error) {
      return this.handleProcessingError(error);
    }
  }

  private generateSuggestions(
    analysis: RobustAnalysis,
    enhancedContext: any
  ): string[] {
    const suggestions: string[] = [];

    // Add topic-based suggestions
    switch (analysis.classification.primaryIntent) {
      case 'MARKET_DATA':
        if (enhancedContext.userPreferences.technicalLevel === 'advanced') {
          suggestions.push(
            'Would you like to see detailed market metrics?',
            'Should we analyze the trading volume patterns?'
          );
        } else {
          suggestions.push(
            'How does this compare to other tokens?',
            'Would you like to see the price history?'
          );
        }
        break;

      case 'TECHNICAL':
        suggestions.push(
          'Would you like to see code examples?',
          'Should we explore security implications?'
        );
        break;

      case 'DEFI':
        suggestions.push(
          'Would you like to analyze the protocol risks?',
          'Should we compare yields across platforms?'
        );
        break;

      case 'REGULATORY':
        suggestions.push(
          'Would you like to see compliance requirements?',
          'Should we check jurisdictional differences?'
        );
        break;

      case 'SECURITY':
        suggestions.push(
          'Would you like to see recent audit findings?',
          'Should we review security best practices?'
        );
        break;

      case 'NEWS_EVENTS':
        suggestions.push(
          'Would you like to see related developments?',
          'Should we analyze market impact?'
        );
        break;
    }

    // Add personalized suggestions based on user preferences
    if (enhancedContext.userPreferences.favoriteTokens.length) {
      const favoriteToken = enhancedContext.userPreferences.favoriteTokens[0];
      suggestions.push(
        `What's the latest price of ${favoriteToken}?`,
        `How has ${favoriteToken} performed recently?`
      );
    }

    // Randomize and limit suggestions
    return this.shuffleArray(suggestions).slice(0, 3);
  }

  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  // Add helper method to extract parameters
  private extractBlockchainParams(analysis: RobustAnalysis, query: string): BlockchainActionParams {
    let actionParams: BlockchainActionParams = {
      actionType: analysis.classification.primaryIntent as BlockchainActionType
    };
    
    // Extract parameters based on intent
    switch(analysis.classification.primaryIntent) {
      case 'DEPLOY_CONTRACT':
        // Extract template name, params
        actionParams.deploymentParams = {
          templateId: analysis.queryAnalysis.detectedEntities?.[0] || 'ERC20',
          templateParams: {
            name: analysis.queryAnalysis.entityParams?.name || 'MyToken',
            symbol: analysis.queryAnalysis.entityParams?.symbol || 'MTK'
            // Other parameters
          }
        };
        break;
        
      case 'TRANSFER_TOKENS':
        // Extract recipient, amount, token
        actionParams.transferParams = {
          to: analysis.queryAnalysis.recipient as `0x${string}` || '0x0000000000000000000000000000000000000000',
          amount: analysis.queryAnalysis.amount || '0.1',
          tokenAddress: analysis.queryAnalysis.tokenAddress as `0x${string}` || null,
          chainId: 1 // Default to Ethereum mainnet
        };
        break;
        
      case 'CONNECT_WALLET':
        actionParams.walletParams = {
          type: 'metamask'
        };
        break;
    }
    
    return actionParams;
  }
}

================================================================================
File: lib/session-utils.ts
================================================================================

import { v4 as uuidv4 } from 'uuid';

interface SessionStorage {
  getItem(key: string): string | null;
  setItem(key: string, value: string): void;
  removeItem(key: string): void;
}

class MemoryStorage implements SessionStorage {
  private storage = new Map<string, string>();

  getItem(key: string): string | null {
    return this.storage.get(key) || null;
  }

  setItem(key: string, value: string): void {
    this.storage.set(key, value);
  }

  removeItem(key: string): void {
    this.storage.delete(key);
  }
}

export const SESSION_STORAGE_KEY = 'chatSessionId';

export const getStorage = (): SessionStorage => {
  if (typeof window === 'undefined') {
    return new MemoryStorage();
  }

  try {
    // Test localStorage availability
    const test = '__test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return localStorage;
  } catch (e) {
    console.warn('localStorage not available, falling back to memory storage');
    return new MemoryStorage();
  }
};

export const initializeSession = (): string => {
  const storage = getStorage();
  const existingSession = storage.getItem(SESSION_STORAGE_KEY);
  
  if (existingSession) {
    console.log('Found existing session:', existingSession);
    return existingSession;
  }
  
  const newSession = uuidv4();
  console.log('Creating new session:', newSession);
  
  try {
    storage.setItem(SESSION_STORAGE_KEY, newSession);
  } catch (e) {
    console.error('Failed to store session:', e);
  }
  
  return newSession;
};

export const clearSession = (): void => {
  const storage = getStorage();
  try {
    storage.removeItem(SESSION_STORAGE_KEY);
  } catch (e) {
    console.error('Failed to clear session:', e);
  }
};

export const validateSession = (sessionId: string | null): boolean => {
  if (!sessionId) return false;
  
  // Validate UUID format
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(sessionId);
};

================================================================================
File: lib/token-data.ts
================================================================================

import { 
  envConfig, 
  canCallCoinGecko, 
  canCallCoinMarketCap,
  recordCoinGeckoCall,
  recordCoinMarketCapCall,
  getApiBaseUrl,
  getApiKey
} from './env-config';
import { queryCounter, queryDuration, queryErrors } from './monitoring';

export interface TokenPrice {
  current_price: number;
  market_cap: number;
  price_change_percentage_24h: number;
  source: 'coingecko' | 'coinmarketcap';
}

export interface TokenInfo {
  id: string;
  symbol: string;
  name: string;
  current_price: number;
  market_cap: number;
  market_cap_rank: number;
  total_volume: number;
  high_24h: number | null;
  low_24h: number | null;
  price_change_24h: number;
  price_change_percentage_24h: number;
  circulating_supply: number;
  total_supply: number;
  max_supply: number | null;
  ath: number | null;
  ath_date: string | null;
  source: 'coingecko' | 'coinmarketcap';
}

export interface TokenTrend {
  item: {
    id: string;
    coin_id: number;
    name: string;
    symbol: string;
    market_cap_rank: number;
    thumb: string;
    small: string;
    large: string;
    slug: string;
    price_btc: number;
    score: number;
  };
}

async function fetchCoinGecko(endpoint: string): Promise<Response> {
  const response = await fetch(
    `${getApiBaseUrl('COINGECKO')}${endpoint}`,
    {
      headers: {
        'x-cg-pro-api-key': getApiKey('COINGECKO'),
        'Accept': 'application/json'
      }
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('CoinGecko rate limit exceeded');
    }
    throw new Error(`CoinGecko API error: ${response.status}`);
  }

  return response;
}

async function fetchCoinMarketCap(endpoint: string): Promise<any> {
  const response = await fetch(
    `${getApiBaseUrl('COINMARKETCAP')}${endpoint}`,
    {
      headers: {
        'X-CMC_PRO_API_KEY': getApiKey('COINMARKETCAP'),
        'Accept': 'application/json'
      }
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('CoinMarketCap rate limit exceeded');
    }
    throw new Error(`CoinMarketCap API error: ${response.status}`);
  }

  const data = await response.json();
  if (data.status?.error_code) {
    throw new Error(`CoinMarketCap error: ${data.status.error_message}`);
  }

  return data.data;
}

export async function getTrendingTokens(): Promise<TokenTrend[]> {
  try {
    if (canCallCoinGecko()) {
      const response = await fetchCoinGecko('/search/trending');
      const data = await response.json();
      recordCoinGeckoCall();
      
      if (data?.coins) {
        return data.coins;
      }
    }
    
    // Fallback to CoinMarketCap trending
    if (canCallCoinMarketCap()) {
      const data = await fetchCoinMarketCap('/cryptocurrency/trending/latest');
      recordCoinMarketCapCall();
      
      if (data) {
        // Transform to match CoinGecko format
        return data.map((coin: any) => ({
          item: {
            id: coin.slug,
            coin_id: coin.id,
            name: coin.name,
            symbol: coin.symbol,
            market_cap_rank: coin.cmc_rank,
            thumb: coin.logo || '',
            small: coin.logo || '',
            large: coin.logo || '',
            slug: coin.slug,
            price_btc: coin.quote?.BTC?.price || 0,
            score: 0
          }
        }));
      }
    }
    
    return [];
  } catch (error) {
    console.error('Error fetching trending tokens:', error);
    return [];
  }
}

async function searchToken(query: string): Promise<{id: string, symbol: string, name: string} | null> {
  if (!query?.trim()) {
    throw new Error('Search query is required');
  }

  try {
    // Try CoinGecko first
    if (canCallCoinGecko()) {
      try {
        const response = await fetchCoinGecko(
          `/search?query=${encodeURIComponent(query)}`
        );

        const data = await response.json();
        if (data.coins?.length > 0) {
          // Find best match based on exact symbol/name match or highest market cap rank
          const exactSymbolMatch = data.coins.find(
            (coin: { symbol: string }) => coin.symbol.toLowerCase() === query.toLowerCase()
          );
          
          if (exactSymbolMatch) {
            recordCoinGeckoCall();
            return {
              id: exactSymbolMatch.id,
              symbol: exactSymbolMatch.symbol.toLowerCase(),
              name: exactSymbolMatch.name
            };
          }
          
          const exactNameMatch = data.coins.find(
            (coin: { name: string }) => coin.name.toLowerCase() === query.toLowerCase()
          );
          
          if (exactNameMatch) {
            recordCoinGeckoCall();
            return {
              id: exactNameMatch.id,
              symbol: exactNameMatch.symbol.toLowerCase(),
              name: exactNameMatch.name
            };
          }
          
          // Otherwise return the highest ranked result
          const bestMatch = data.coins.reduce((best: any, current: any) => {
            return (current.market_cap_rank < best.market_cap_rank) ? current : best;
          }, data.coins[0]);
          
          recordCoinGeckoCall();
          return {
            id: bestMatch.id,
            symbol: bestMatch.symbol.toLowerCase(),
            name: bestMatch.name
          };
        }
      } catch (error) {
        console.warn('CoinGecko search failed:', error);
      }
    }
    
    // Fallback to CoinMarketCap
    if (canCallCoinMarketCap()) {
      try {
        const data = await fetchCoinMarketCap(
          `/cryptocurrency/map?symbol=${encodeURIComponent(query)}`
        );
        
        if (data?.length > 0) {
          // Sort by rank and take the best match
          const bestMatch = data.sort((a: any, b: any) => a.rank - b.rank)[0];
          
          recordCoinMarketCapCall();
          return {
            id: bestMatch.id.toString(),
            symbol: bestMatch.symbol.toLowerCase(),
            name: bestMatch.name
          };
        }
      } catch (error) {
        console.warn('CoinMarketCap search failed:', error);
      }
    }

    return null;
  } catch (error) {
    console.error('Token search error:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('Rate limit exceeded. Please try again in a moment.');
      }
      if (error.message.includes('API key')) {
        throw new Error('API configuration error. Please check your settings.');
      }
    }
    
    throw new Error('Failed to search for token');
  }
}

export async function getTokenDetails(query: string): Promise<TokenInfo | null> {
  if (!query?.trim()) {
    throw new Error('Token query is required');
  }

  try {
    // First search for the token
    const tokenMatch = await searchToken(query);
    if (!tokenMatch) {
      return null;
    }

    console.log(`Found token match:`, tokenMatch);

    // Try CoinGecko first
    if (canCallCoinGecko()) {
      try {
        const response = await fetchCoinGecko(
          `/coins/${tokenMatch.id}?localization=false&tickers=false&community_data=false&developer_data=false`
        );

        const data = await response.json();
        if (data?.market_data) {
          recordCoinGeckoCall();
          
          return {
            id: data.id,
            symbol: data.symbol,
            name: data.name,
            current_price: data.market_data.current_price.usd,
            market_cap: data.market_data.market_cap.usd,
            market_cap_rank: data.market_cap_rank,
            total_volume: data.market_data.total_volume.usd,
            high_24h: data.market_data.high_24h?.usd || null,
            low_24h: data.market_data.low_24h?.usd || null,
            price_change_24h: data.market_data.price_change_24h || 0,
            price_change_percentage_24h: data.market_data.price_change_percentage_24h || 0,
            circulating_supply: data.market_data.circulating_supply,
            total_supply: data.market_data.total_supply,
            max_supply: data.market_data.max_supply,
            ath: data.market_data.ath?.usd || null,
            ath_date: data.market_data.ath_date?.usd || null,
            source: 'coingecko'
          };
        }
      } catch (error) {
        console.warn('CoinGecko details fetch failed:', error);
      }
    }
    
    // Fallback to CoinMarketCap
    if (canCallCoinMarketCap()) {
      try {
        const data = await fetchCoinMarketCap(
          `/cryptocurrency/quotes/latest?symbol=${tokenMatch.symbol}`
        );
        
        if (data && data[tokenMatch.symbol]) {
          const coinData = data[tokenMatch.symbol][0];
          const quote = coinData.quote.USD;
          
          recordCoinMarketCapCall();
          
          return {
            id: coinData.slug,
            symbol: coinData.symbol.toLowerCase(),
            name: coinData.name,
            current_price: quote.price,
            market_cap: quote.market_cap,
            market_cap_rank: coinData.cmc_rank,
            total_volume: quote.volume_24h,
            high_24h: null, // Not available in this endpoint
            low_24h: null, // Not available in this endpoint
            price_change_24h: quote.volume_change_24h || 0,
            price_change_percentage_24h: quote.percent_change_24h || 0,
            circulating_supply: coinData.circulating_supply,
            total_supply: coinData.total_supply,
            max_supply: coinData.max_supply,
            ath: null,
            ath_date: null,
            source: 'coinmarketcap'
          };
        }
      } catch (error) {
        console.warn('CoinMarketCap details fetch failed:', error);
      }
    }

    throw new Error('Failed to fetch token details from all available sources');

  } catch (error) {
    console.error('Token details fetch error:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('Rate limit exceeded. Please try again in a moment.');
      }
      if (error.message.includes('API key')) {
        throw new Error('API configuration error. Please check your settings.');
      }
    }
    
    return null;
  }
}

export async function getTokenPrices(tokens: string[]): Promise<Record<string, TokenPrice>> {
  const results: Record<string, TokenPrice> = {};
  
  for (const token of tokens) {
    const tokenInfo = await getTokenDetails(token);
    if (tokenInfo) {
      results[token] = {
        current_price: tokenInfo.current_price,
        market_cap: tokenInfo.market_cap,
        price_change_percentage_24h: tokenInfo.price_change_percentage_24h,
        source: tokenInfo.source
      };
    }
  }
  
  return results;
}

================================================================================
File: lib/types/conversation.ts
================================================================================

import type { RobustAnalysis } from '@/lib/agents/types';

export interface ConversationTopic {
  name: string;
  confidence: number;
  lastDiscussed: number;
  relatedTokens: string[];
}

export interface ConversationMemory {
  topics: ConversationTopic[];
  userPreferences: {
    favoriteTokens?: string[];
    riskTolerance?: 'low' | 'medium' | 'high';
    investmentGoals?: string[];
  };
  lastInteraction: number;
}

export interface ConversationContext {
  sessionId: string;
  memory: ConversationMemory;
  recentMessages: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp: number;
  }>;
  currentTopic?: string;
}

================================================================================
File: lib/utils.ts
================================================================================

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


================================================================================
File: lib/wagmi.ts
================================================================================

"use client";

import { http, createConfig } from 'wagmi';
import { mainnet } from 'wagmi/chains';
import { injected } from 'wagmi/connectors';
import { createPublicClient, fallback, http as viemHttp } from 'viem';

export const publicClient = createPublicClient({
  chain: mainnet,
  transport: fallback([
    viemHttp(),
    viemHttp('https://eth-mainnet.g.alchemy.com/v2/demo'),
  ]),
});

export const config = createConfig({
  chains: [mainnet],
  connectors: [
    injected(),
  ],
  transports: {
    [mainnet.id]: http(),
  },
});

================================================================================
File: middleware.ts
================================================================================

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // Add CORS headers
  const response = NextResponse.next();
  
  response.headers.set('Access-Control-Allow-Origin', '*');
  response.headers.set(
    'Access-Control-Allow-Methods',
    'GET, POST, PUT, DELETE, OPTIONS'
  );
  response.headers.set(
    'Access-Control-Allow-Headers',
    'Content-Type, Authorization'
  );

  // Handle preflight requests
  if (request.method === 'OPTIONS') {
    return new NextResponse(null, { status: 200, headers: response.headers });
  }

  return response;
}

export const config = {
  matcher: '/api/:path*',
};

================================================================================
File: next.config.js
================================================================================

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  eslint: {
    ignoreDuringBuilds: true,
  },
  experimental: {
    serverComponentsExternalPackages: ['solc'],
  },
  images: { unoptimized: true },
  async headers() {
    return [
      {
        source: "/api/:path*",
        headers: [
          { key: "Access-Control-Allow-Origin", value: "*" },
          { key: "Access-Control-Allow-Methods", value: "GET,POST,OPTIONS" },
          { key: "Access-Control-Allow-Headers", value: "Content-Type, Authorization" },
          { key: "Content-Type", value: "application/json" }
        ],
      },
    ];
  },
  webpack: (config, { isServer }) => {
    // If client-side (browser), provide empty implementations for Node.js modules
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false,
        crypto: false,
        stream: false,
        path: false,
        os: false,
        http: false,
        https: false,
        zlib: false,
      };
    }
    return config;
  },
};

export default nextConfig;

================================================================================
File: package.json
================================================================================

{
  "name": "nextjs",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test:agents": "NODE_ENV=test node --loader ts-node/esm tests/agent-tests.ts",
    "blockchain:node": "hardhat node",
    "blockchain:deploy": "hardhat run scripts/blockchain/deploy.ts --network localhost",
    "blockchain:test": "hardhat test"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@openzeppelin/contracts": "^5.2.0",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-aspect-ratio": "^1.1.2",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-collapsible": "^1.1.3",
    "@radix-ui/react-context-menu": "^2.2.6",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-hover-card": "^1.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-menubar": "^1.1.6",
    "@radix-ui/react-navigation-menu": "^1.2.5",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.3",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-toggle": "^1.1.2",
    "@radix-ui/react-toggle-group": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@supabase/supabase-js": "^2.49.1",
    "@tanstack/react-query": "^5.67.2",
    "@types/node": "^20.17.23",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@types/uuid": "^9.0.8",
    "autoprefixer": "^10.4.20",
    "axios": "^1.8.2",
    "buffer": "^6.0.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.0",
    "cmdk": "^1.0.4",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.5.2",
    "ethers": "^6.13.5",
    "graphql": "^16.10.0", 
    "graphql-request": "^6.1.0",
    "input-otp": "^1.4.2",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.341.0",
    "next": "14.1.0",
    "next-themes": "^0.4.4",
    "openai": "^3.3.0",
    "pino-pretty": "^10.3.1",
    "postcss": "^8.5.3",
    "process": "^0.11.10",
    "react": "^18.2.0",
    "react-day-picker": "^9.5.1",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.54.2",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.1",
    "solc": "^0.8.28",
    "sonner": "^2.0.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.2",
    "url": "^0.11.4",
    "uuid": "^9.0.1",
    "vaul": "^1.1.2",
    "viem": "^2.23.7",
    "wagmi": "^2.14.12",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@graphql-codegen/cli": "^5.0.5",
    "@graphql-codegen/typescript": "^4.1.5",
    "@graphql-codegen/typescript-operations": "^4.5.1",
    "@nomicfoundation/hardhat-chai-matchers": "^2.0.0",
    "@nomicfoundation/hardhat-ethers": "^3.0.0",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.0",
    "@nomicfoundation/hardhat-toolbox": "^4.0.0",
    "@nomicfoundation/hardhat-verify": "^2.0.0",
    "@typechain/ethers-v6": "^0.5.0",
    "@typechain/hardhat": "^9.0.0",
    "@types/chai": "^4.3.5",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/mocha": "^10.0.1",
    "browserify-zlib": "^0.2.0",
    "chai": "^4.3.7",
    "crypto-browserify": "^3.12.1",
    "hardhat": "^2.19.1",
    "hardhat-gas-reporter": "^1.0.8",
    "https-browserify": "^1.0.0",
    "os-browserify": "^0.3.0",
    "path-browserify": "^1.0.1",
    "solidity-coverage": "^0.8.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "typechain": "^8.3.0"
  }
}

================================================================================
File: supabase/migrations/20250125030838_broad_tree.sql
================================================================================

/*
  # Initial Schema Setup

  1. New Tables
    - `users`
      - `id` (uuid, primary key)
      - `address` (text, unique) - Ethereum address
      - `role` (text) - User role (basic/advanced)
      - `created_at` (timestamp)
      - `last_login` (timestamp)
    
    - `queries`
      - `id` (uuid, primary key)
      - `user_id` (uuid, foreign key)
      - `query` (text)
      - `response` (text)
      - `created_at` (timestamp)

  2. Security
    - Enable RLS on all tables
    - Add policies for authenticated users
*/

-- Create users table
CREATE TABLE IF NOT EXISTS users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  address text UNIQUE NOT NULL,
  role text NOT NULL DEFAULT 'basic',
  created_at timestamptz DEFAULT now(),
  last_login timestamptz
);

-- Create queries table
CREATE TABLE IF NOT EXISTS queries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES users(id),
  query text NOT NULL,
  response text NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE queries ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can read own data"
  ON users
  FOR SELECT
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can update own data"
  ON users
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can read own queries"
  ON queries
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own queries"
  ON queries
  FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

================================================================================
File: tailwind.config.ts
================================================================================

import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      colors: {
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        chart: {
          '1': 'hsl(var(--chart-1))',
          '2': 'hsl(var(--chart-2))',
          '3': 'hsl(var(--chart-3))',
          '4': 'hsl(var(--chart-4))',
          '5': 'hsl(var(--chart-5))',
        },
      },
      keyframes: {
        'accordion-down': {
          from: {
            height: '0',
          },
          to: {
            height: 'var(--radix-accordion-content-height)',
          },
        },
        'accordion-up': {
          from: {
            height: 'var(--radix-accordion-content-height)',
          },
          to: {
            height: '0',
          },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};
export default config;


================================================================================
File: tsconfig.json
================================================================================

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "baseUrl": ".",
    "typeRoots": ["./node_modules/@types", "./types"]
  },
  "ts-node": {
    "esm": true,
    "transpileOnly": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "tests/**/*.ts",
    "types/**/*.d.ts"
  ],
  "exclude": ["node_modules"]
}